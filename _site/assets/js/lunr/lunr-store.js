var store = [{
        "title": "Backjoon 2557",
        "excerpt":"Backjoon 2557   main 클래스는 main 이라고 적어야 한다.    public class Main {     public static void main(String[] args) {         System.out.println(\"Hello World!\");     } }   ","categories": ["Backjoon"],
        "tags": [],
        "url": "http://localhost:4000/backjoon/2557/",
        "teaser": null
      },{
        "title": "Backjoon 2742",
        "excerpt":"Backjoon 2742   while 문    import java.util.Scanner;  public class Main {     public static void main(String[] args) {         Scanner sc = new Scanner(System.in);         int n = sc.nextInt();         int i = 1;                  while (i &lt;= n) {             System.out.println(n);             n--;         }         sc.close();       } }    for 문    import java.util.Scanner;  public class Main {     public static void main(String[] args) {         Scanner sc = new Scanner(System.in);         int n = sc.nextInt();         for (int i = n; i &gt;=1; i--) {             System.out.println(i);         }         sc.close();       } }   ","categories": ["Backjoon"],
        "tags": [],
        "url": "http://localhost:4000/backjoon/2742/",
        "teaser": null
      },{
        "title": "How to make ArrayList 01",
        "excerpt":"TLI How to make ArrayList   01) 인스턴스의 주소를 담을 레퍼런스 배열을 준비한다.     size = 리스트에 들어간 레퍼런스의 갯수(1부터 시작)   index = 배열의 순서(0부터 시작)   .length = 배열의 길이   public class MyArrayList { // 01     static Object[] elementData = new Object[5];     static int size; }   02) 인스턴스를 추가하는 add() 메서드 정의.   public class MyArrayList { // 01     static Object[] elementData = new Object[5];     static int size;  // 02     static public boolean add(Object e) {         elementData[size++] = e;         return true;     } }   03) 특정 인덱스의 인스턴스를 리턴하는 get(int) 메서드 정의.   public class MyArrayList { // 01     static Object[] elementData = new Object[5];     static int size;  // 02     static public boolean add(Object e) {         elementData[size++] = e;         return true;     }  // 03     static public Object get(int index) {         return elementData[index];     } }   04) 인스턴스를 특정 위치에 삽입하는 add(int, Object) 메서드 정의.   public class MyArrayList { // 01     static Object[] elementData = new Object[5];     static int size;  // 02     static public boolean add(Object e) {         elementData[size++] = e;         return true;     }  // 03     static public Object get(int index) {         return elementData[index];     }  // 04     static public void add(int index, Object element) {         // 마지막 레퍼런스(size)부터 index의 레퍼런스까지 그 다음 칸으로 옮겨넣는 작업을 반복한다.         // index - 1 다음에 index를 새로 만들어 넣는 것이기 때문에 i 는 index보다 커야한다.         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         // 지정한 인덱스에 원하는 레퍼런스를 삽입한다.         elementData[index] = element;         // 레퍼런스가 하나 늘어났으니 배열을 하나 늘려준다.         size++;     } }   05) 특정 위치의 항목을 다른 인스턴스로 교체하는 set(int, Object) 메서드 정의.   public class MyArrayList { // 01     static Object[] elementData = new Object[5];     static int size;  // 02     static public boolean add(Object e) {         elementData[size++] = e;         return true;     }  // 03     static public Object get(int index) {         return elementData[index];     }  // 04     static public void add(int index, Object element) {         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05     static public Object set(int index, Object element) {         // 지정한 index에 있는 값을 새로운 변수를 만들어 넣어준다.         Object old = elementData[index];         // 지정한 index에 새 값을 넣는다.         elementData[index] = element;         // old 값을 리턴한다.         return old;     } }   06) 특정 위치의 항목을 제거하는 remove(int) 메서드를 정의.   public class MyArrayList { // 01     static Object[] elementData = new Object[5];     static int size;  // 02     static public boolean add(Object e) {         elementData[size++] = e;         return true;     }  // 03     static public Object get(int index) {         return elementData[index];     }  // 04     static public void add(int index, Object element) {         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05     static public Object set(int index, Object element) {         Object old = elementData[index];         elementData[index] = element;         return old;     }  // 06     static public Object remove(int index) {         // 지정한 index의 레퍼런스를 새 변수에 담는다.         Object old = elementData[index];         // index에 들어있는 레퍼런스를 지우려면 index + 1, index + 2 ... size - 1(인덱스는 0부터, 사이즈는 1부터 시작하기 때문에 사이즈에서 -1을 빼야 배열의 마지막 인덱스 번호를 구할 수 있다) 번째까지의 레퍼런스를 한칸씩 앞으로 당겨넣는다.         for (int i = index; i &lt; size - 1; i++) {             elementData[i] = elementData[i +1];         }         // 레퍼런스가 하나 줄었으므로 배열도 하나 줄인다.         size--;         return old     } }   07) add() 할 때 배열의 크기를 넘는 경우 배열의 크기를 늘린다.   public class MyArrayList { // 01     static Object[] elementData = new Object[5];     static int size;  // 02 // 07     static public boolean add(Object e) {         // 07의 grow() 호출         // size와 배열의 길이가 같을 경우 배열을 늘려준다.         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03     static public Object get(int index) {         return elementData[index];     }  // 04     static public void add(int index, Object element) {         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05     static public Object set(int index, Object element) {         Object old = elementData[index];         elementData[index] = element;         return old;  // 06     static public Object remove(int index) {         Object old = elementData[index];         for (int i = index; i &lt; size - 1; i++) {             elementData[i] = elementData[i +1];         }         size--;         return old     }  // 07 - 02의 add()에서 grow() 호출     static void grow() {         // static 배열은 여러개 만들 수 없다.         // 그러므로 새 배열을 만들어 기존의 배열을 복사 붙여넣기 한 다음 새 배열의 주소를 기존 배열의 주소가 들어있던 곳에 넣어준다.         // 새 배열의 길이는 보통 기존 배열 길이의 절반을 덧붙여 만든다.         // 비트 연산자를 쓰는 경우가 많다. (&gt;&gt; 1 == / 2)         Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         // 기존의 배열을 새로운 배열에 복사 붙여넣기 한다.         // i = index를 말한다.         for (int i = 0; i &lt; elementData.length; i++) {             newArray[i] = elementData[i];         }         // 새 배열의 주소를 기존 배열의 주소를 넣던 곳에 넣어준다.         elementData = newArray;     } }   08) add(int, Object)로 임의의 위치에 삽입할 때     배열의 크기가 작으면 늘린다.   인덱스가 유효하지 않으면 예외를 발생시킨다.   public class MyArrayList { // 01     static Object[] elementData = new Object[5];     static int size;  // 02     static public boolean add(Object e) {         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03     static public Object get(int index) {         return elementData[index];     }  // 04 // 08     static public void add(int index, Object element) {         // 배열을 늘린다.         if (size == elementData.length) {             grow();         }         // index의 범위를 지정하고 예외 발생시킨다.         if (index &lt; 0 || index &gt; size) {             throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05     static public Object set(int index, Object element) {         Object old = elementData[index];         elementData[index] = element;         return old;  // 06     static public Object remove(int index) {         Object old = elementData[index];         for (int i = index; i &lt; size - 1; i++) {             elementData[i] = elementData[i +1];         }         size--;         return old     }  // 07      static void grow() {         Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         for (int i = 0; i &lt; elementData.length; i++) {             newArray[i] = elementData[i];         }         elementData = newArray;     } }   09) get(int)으로 유효하지 않은 인덱스의 값을 꺼낼 때 예외를 발생시킨다.   public class MyArrayList { // 01     static Object[] elementData = new Object[5];     static int size;  // 02     static public boolean add(Object e) {         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03 // 09     static public Object get(int index) {         // index의 범위를 지정         // size는 index보다 1이 크기 때문에 index가 size 보다 크거나 같으면 범위를 벗어난다.         // 예: size가 12345 일 때 index는 01234 이다.         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         return elementData[index];     }  // 04 // 08     static public void add(int index, Object element) {         if (size == elementData.length) {             grow();         }         if (index &lt; 0 || index &gt; size) {             throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05     static public Object set(int index, Object element) {         Object old = elementData[index];         elementData[index] = element;         return old;  // 06 // 10     static public Object remove(int index) {         Object old = elementData[index];         for (int i = index; i &lt; size - 1; i++) {             elementData[i] = elementData[i +1];         }         size--;         return old     }  // 07      static void grow() {         Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         for (int i = 0; i &lt; elementData.length; i++) {             newArray[i] = elementData[i];         }         elementData = newArray;     } }   10) remove()를 수행한 다음 맨 끝에 남아있는 주소를 null로 설정하여 인스턴스의 레퍼런스 카운트를 한 개 줄인다.   public class MyArrayList { // 01     static Object[] elementData = new Object[5];     static int size;  // 02     static public boolean add(Object e) {         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03 // 09     static public Object get(int index) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         return elementData[index];     }  // 04 // 08     static public void add(int index, Object element) {         if (size == elementData.length) {             grow();         }         if (index &lt; 0 || index &gt; size) {             throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05     static public Object set(int index, Object element) {         Object old = elementData[index];         elementData[index] = element;         return old;  // 06 // 10     static public Object remove(int index) {         Object old = elementData[index];         for (int i = index; i &lt; size - 1; i++) {             elementData[i] = elementData[i +1];         }         size--;          // 쓰지않는 인스턴스의 주소를 제거하여 가비지가 될 수 있게 한다.         elementData[size] = null;         return old     }  // 07      static void grow() {         Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         for (int i = 0; i &lt; elementData.length; i++) {             newArray[i] = elementData[i];         }         elementData = newArray;     } }  ","categories": ["Howto"],
        "tags": [],
        "url": "http://localhost:4000/howto/HowtoMakeArrayList01/",
        "teaser": null
      },{
        "title": "How to make ArrayList 02",
        "excerpt":"TLI How to make ArrayList02   11) set()을 호출할 때 인덱스가 유효하지 않으면 예외를 발생시킨다.   public class MyArrayList { // 01     static Object[] elementData = new Object[5];     static int size;  // 02     static public boolean add(Object e) {         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03 // 09     static public Object get(int index) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         return elementData[index];     }  // 04 // 08     static public void add(int index, Object element) {         if (size == elementData.length) {             grow();         }         if (index &lt; 0 || index &gt; size) {             throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05 // 11     static public Object set(int index, Object element) {         // index의 범위를 지정         // size는 index보다 1이 크기 때문에 index가 size 보다 크거나 같으면 범위를 벗어난다.         // 예: size가 12345 일 때 index는 01234 이다.         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Object old = elementData[index];         elementData[index] = element;         return old;  // 06 // 10     static public Object remove(int index) {         Object old = elementData[index];         for (int i = index; i &lt; size - 1; i++) {             elementData[i] = elementData[i +1];         }         size--;         elementData[size] = null;         return old     }  // 07      static void grow() {         Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         for (int i = 0; i &lt; elementData.length; i++) {             newArray[i] = elementData[i];         }         elementData = newArray;     } }   12) 여러개의 목록을 동시에 관리할 수 있도록 MyArrayList에 선언된 레퍼런스 배열을 스태틱 대신 인스턴스로 전환한다.     개별적으로 관리해야 할 데이터는 인스턴스 변수를 사용해야 한다.   public class MyArrayList { // 01 // 12     Object[] elementData = new Object[5];     int size;  // 02 // 12     public boolean add(Object e) {         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03 // 09 // 12     public Object get(int index) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         return elementData[index];     }  // 04 // 08 // 12     public void add(int index, Object element) {         if (size == elementData.length) {             grow();         }         if (index &lt; 0 || index &gt; size) {             throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05 // 11 // 12     public Object set(int index, Object element) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Object old = elementData[index];         elementData[index] = element;         return old;  // 06 // 10 // 12     public Object remove(int index) {         Object old = elementData[index];         for (int i = index; i &lt; size - 1; i++) {             elementData[i] = elementData[i +1];         }         size--;         elementData[size] = null;         return old     }  // 07      static void grow() {         Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         for (int i = 0; i &lt; elementData.length; i++) {             newArray[i] = elementData[i];         }         elementData = newArray;     } }   13) 캡슐화를 적용하여 공개할 멤버와 공개하지 말아야 할 멤버를 구분한다.   public class MyArrayList { // 01 // 12 // 13     private Object[] elementData = new Object[5];     private int size;  // 13      // size에 직접적으로 접속할 수 없으니 생성자를 만들어 준다.     public int size() {         return this.size;     }  // 02 // 12     public boolean add(Object e) {         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03 // 09 // 12     public Object get(int index) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         return elementData[index];     }  // 04 // 08 // 12     public void add(int index, Object element) {         if (size == elementData.length) {             grow();         }         if (index &lt; 0 || index &gt; size) {             throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05 // 11 // 12     public Object set(int index, Object element) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Object old = elementData[index];         elementData[index] = element;         return old;  // 06 // 10 // 12     public Object remove(int index) {         Object old = elementData[index];         for (int i = index; i &lt; size - 1; i++) {             elementData[i] = elementData[i +1];         }         size--;         elementData[size] = null;         return old     }  // 07 // 13     private static void grow() {         Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         for (int i = 0; i &lt; elementData.length; i++) {             newArray[i] = elementData[i];         }         elementData = newArray;     } }   14) ArrayList 인스턴스를 생성할 때 배열의 초기 크기를 설정할 수 있도록 생성자를 추가한다.   public class MyArrayList { // 01 // 12 // 13 // 14     private Object[] elementData;     private int size;  // 14     public MyArrayList() {         elementData = new Object[5];     }  // 13      public int size() {         return this.size;     }  // 14      public MyArrayList(int initialCapacity) {         elementData = new Object[initialCapacity];     }  // 02 // 12     public boolean add(Object e) {         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03 // 09 // 12     public Object get(int index) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         return elementData[index];     }  // 04 // 08 // 12     public void add(int index, Object element) {         if (size == elementData.length) {             grow();         }         if (index &lt; 0 || index &gt; size) {             throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05 // 11 // 12     public Object set(int index, Object element) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Object old = elementData[index];         elementData[index] = element;         return old;  // 06 // 10 // 12     public Object remove(int index) {         Object old = elementData[index];         for (int i = index; i &lt; size - 1; i++) {             elementData[i] = elementData[i +1];         }         size--;         elementData[size] = null;         return old     }  // 07 // 13     private static void grow() {         Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         for (int i = 0; i &lt; elementData.length; i++) {             newArray[i] = elementData[i];         }         elementData = newArray;     } }   15) ArrayList 인스턴스를 생성할 때 초기 크기를 지정하지 않고 생성할 수 있도록 기본 생성자를 추가한다.   public class MyArrayList { // 01 // 12 // 13 // 15     private Object[] elementData;     private int size;  // 13      public int size() {         return this.size;     }  // 14      public MyArrayList(int initialCapacity) {         elementData = new Object[initialCapacity];     }  // 15     public MyArrayList() {         elementData = new Object[5];     }  // 02 // 12     public boolean add(Object e) {         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03 // 09 // 12     public Object get(int index) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         return elementData[index];     }  // 04 // 08 // 12     public void add(int index, Object element) {         if (size == elementData.length) {             grow();         }         if (index &lt; 0 || index &gt; size) {             throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05 // 11 // 12     public Object set(int index, Object element) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Object old = elementData[index];         elementData[index] = element;         return old;  // 06 // 10 // 12     public Object remove(int index) {         Object old = elementData[index];         for (int i = index; i &lt; size - 1; i++) {             elementData[i] = elementData[i +1];         }         size--;         elementData[size] = null;         return old     }  // 07 // 13     private static void grow() {         Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         for (int i = 0; i &lt; elementData.length; i++) {             newArray[i] = elementData[i];         }         elementData = newArray;     } }   16) 배열 크기를 지정할 때 기본 크기보다 큰 값이 되도록 생성자를 변경한다. (기본 크기를 5로 가정)   public class MyArrayList { // 01 // 12 // 13 // 15     private Object[] elementData;     private int size;  // 13      public int size() {         return this.size;     }  // 14 // 16     public MyArrayList(int initialCapacity) {         // 기본 크기보다 size가 작으면 배열을 기본 크기만큼만 만들고         if (initialCapacity &lt; 5) {             elementData = new Object[5];         // 그 외에는 size 만큼 배열을 만든다.         } else {             elementData = new Object[initialCapacity];         }     }  // 15     public MyArrayList() {         elementData = new Object[5];     }  // 02 // 12     public boolean add(Object e) {         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03 // 09 // 12     public Object get(int index) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         return elementData[index];     }  // 04 // 08 // 12     public void add(int index, Object element) {         if (size == elementData.length) {             grow();         }         if (index &lt; 0 || index &gt; size) {             throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05 // 11 // 12     public Object set(int index, Object element) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Object old = elementData[index];         elementData[index] = element;         return old;  // 06 // 10 // 12     public Object remove(int index) {         Object old = elementData[index];         for (int i = index; i &lt; size - 1; i++) {             elementData[i] = elementData[i +1];         }         size--;         elementData[size] = null;         return old     }  // 07 // 13     private static void grow() {         Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         for (int i = 0; i &lt; elementData.length; i++) {             newArray[i] = elementData[i];         }         elementData = newArray;     } }   17) 배열의 기본 크기를 직접 숫자로 지정하지 말고 상수를 사용하여 지정한다.   public class MyArrayList { // 17     private static final int DEFAULT_CAPACITY = 5;  // 01 // 12 // 13 // 15     private Object[] elementData;     private int size;  // 13      public int size() {         return this.size;     }  // 14 // 16 // 17     public MyArrayList(int initialCapacity) {         if (initialCapacity &lt; DEFAULT_CAPACITY) {             elementData = new Object[DEFAULT_CAPACITY];         } else {             elementData = new Object[initialCapacity];         }     }  // 15 // 17     public MyArrayList() {         elementData = new Object[DEFAULT_CAPACITY];     }  // 02 // 12     public boolean add(Object e) {         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03 // 09 // 12     public Object get(int index) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         return elementData[index];     }  // 04 // 08 // 12     public void add(int index, Object element) {         if (size == elementData.length) {             grow();         }         if (index &lt; 0 || index &gt; size) {             throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05 // 11 // 12     public Object set(int index, Object element) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Object old = elementData[index];         elementData[index] = element;         return old;  // 06 // 10 // 12     public Object remove(int index) {         Object old = elementData[index];         for (int i = index; i &lt; size - 1; i++) {             elementData[i] = elementData[i +1];         }         size--;         elementData[size] = null;         return old     }  // 07 // 13     private static void grow() {         Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         for (int i = 0; i &lt; elementData.length; i++) {             newArray[i] = elementData[i];         }         elementData = newArray;     } }   18) 배열의 크기를 늘릴 때 자바에서 제공하는 Arrays를 사용하여 처리한다.   public class MyArrayList { // 17     private static final int DEFAULT_CAPACITY = 5;  // 01 // 12 // 13 // 15     private Object[] elementData;     private int size;  // 13      public int size() {         return this.size;     }  // 14 // 16 // 17     public MyArrayList(int initialCapacity) {         if (initialCapacity &lt; DEFAULT_CAPACITY) {             elementData = new Object[DEFAULT_CAPACITY];         } else {             elementData = new Object[initialCapacity];         }     }  // 15 // 17     public MyArrayList() {         elementData = new Object[DEFAULT_CAPACITY];     }  // 02 // 12     public boolean add(Object e) {         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03 // 09 // 12     public Object get(int index) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         return elementData[index];     }  // 04 // 08 // 12     public void add(int index, Object element) {         if (size == elementData.length) {             grow();         }         if (index &lt; 0 || index &gt; size) {             throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05 // 11 // 12     public Object set(int index, Object element) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Object old = elementData[index];         elementData[index] = element;         return old;  // 06 // 10 // 12     public Object remove(int index) {         Object old = elementData[index];         for (int i = index; i &lt; size - 1; i++) {             elementData[i] = elementData[i +1];         }         size--;         elementData[size] = null;         return old     }  // 07 // 13 // 18     private static void grow() {         // for 문을 사용해서 반복문을 쓰지 않아도 간편하게 배열을 늘릴 수 있다.         // 길이가 늘어난 새로운 배열을 만들고         int newCapacity = elementData.length + (elementData.length &gt;&gt; 1);         // 그 배열의 레퍼런스를 기존 배열의 레퍼런스가 들어있던 곳에 넣는다.         // Arrays.copyOf(기존배열, 새 배열);         elementData = Arrrays.copyOf(elementData, newCapacity);         // Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         // for (int i = 0; i &lt; elementData.length; i++) {         //     newArray[i] = elementData[i];         // }         // elementData = newArray;     } }   19) 배열의 특정 항목을 삭제할 때 배열 복사 기능을 이용하여 처리한다.   public class MyArrayList { // 17     private static final int DEFAULT_CAPACITY = 5;  // 01 // 12 // 13 // 15     private Object[] elementData;     private int size;  // 13      public int size() {         return this.size;     }  // 14 // 16 // 17     public MyArrayList(int initialCapacity) {         if (initialCapacity &lt; DEFAULT_CAPACITY) {             elementData = new Object[DEFAULT_CAPACITY];         } else {             elementData = new Object[initialCapacity];         }     }  // 15 // 17     public MyArrayList() {         elementData = new Object[DEFAULT_CAPACITY];     }  // 02 // 12     public boolean add(Object e) {         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03 // 09 // 12     public Object get(int index) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         return elementData[index];     }  // 04 // 08 // 12     public void add(int index, Object element) {         if (size == elementData.length) {             grow();         }         if (index &lt; 0 || index &gt; size) {             throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05 // 11 // 12     public Object set(int index, Object element) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Object old = elementData[index];         elementData[index] = element;         return old;  // 06 // 10 // 12 // 19     public Object remove(int index) {         Object old = elementData[index];          System.arraycopy(             elementData,            // 복사 대상             index + 1,              // 복사할 항목의 시작 인덱스             elementData,            // 목적지             index,                  // 복사 목적지 인덱스             // 인덱스가 0부터 시작하기 때문에 갯수는 +1을 해줘야 한다             this.size - (index + 1) // 복사할 항목의 갯수         );         // for (int i = index; i &lt; size - 1; i++) {         //     elementData[i] = elementData[i +1];         // }         size--;         elementData[size] = null;         return old     }  // 07 // 13 // 18     private static void grow() {         int newCapacity = elementData.length + (elementData.length &gt;&gt; 1);         elementData = Arrrays.copyOf(elementData, newCapacity);         // Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         // for (int i = 0; i &lt; elementData.length; i++) {         //     newArray[i] = elementData[i];         // }         // elementData = newArray;     } }   ArrayList에 보관되어 있는 인스턴스 목록을 배열로 리턴하는 toArray() 메서드를 추가한다.   public class MyArrayList { // 17     private static final int DEFAULT_CAPACITY = 5;  // 01 // 12 // 13 // 15     private Object[] elementData;     private int size;  // 13      public int size() {         return this.size;     }  // 14 // 16 // 17     public MyArrayList(int initialCapacity) {         if (initialCapacity &lt; DEFAULT_CAPACITY) {             elementData = new Object[DEFAULT_CAPACITY];         } else {             elementData = new Object[initialCapacity];         }     }  // 15 // 17     public MyArrayList() {         elementData = new Object[DEFAULT_CAPACITY];     }  // 02 // 12     public boolean add(Object e) {         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03 // 09 // 12     public Object get(int index) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         return elementData[index];     }  // 04 // 08 // 12     public void add(int index, Object element) {         if (size == elementData.length) {             grow();         }         if (index &lt; 0 || index &gt; size) {             throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05 // 11 // 12     public Object set(int index, Object element) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Object old = elementData[index];         elementData[index] = element;         return old;  // 06 // 10 // 12 // 19     public Object remove(int index) {         Object old = elementData[index];          System.arraycopy(             elementData,                        index + 1,                           elementData,                         index,                               this.size - (index + 1)          );         // for (int i = index; i &lt; size - 1; i++) {         //     elementData[i] = elementData[i +1];         // }         size--;         elementData[size] = null;         return old     }  // 07 // 13 // 18     private static void grow() {         int newCapacity = elementData.length + (elementData.length &gt;&gt; 1);         elementData = Arrrays.copyOf(elementData, newCapacity);         // Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         // for (int i = 0; i &lt; elementData.length; i++) {         //     newArray[i] = elementData[i];         // }         // elementData = newArray;     }  // 20     public Object[] toArray() {         Object[] arr = new Object[this.size];         // i는 인덱스         for (int i = 0; i &lt; arr.length; i++) {             arr[i] = elementData[i];         }         return arr;     } }   21) toArray()에서 배열을 복사할 때 Arrays.copyOf() 메서드를 활용한다.   public class MyArrayList { // 17     private static final int DEFAULT_CAPACITY = 5;  // 01 // 12 // 13 // 15     private Object[] elementData;     private int size;  // 13      public int size() {         return this.size;     }  // 14 // 16 // 17     public MyArrayList(int initialCapacity) {         if (initialCapacity &lt; DEFAULT_CAPACITY) {             elementData = new Object[DEFAULT_CAPACITY];         } else {             elementData = new Object[initialCapacity];         }     }  // 15 // 17     public MyArrayList() {         elementData = new Object[DEFAULT_CAPACITY];     }  // 02 // 12     public boolean add(Object e) {         if (size == elementData.length) {             grow();         }         elementData[size++] = e;         return true;     }  // 03 // 09 // 12     public Object get(int index) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         return elementData[index];     }  // 04 // 08 // 12     public void add(int index, Object element) {         if (size == elementData.length) {             grow();         }         if (index &lt; 0 || index &gt; size) {             throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         for (int i = size; i &gt; index; i--) {             elementData[i] = elementData[i - 1];         }         elementData[index] = element;         size++;     }  // 05 // 11 // 12     public Object set(int index, Object element) {         if (index &lt; 0 || index &gt;= size) {         throw new ArrayIndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Object old = elementData[index];         elementData[index] = element;         return old;  // 06 // 10 // 12 // 19     public Object remove(int index) {         Object old = elementData[index];          System.arraycopy(             elementData,                        index + 1,                           elementData,                         index,                               this.size - (index + 1)          );         // for (int i = index; i &lt; size - 1; i++) {         //     elementData[i] = elementData[i +1];         // }         size--;         elementData[size] = null;         return old     }  // 07 // 13 // 18     private static void grow() {         int newCapacity = elementData.length + (elementData.length &gt;&gt; 1);         elementData = Arrrays.copyOf(elementData, newCapacity);         // Object[] newArray = new Object[elementData.length + (elementData.lengt &gt;&gt; 1)];         // for (int i = 0; i &lt; elementData.length; i++) {         //     newArray[i] = elementData[i];         // }         // elementData = newArray;     }  // 20     public Object[] toArray() {         // copyOf​(original, int newLength)         Object[] arr = Arrays.copyOf(elementData, this.size);         return arr;         // Object[] arr = new Object[this.size];         // for (int i = 0; i &lt; arr.length; i++) {         //     arr[i] = elementData[i];         // }         // return arr;     } }  ","categories": ["Howto"],
        "tags": [],
        "url": "http://localhost:4000/howto/HowtoMakeArrayList02/",
        "teaser": null
      },{
        "title": "How to make LinkedList 01",
        "excerpt":"TLI How to make LinkedList   01) LinkedList 클래스 정의   // 01 public class MyLinkedList {  }   02) 값을 담을 노드 클래스를 설계한다.   // 01 public class MyLinkedList {  // 02     // 용도?     // - Node 클래스는 목록에서 각 항목의 값을 보관하는 객체로 역할을 수행한다.     // 스태틱 클래스?     // - 여러개의 MyLinkedList 객체가 공요하는 클래스이기 때문에 static으로 node 클래스를 설계한다.     static class Node {         Object value;         Node next;     } }   03) 첫번째 노드와 마지막 노드의 주소를 담을 필드와 목록 크기를 저장할 필드를 추가한다.   // 01 public class MyLinkedList {          // 03     // 값을 찾을때는 첫번째 노드부터 따라간다.     Node first;     // 값을 추가할 때는 마지막 노드에 연결한다.     Node last;     // MyLinkedList 목록 크기를 보관한다.     int size;  // 02     static class Node {         Object value;         Node next;     } }   04) 목록에 값을 추가하는 add() 메서드를 정의한다.   // 01 public class MyLinkedList {  // 03     Node first;     Node last;     int size;  // 02     static class Node {         Object value;         Node next;     }  // 04     public boolean add(Object e) {         Node node = new Node();         node.value = e;          // first 변수가 null이면 first 변수에 node 주소를 넣고         if (first == null) {             first = node;         // first 변수가 null이 아니면 last 변수(노드?)의 next 부분에 node 주소를 넣는다.         } else {             last.next = node;         }         // last 변수에 node new node 주소를 넣는다.         last = node;         size++;         return true;     } }   05) 목록에서 값을 조회하는 get() 메서드를 정의한다.   // 01 public class MyLinkedList {  // 03     Node first;     Node last;     int size;  // 02     static class Node {         Object value;         Node next;     }  // 04     public boolean add(Object e) {         Node node = new Node();         node.value = e;          if (first == null) {             first = node;         } else {             last.next = node;         }         last = node;         size++;         return true;     }  // 05     public Object get(int index) {         if (index &lt; 0 || index &gt;= this.size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         // node를 가리키는 cursor를 사용한다.         // 커서는 처음 node부터 순서대로 움직인다.         // 오른쪽에서부터 실행한다.         // cursor.next 변수의 주소값을 cursor에 넣는다.         Node cursor = this.first;         for (int i = 1; i &lt;= index; i++) {             cursor = cursor.next;         }         return cursor.value;     } }   06) 목록에서 특정 인덱스 위치에 값을 삽입하는 add(in, Object) 메서드를 정의한다.     Node의 생성자를 추가한다.   // 01 public class MyLinkedList {  // 03      Node first;     Node last;     int size;  // 02 // 06     static class Node {         Object value;         Node next;          // 기본 생성자와 value를 파라미터로 가지는 생성자를 만든다.         public Node() {}         public Node(Object value) {             this.value = value;         }     }  // 04     public boolean add(Object e) {         Node node = new Node();         node.value = e;          if (first == null) {             first = node;         } else {             last.next = node;         }         last = node;         size++;         return true;     }  // 05     public Object get(int index) {         if (index &lt; 0 || index &gt;= this.size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Node cursor = this.first;         for (int i = 1; i &lt;= index; i++) {             cursor = cursor.next;         }         return cursor.value;     }  // 06     public void add(int index, Object element) {         // index == size 면 마지막에 붙이는 것이 되어 인덱스가 유효하다.         if (index &lt; 0 || index &gt; size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Node node = new Node(element);         size++;          // 인덱스가 0 이면 first 주소를 변경해서 first Node를 바꿔줘야 한다.         if (index == 0) {             node.next = first;             first = node;             return;         }         // 커서는 인덱스 바로 전까지 움직인다.         Node cursor = this.first;         for (int i = 1; i &lt;= index - 1; i++) {             cursor = cursor.next;         }         // 커서가 가리키는 노드의 next 값을 삽입하려는 node의 next에 넣어준다.         node.next = cursor.next;         // 노드의 주소를 커서가 가리키는 노드의 next에 넣는다.         cursor.next = node;          // 마지막에 삽입한 후에는 last를 바꿔줘야 한다.         // 마지막 노드의 next는 null인 것을 이용한다.         if (node.next == null) {             last = node;         }     } }   07) 목록에서 특정 인덱스의 값을 제거하는 remove(int) 메서드를 정의한다.   // 01 public class MyLinkedList {  // 03      Node first;     Node last;     int size;  // 02 // 06     static class Node {         Object value;         Node next;          public Node() {}         public Node(Object value) {             this.value = value;         }     }  // 04     public boolean add(Object e) {         Node node = new Node();         node.value = e;          if (first == null) {             first = node;         } else {             last.next = node;         }         last = node;         size++;         return true;     }  // 05     public Object get(int index) {         if (index &lt; 0 || index &gt;= this.size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Node cursor = this.first;         for (int i = 1; i &lt;= index; i++) {             cursor = cursor.next;         }         return cursor.value;     }  // 06     public void add(int index, Object element) {         if (index &lt; 0 || index &gt; size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Node node = new Node(element);         size++;          if (index == 0) {             node.next = first;             first = node;             return;         }          Node cursor = this.first;         for (int i = 1; i &lt;= index - 1; i++) {             cursor = cursor.next;         }          node.next = cursor.next;         cursor.next = node;          if (node.next == null) {             last = node;         }     }      public Object remove(int value) {         if (index &lt; 0 || index &gt;= this.size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         size--;          if (index == 0) {             Node old = first;             first = old.next;             // 가비지가 다른 인스턴스를 가리키지 않게 한다.             old.next = null;             return old.value;         }                  // 커서는 오른쪽 처음에서부터 인덱스 바로 전까지 움직인다.         Node cursor = this.first;         for (int i = 1; i &lt;= index - 1; i++) {             cursor = cursor.next;         }          // 가비지가 다른 인스턴스를 가리키지 않게 한다.         Node old = cursor.next;         cursor.next = old.next;         old.next = null;          if (cursor.next == null) {             last = cursor;         }         return old.value;      } }   08) 목록에서 특정 인덱스의 값을 바꾸는 set(int, Object) 메서드를 정의한다.   // 01 public class MyLinkedList {  // 03      Node first;     Node last;     int size;  // 02 // 06     static class Node {         Object value;         Node next;          public Node() {}         public Node(Object value) {             this.value = value;         }     }  // 04     public boolean add(Object e) {         Node node = new Node();         node.value = e;          if (first == null) {             first = node;         } else {             last.next = node;         }         last = node;         size++;         return true;     }  // 05     public Object get(int index) {         if (index &lt; 0 || index &gt;= this.size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Node cursor = this.first;         for (int i = 1; i &lt;= index; i++) {             cursor = cursor.next;         }         return cursor.value;     }  // 06     public void add(int index, Object element) {         if (index &lt; 0 || index &gt; size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Node node = new Node(element);         size++;          if (index == 0) {             node.next = first;             first = node;             return;         }          Node cursor = this.first;         for (int i = 1; i &lt;= index - 1; i++) {             cursor = cursor.next;         }          node.next = cursor.next;         cursor.next = node;          if (node.next == null) {             last = node;         }     }  // 07     public Object remove(int value) {         if (index &lt; 0 || index &gt;= this.size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         size--;          if (index == 0) {             Node old = first;             first = old.next;             old.next = null;             return old.value;         }          Node cursor = this.first;         for (int i = 1; i &lt;= index - 1; i++) {             cursor = cursor.next;         }          Node old = cursor.next;         cursor.next = old.next;         old.next = null;          if (cursor.next == null) {             last = cursor;         }         return old.value;     }  // 08     public Object set(int index, Object element) {         if (index &lt; 0 || index &gt;= this.size) {         throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");     }          Node cursor = this.first;         for (int i = 1; i &lt;= index; i++) {         cursor = cursor.next;         }          Object old = cursor.value;         cursor.value = element;          return old;   } }   09) 목록의 데이터를 새 배열에 담아 리턴하는 toArray() 메소드를 정의한다.   // 01 public class MyLinkedList {  // 03      Node first;     Node last;     int size;  // 02 // 06     static class Node {         Object value;         Node next;          public Node() {}         public Node(Object value) {             this.value = value;         }     }  // 04     public boolean add(Object e) {         Node node = new Node();         node.value = e;          if (first == null) {             first = node;         } else {             last.next = node;         }         last = node;         size++;         return true;     }  // 05     public Object get(int index) {         if (index &lt; 0 || index &gt;= this.size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Node cursor = this.first;         for (int i = 1; i &lt;= index; i++) {             cursor = cursor.next;         }         return cursor.value;     }  // 06     public void add(int index, Object element) {         if (index &lt; 0 || index &gt; size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Node node = new Node(element);         size++;          if (index == 0) {             node.next = first;             first = node;             return;         }          Node cursor = this.first;         for (int i = 1; i &lt;= index - 1; i++) {             cursor = cursor.next;         }          node.next = cursor.next;         cursor.next = node;          if (node.next == null) {             last = node;         }     }  // 07     public Object remove(int value) {         if (index &lt; 0 || index &gt;= this.size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         size--;          if (index == 0) {             Node old = first;             first = old.next;             old.next = null;             return old.value;         }          Node cursor = this.first;         for (int i = 1; i &lt;= index - 1; i++) {             cursor = cursor.next;         }          Node old = cursor.next;         cursor.next = old.next;         old.next = null;          if (cursor.next == null) {             last = cursor;         }         return old.value;     }  // 08     public Object set(int index, Object element) {         if (index &lt; 0 || index &gt;= this.size) {         throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }          Node cursor = this.first;         for (int i = 1; i &lt;= index; i++) {         cursor = cursor.next;         }          Object old = cursor.value;         cursor.value = element;          return old;     }  // 09     public Object[] toArray() {         Object[] arr = new Object[this.size];          int i = 0;         Node cursor = first;         while (cursor != null) {             arr[i++] = cursor.value;             cursor = cursor.next;         }         return arr;     } }   10) 인스턴스 필드에 대해 캡슐화를 적용한다.      목록 크기를 리턴하는 size()를 추가로 정의한다.   // 01 public class MyLinkedList {  // 03 // 10     private Node first;     private Node last;     private int size;  // 02 // 06     static class Node {         Object value;         Node next;          public Node() {}         public Node(Object value) {             this.value = value;         }     }  // 04     public boolean add(Object e) {         Node node = new Node();         node.value = e;          if (first == null) {             first = node;         } else {             last.next = node;         }         last = node;         size++;         return true;     }  // 05     public Object get(int index) {         if (index &lt; 0 || index &gt;= this.size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Node cursor = this.first;         for (int i = 1; i &lt;= index; i++) {             cursor = cursor.next;         }         return cursor.value;     }  // 06     public void add(int index, Object element) {         if (index &lt; 0 || index &gt; size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         Node node = new Node(element);         size++;          if (index == 0) {             node.next = first;             first = node;             return;         }          Node cursor = this.first;         for (int i = 1; i &lt;= index - 1; i++) {             cursor = cursor.next;         }          node.next = cursor.next;         cursor.next = node;          if (node.next == null) {             last = node;         }     }  // 07     public Object remove(int value) {         if (index &lt; 0 || index &gt;= this.size) {             throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }         size--;          if (index == 0) {             Node old = first;             first = old.next;             old.next = null;             return old.value;         }          Node cursor = this.first;         for (int i = 1; i &lt;= index - 1; i++) {             cursor = cursor.next;         }          Node old = cursor.next;         cursor.next = old.next;         old.next = null;          if (cursor.next == null) {             last = cursor;         }         return old.value;     }  // 08     public Object set(int index, Object element) {         if (index &lt; 0 || index &gt;= this.size) {         throw new IndexOutOfBoundsException(\"인덱스가 유효하지 않습니다.\");         }          Node cursor = this.first;         for (int i = 1; i &lt;= index; i++) {         cursor = cursor.next;         }          Object old = cursor.value;         cursor.value = element;          return old;     }  // 09     public Object[] toArray() {         Object[] arr = new Object[this.size];          int i = 0;         Node cursor = first;         while (cursor != null) {             arr[i++] = cursor.value;             cursor = cursor.next;         }         return arr;     }  // 10     public int size() {         return this.size;     } }  ","categories": ["Howto"],
        "tags": [],
        "url": "http://localhost:4000/howto/HowtoMakeLinkedList01/",
        "teaser": null
      },{
        "title": "Queue, Stack",
        "excerpt":"2020-08-18 TLI   Internationalization(국제화) vs Localization(지역화)     약자 : i18n, l10n   한국어를 영어로 바꾸는 것이 국제화, 영어를 한국어로 바꾸는 것을 지역화라고 한다.   Queue   First In First Out(FIFO)     offer() 로 삽입한 값은 poll()을 통해 추출한다.   맨 처음 넣은 것이 가장 먼저 나오는 선입선출을 따른다.(긴 통에 한쪽 끝에선 공을 넣고 다른 쪽 끝에선 공을 꺼내는 형상)   peek()은 조회만 하고 poll()은 조회를 한 값을 지운다.   Stack   First In Last out(FILO) 혹은  Last In First Out(LIFO)     push()로 삽입한 값은 pop()을 통해 추출한다.   맨 나중에 넣은 것이 가장 먼저 나오는 후입선출을 따른다.(입구와 출구가 한곳밖에 없다. 통 안에 판을 하나씩 넣었다가 꺼내는 형상)   HashSet        HashMap   클래스 관계 (주어 가 목적어 를 사용/포함한다.) - 의존 관계     01) 상속   02) 연관(Association)            지속성이 있다.       사용체에서 피사용체로 화살표를 그린다.       목적어를 사용하기 때문에 목적어 없이는 주어가 성립하지 않는다.           03) 집합(Aggregation)            사용체(빈 마름모)에서 피사용체로 화살표를 그린다.       lifecycle이 다르다.                    예) 컴퓨터와 모니터, 마우스, 키보드.           예) 사람과 핸드폰.           컨테이너가 사라질 때 아이템은 남는다.                       포함관계 (주어 가 목적어 를 포함한다. 능동목적어 쪽으로 화살표가 간다.)           04) 합성(Compositon)            사용체(채워진 마름모)에서 피사용체로 화살표를 그린다.       lifecycle이 같다.                    예) 컴퓨터와 메인보드, 파워서플라이.           예) 사람과 심장.           링크드리스트 -&gt; 노드           컨테이너가 사라질 때 아이템도 사라진다.                       포함관계 (주어 가 목적어 를 포함한다. 능동목적어 쪽으로 화살표가 간다.)           05) 의존(Dependency)            사용체에서 피사용체로 실선으로 화살표를 그린다.       특정 메소드에서만 사용되는 관계(기능을 사용하려면 일시적으로 의존하는 수 밖에 없다.)           의존객체(쓰임을 당하는 객체)     의존 관계에서 사용을 당하는 객체를 의존객체(Dependency Object)라고 한다.   동기화와 비동기화     동기화가 되어 있으면 하나의 스레드가 특정 코드에 접속할 때 락으로 잠근다.   작업을 끝내고 락을 풀면 다른 스레드가 접속할 수 있다.   StringBuilder는 동기화가 되어 있지만 No guarantee이다.(다른 스레드가 접속해서 문자열을 추가하는 것을 막지 않는다.)   로컬 변수일 경우는 여러 스레드가 접속할 수 없기 때문에 StringBuffer(락을 걸고 개런티가 있음)가 아니라 StringBuilder로 충분하다.   ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200818/",
        "teaser": null
      },{
        "title": "About Queue",
        "excerpt":"How to make Queue   01) Queue를 구현하기 위해 기존에 작성한  ","categories": ["Howto"],
        "tags": [],
        "url": "http://localhost:4000/howto/Queue/",
        "teaser": null
      },{
        "title": "2020-08-19 TIL",
        "excerpt":"인스턴스 필드와 인스턴스 메소드가 필요한 이유   의존 객체     클래스는 상호 크로스로 의존 객체가 될 수 있다.   객체지향은 절대 쌍방향으로 참조(레퍼런스)하지 말라고 이야기 한다.   쌍방향이 되는 상황이 되면 인터페이스 등을 사용한다.   인스턴스 필드(non-static field)     new 명령을 통해 Heap 영역에 생성된다.   개별적으로 다뤄야 할 값이라면 인스턴스 필드로 선언하라.(처음부터 인스턴스 필드로 만들어도 좋다.)   인스턴스 필드를 다루는 메서드는 인스턴스 메서드(non-static method)로 선언한다.   인스턴스 메서드는 호출할 때 반드시 유효한 레퍼런스(인스턴스 주소)가 있어야 한다.   레퍼런스는 인스턴스 메서드의 내장(built-in) 로컬 변수인 this에 저장된다.   인스턴스들이 공유하는 상수값은 인스턴스 필드로 만들 필요가 없고 스태틱 멤버(클래스 멤버)로 만든다.   스태틱 필드로 만든 클래스가 여러개 필요해질 때 클래스를 여러개 만들지 말고 처음부터 인스턴스 필드로 만들어 대비하는 것이 좋다.            클래스를 복붙하면 버그가 복사되었을 때 관리하기 어렵다.             생성자가 필요한 이유   생성자     생성자는 인스턴스를 사용하는데 문제가 없도록 인스턴스 필드를 유효한 값으로 초기화시키는 일을 한다.   생성자를 이용하여 의존 객체를 강제로 주입하게 한다.            인스턴스를 생성할 때 의존 객체를 반드시 주입하도록 기본 생성자 대신 의존 객체를 파라미터로 받는 생성자를 추가한다.             UI 코드와 Data 코드 분리      객체지향 프로그래밍을 할 때 다음 두 가지를 명심해야 한다.            Low Coupling       High Cohesion           관계도 낮추기(Low Coupling) 란?     한 클래스가 많은 클래스에 의존하는 구조로 작성하면 의존 클래스가 변경될 때 마다 영향을 받기 때문에 유지보수에 좋지 않다.   그래서, 가능한 의존하는 클래스의 접점을 줄이는 구조로 만드는 것이 좋다.   응집력 강화(High Cohesion) 란?     한 클래스가 너무 다양한 역할을 수행하면 클래스의 코드가 커지고 변경 사항이 잦아지기 때문에 유지보수에 좋지 않다.   그래서, 가능한 한 클래스가 한 개의 역할만 수행하게 만드는 것이 유지보수에 좋다.   역할을 작게 쪼개게 되면 해당 클래스를 다른 프로젝트에서 재사용하기가 쉽다.   ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200819/",
        "teaser": null
      },{
        "title": "PMS TLI",
        "excerpt":"pms project study   pms 03   Scanner 사용     클래스 밖에 import java.util.Scanner; 로 임포트를 해두면 사용하기 편하다.   사용법            Scanner sc = new Scanner(System.in);           사용이 끝나면 닫아줘야 한다.            sc.close();           int를 스캐너로 받을 때     int no = sc.nextInt();   숫자를 입력하고 엔터를 쳤을 때 nextInt()는 숫자만 읽어가고 엔터가 남는다.   이후 sc.nextLine();을 하면 남아있던 엔터가 읽혀서 원하는 문자열을 입력하지 못하게 된다.   이 문제를 해결하기 위해 nextInt(); 아래에 nextLine();을 미리 삽입해서 엔터를 읽고 끝내도록 한다.   시작일과 종료일을 입력받을 때     java.sql.Date 를 임포트한다.   Date startDate = Date.valueOf(sc.nextLine()); 으로 받는다.   상태를 입력받을 때     int status = Integer.valueOf(sc.nextLine()); 으로 입력받는다.   출력 시에 조건문을 사용한다.   switch 문을 사용해서 조건문을 출력한다.   pms 04   배열을 사용해서 변수 배열을 새로 만든다.     String[] 변수이름 = new String[갯수];   위에서 배열로 정의한 변수는 아래 조건문에서 앞에 String을 붙이지 않아도 된다.   반복문을 돌릴 때 횟수가 늘어날 때 아래쪽에 size를 붙인다.   배열의 길이를 변수로 따로 지정해서 관리한다.     final을 붙여서 상수로 관리하면 아래쪽에서 변경되지 않는다.   switch 문을 써서 진행중, 완료, 신규를 나눠서 표시할 수 있다.     배열로 바꿨을 때 상태표시를 나타낼 스트링 변수를 하나 준비한다.   그 변수에 진행중, 완료, 신규를 넣는 스위치 문을 만들어서 출력 부분에서 변수를 출력한다.   pms 05   명령어를 반복해서 받을 때는 while 문을 사용한다.     while 문이 언제나 참이면 무한 루프가 되기 때문에 loop를 사용해서 원하는 구간을 반복시키고 빠져나갈 수 있도록 한다.   명령어 입력을 받아 명령을 구별할 때는 switch 문을 사용한다.     케이스에 따라 명령 구분이 가능한 스위치 문을 사용한다.   pms 06   변수들은 다른 메서드에서도 사용할 수 있도록 스태틱을 붙인다.   메인 메서드에는 메서드 호출만 하도록 만든다.   호출당하는 메서드들은 스태틱을 붙인다.   명령 입력문을 프롬프트 메서드로 만든다.     프롬프트 메서드의 파라미터를 스트링으로 받는다.   입력받는 기능에 프롬프트 제목을 바꿀 수 있게 만든다.   리턴하는 값에 맞춰 리턴 타입을 정한다.   메소드명은 아규먼트 타입에 맞춰서 알아보기 쉽게 적는다.   리턴할 때 파라미터가 스트링이기 때문에 스트링을 인트와 데이트 타입으로 바꿔서 리턴해야 한다.   pms 07   (add) static 변수를 클래스로 묶었을 때     class 로 인스턴스 메모리를 만들 때 타입과 이름만 지정한다.   배열로 되어있을 필요가 없다.   (add) 클래스로 인스턴트를 만들 때     멤버 인스턴스를 담을 레퍼런스 배열을 만들어야 한다.   길이와 사이즈는 클래스에 포함하지 않는다.   (add) 회원 정보를 담을 메모리 생성   (add) 인스턴스 주소를 레퍼런스 배열에 저장   (list) 레퍼런스 배열에서 인스턴스 주소를 꺼내서 레퍼런스 변수에 저장.   add 의 반복문은 지워줘야 add 메서드를 한번 완료하고 빠져나온다.   pms 08   프롬프트, 멤버 핸들러, 프로젝트 핸들러, 태스크 핸들러로 분리시킬 때 앞에 클래스 주소를 붙여준다.   pms 09   util 패키지를 새로 만들어서 프롬프트를 옮긴다.     이때 public 으로 공개를 한다.   pms 10   findByName 클래스를 만들 때     회원 정보를 담을 인스턴스가 필요하다.   이름을 공란으로 처리하는 명령을 만들때는 문자열 길이를 비교하는 것이 좋다.   pms 11   보드 핸들러를 만들 때 퍼블릭 클래스 이름과 스태틱 클래스 이름을 헷갈리지 않도록 주의한다.   pms 12   pms 15     프라이빗으로 숨기고   게터, 세터 사용   pms 16     리스트를 각각 나눠서 사용하니 번잡하기 때문에   어레이리스트 하나를 만들고 배열 타입을 오브젝트로   오브젝트로 하니까 아무 주소나 다 담을 수 있어서 제네릭을 사용해서 무엇을 담을지 미리 지정   17   18   ","categories": ["pms"],
        "tags": [],
        "url": "http://localhost:4000/pms/pms/",
        "teaser": null
      },{
        "title": "2020-08-31 TIL",
        "excerpt":"캡슐화     특정 역할을 수행하는 코드를 클래스라는 캡슐에 감추고 메서드라는 도구를 통해 해당 코드를 이용하게 하는 기법이다   메서드로 접근하게 할 때는 일단 프라이빗으로 막고 필요한 것만 퍼블릭으로 공개한다.   인터페이스     기계와 사람 사이의 매개체   기계와 소통할 수 있는 중간 역할   핸드폰의 화면, 버튼 등   낮은 결합도, 높은 응집력     클래스 간의 관계를 줄이는 것이 유지보수에 편리하다   pms 14에서 하는 것이 응집력을 높이는 것   하나의 클래스가 한 개의 역할만 하도록 하는 것이 유지보수에 좋다.   도메인 객체     (비지니스) 도메인 객체   행위와 정보를 분리한다   도메인 객체를 값 객체, 모델 객체라고도 한다.   Board == BoardVO == BoardModle 등등   다형적 변수     같은 기능을 하는 메서드에 대해 같은 이름을 사용할 수 있어 프로그래밍의 일관성을 유지할 수 있다(오버로딩)   상속받은 메서드에 대해   제네릭     클래스가 다루는 변수를 지정할 수 있다.   public class ArrayList Element의 약자   CRUD     CRUD는 데이터의 생성(Create), 조회(Read/Retrieve), 변경(Update), 삭제(Delete)을 가리키는 용어이다.   어레이리스트     toArray()는 무조건 오브젝트를 받아서 새 배열을 만들어 리턴한다.   toArray(E[]) 는 내가 만든 배열에 값을 담아서 리턴한다.   native 라고 적혀있는 것은 c나 cpp로 만들어진 펑션을 호출한다는 뜻이다.  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200831/",
        "teaser": null
      },{
        "title": "2020-09-01 TIL",
        "excerpt":"제네릭     제네릭 문법이 없다면 각 타입의 객체를 저장하기 위해 각 타입에 대한 클래스를 정의해야 한다.   제네릭 문법은 코드의 안정성을 추구한다.   원하는 타입이 아닌 다른 타입의 값을 지정하는 오류를 막기 위해 만들어졌다.   각 객체 타입 별로 클래스를 생성해야 하면 타입 별로 만들어야 할 클래스가 무한정으로 늘어난다.            같은 일을 하는 클래스임에도 불구하고 다루는 객체의 타입이 다르다는 이유만으로 여러개의 유사 클래스를 반복적으로 정의해야 하는 문제가 생긴다.       해결책으로 다형적 변수의 특징을 이용하여 값을 저장하는 인스턴스 변수 오브젝트 타입으로 정의한다.                    인스턴스 변수를 오브젝트로 선언하면 한 개의 클래스만 정의하면 된다.           객체의 타입 별로 클래스를 구분해서 쓰지 않으니 코딩이 편하지만 값을 꺼낼 때마다 원래의 타입으로 바꾸기 위해 형변환을 해야한다.           오브젝트 타입이기 때문에 원래의 목적과 다른 객체를 넣어도 오류를 띄우지 않는다는 문제점이 있다.                           제네릭 문법은 컴파일러를 대상으로 한다.   다형적 변수의 한계(문제점)를 극복하기 위해 제네릭을 사용한다.     한 개의 클래스가 다양한 타입의 객체를 제한적으로 다루게 만든다.   클래스의 레퍼런스를 정의할 때 어떤 타입의 값을 다룰 것인지 제한을 걸아야 한다.(변수 타입 지정)   인스턴스를 생성할 때도 어떤 타입의 값을 다룰 것인지 지정해야 한다.   객체를 생성할 때 타입 지정을 생략할 수 있다.   메서드를 사용할 때 그 타입 전용 클래스인 것처럼 쓰면 되고 형변환을 할 필요가 없다.   제네릭으로 사용하는 변수 이름 종류     자바에서 제안하는 변수 이름은 다음과 같다.            T - type       E - element       K - key       V - value       N - number       여러개의 파라미터를 쓸 때는 보통 두 번째 파라미터부터 다음 알파벳을 사용한다.           특징     지정한 타입 전용 클래스로 동작한다.   그래서 타입이 아닌 경우 메서드를 호출할 수 없다.   제네릭 문법을 사용하면 오브젝트 타입을 사용하는 것보다 편리하다.   각 타입별로 클래스를 지정하는 듯한 효과가 있다.   제네릭 사용     특징 1 : 다루는 타입을 제한할 수 있다.            즉, 어레이리스트가 어떤 종류(타입, 클래스)의 객체를 저장할 것인지 지정할 수 있다.       지정된 타입 외의 객체는 저장할 수 없다.       사용법 : 클래스명           특징 2 : 제네릭을 지정하면 그와 관련된 메서드의 타입 정보가 자동으로 바뀐다.            형변환하는 번거로움이 없다.                    제네릭이 없다면 값을 꺼낼 때마다 형변환을 해줘야 한다.           아니면 값의 종류별로 어레이리스트를 만들어야 한다.                           제네릭 문법이 존재하므로 한 개의 클래스로 형변환 없이 특정 타입 전용 클래스를 만들 수 있다.   생략     레퍼런스를 선언할 때는 타입명을 생략하면 안된다.   ArrayList list; =&gt; ArrayList&lt;?&gt; list;            어떤 타입이든 넣을 수 있다.       바람직하지 않기 때문에 경고가 뜬다.           ArrayList&lt;?&gt; list;            이것 역시 바람직하지 않기 때문에 경고가 뜬다.           ArrayList&lt;오브젝트(영어로)&gt; list;            ArrayList&lt;오브젝트(영어로)&gt;로 만든 객체는 Object의 모든 객체를 담을 수 있다.                    list.add(new String()); &lt;= 된다.           add 할때는 오브젝트의 자식들을 담을 수 있다.                       list = new ArrayList&lt;스트링(영어로)&gt;; &lt;= 안된다.                    오브젝트를 담을 수 있는데 스트링이라고 한정하면 나머지를 담지 못하기 때문에 오류가 뜬다.           오브젝트의 자식 클래스를 지정하면 안된다.                           레퍼런스를 선언할 때     제네릭의 타입을 지정하지 않으면 다양한 종류의 어레이리스트를 파라미터로 넘길 수 있다.   그러므로 레퍼런스를 선언할 때 제대로 제네릭의 타입을 지정해야 한다.   제네릭 결정 불가할 때     컴파일러는 파라미터로 받은 어레이리스트가 어떤 타입의 값을 다루는지 알 수 없기 때문에 그 타입인지 검사해야 하는 메서드를 사용할 때는 컴파일을 명확하게 해줄 수 없다. 따라서 컴파일 오류를 발생시킨다.  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200901/",
        "teaser": null
      },{
        "title": "mini-pms 01",
        "excerpt":"mini-pms 01     Hello world를 출력한다.   package com.eomcs.pms;  public class App {     public static void main(String[] args) {         System.out.println(\"Hello world.\");     } }  ","categories": ["pms"],
        "tags": [],
        "url": "http://localhost:4000/pms/mini-pms-01/",
        "teaser": null
      },{
        "title": "mini-pms 02",
        "excerpt":"mini-pms 02     회원 정보, 프로젝트 정보, 작업 정보를 출력한다.   package com.eomcs.pms;  public class App {     public static void main(String[] args) {             System.out.println(\"[회원]\");     System.out.println(\"번호: 101\");     System.out.println(\"이름: 홍길동\");     System.out.println(\"이메일: hong@test.com\");     System.out.println(\"암호: 1111\");     System.out.println(\"사진: hong.png\");     System.out.println(\"전화: 1111-2222\");     System.out.println(\"가입일: 2020-01-01\");     } }  package com.eomcs.pms;  public class App2 {    public static void main(String[] args) {     System.out.print(\"[\");     System.out.print(\"프로젝트\");     System.out.println(\"]\");      System.out.print(\"번호: \");     System.out.println(1201);      System.out.print(\"프로젝트명: \");     System.out.println(\"미니 프로젝트 관리 시스템 개발\");      System.out.print(\"내용: \");     System.out.println(\"소규모 팀을 위한 프로젝트 관리 시스템을 개발한다.\");      System.out.println(\"시작일: \" + \"2020-01-01\");      System.out.println(\"종료일: \" + \"2020-12-31\");      System.out.println(\"만든이: \" + \"홍길동\");          System.out.println(\"팀원: \"         + \"홍길동\" + \",\"         + \"김구\" + \",\"         + \"유관순\" + \",\"         + \"안중근\" + \",\"         + \"윤봉길\");   } }   package com.eomcs.pms;  public class App3 {    public static void main(String[] args) {     System.out.printf(\"[%s]\\n\", \"작업\");     System.out.printf(\"프로젝트: %s\\n\", \"미니 프로젝트 관리 시스템 개발\");     System.out.printf(\"번호: %d\\n\", 1);     System.out.printf(\"내용: %s\\n\", \"요구사항 수집\");     System.out.printf(\"완료일: %s\\n\", \"2020-01-20\");     System.out.printf(\"상태: %s\\n\", \"진행중\");     System.out.printf(\"담당자: %s\\n\", \"홍길동\");   } }  ","categories": ["pms"],
        "tags": [],
        "url": "http://localhost:4000/pms/mini-pms-02/",
        "teaser": null
      },{
        "title": "mini-pms 03",
        "excerpt":" ","categories": ["pms"],
        "tags": [],
        "url": "http://localhost:4000/pms/mini-pms-03/",
        "teaser": null
      },{
        "title": "How to make LinkedList 02",
        "excerpt":"TLI How to make LinkedList02   11)  ","categories": ["Howto"],
        "tags": [],
        "url": "http://localhost:4000/howto/HowtoMakeLinkedList02/",
        "teaser": null
      },{
        "title": "2020-09-03 TIL",
        "excerpt":"상속     상속의 종류            1) specialization                    가장 많이 사용하는 방법으로 수퍼 클래스를 상속 받아 서브 클래스를 만드는 것이다.           수퍼클래스에 새 특징을 추가하거나 새 기능을 추가하여 더 특별한 일을 수행하는 서브클래스를 만든다.           그래서 이런 상속을 “특수화/전문화(specialization)”이라 부른다.                       2) generalization                    리팩토링 과정에 수행하는 방법이다.           서브클래스들의 공통 분모를 추출하여 수퍼클래스를 정의하는 방법을 말한다.           그래서 이런 상속을 “일반화/표준화(generalization)”이라 부른다.                           전문화와 일반화     상속(inheritance)을 구현하는 방법에는 두 가지가 있다.   전문화(specialization) 와 일반화(generalization) 이다.   전문화     기존 클래스의 기능을 그대로 활용할 수 있도록 연결하고   여기에 새 기능을 추가하거나 기존 기능을 변경하여 좀 더 특수 목적의 서브 클래스를 만드는 기법이다.   마치 부모로부터 무언가를 물려 받는 것과 같아서 상속 이라는 문법의 대표적인 기법으로 알려져 있다.   그래서 객체지향 프로그래밍의 상속을 얘기할 때는 대부분 전문화 를 가르키는 말이다.   일반화     클래스들의 공통 분모를 추출하여 수퍼 클래스를 정의하는 기법이다.   그리고 새로 정의한 수퍼 클래스와 부모/자식 관계를 맺는다.   프로그래밍 처음부터 상속을 고려하여 수퍼 클래스를 정의하는 것이 아니라  코드를 리팩토링하는 과정에서 수퍼 클래스를 정의하는 것이기 때문에 초보 개발자에게 적합하다.   보통 일반화를 통해 추출된 수퍼 클래스는 서브 클래스에게 공통 분모를 상속해주는 것이 목적이다.   직접 인스턴스를 생성하고 사용하기 위해 만든 클래스가 아니다.   그래서 일반화를 통해 도출한 수퍼 클래스는 보통 추상 클래스로 정의한다.   수퍼 클래스를 만든 다음 서브 클래스가 수퍼 클래스를 상속하도록 클래스명에 extends XXX 를 해준다.   의존성 주입(dependency injection; DI)     Handler가 의존하는 객체를 내부에서 생성하지 않고 생성자를 통해 외부에서 주입 받는 것.            이를 통해 의존 객체 교체가 쉽도록 만드는 것.           다형적 변수(Polymorphic Variables)     Handler에서 사용할 목록 관리 객체를 수퍼 클래스의 레퍼런스로 선언하는 것.            이를 통해 List의 서브 객체로 교체하기 쉽도록 만드는 것.           일반화     서브 클래스에서 구현하는 방법이 다른 메서드는 수퍼 클래스에서 구현하지 않고 서브 클래스에서 오버라이딩 하게 한다.   그럼 수퍼 클래스에 이 메서드를 둘 필요가 있는가?            서브 클래스들이 갖춰야 할 기능을 정의한다는 면에서 의미가 있다.       즉 서브 클래스들에게 반드시 수퍼 클래스의 기능을 갖도록 강제하는 효과가 있다.           목록을 다루는데 필요한 의존 객체를 특정 클래스로 제한하지 않고 상위 클래스의 레퍼런스를 사용하여 여러 서브 클래스를 사용할 수 있도록 유연성을 제공한다.            다형적 변수의 문법을 활용           의존 객체를 해당 클래스에서 직접 생성하지 않고 외부로부터 주입받는다.            생성자의 특성을 사용한다.       생성자? 객체가 작업하는데 필요한 값 또는 의존 객체를 준비하는 메서드.           추상 클래스와 추상 메서드   추상 클래스     서브 클래스에 기본 기능 및 공통 분모를 상속해 주는 역할을 하는 클래스다.   new 명령을 통해 인스턴스를 생성할 수 없다.   상속의 기법 중에서 일반화를 통해 수퍼 클래스를 정의한 경우 보통 추상 클래스로 선언한다.   추상 메서드를 가질 수 있다.   추상 메서드는 아무 일도 하지 않는다.   일반화를 통해 만든 수퍼 클래스는 일반 클래스로 만들어진다. 일반 클래스는 인스턴스를 만들 수 있으나 일반화를 통해 만들어진 수퍼 클래스가 추상 메서드를 가지고 있을때는 인스턴스를 만들 수 없다. 그러므로 수퍼 클래스를 이용하여 인스턴스를 만들지 못하도록 수퍼 클래스를 추상 클래스로 변경한다.            인스턴스를 만들 수 없기 때문에 레퍼런스를 만들어 사용한다.           추상 클래스는 일반 메서드나 일반 변수도 가질 수 있다.   추상 메서드     서브 클래스에 따라 구현 방법이 다른 경우 보통 추상 메서드로 선언한다.   서브 클래스에서 반드시 구현해야 하는 메서드다.   즉 서브 클래스를 정의할 때 반드시 해당 메서드를 구현하도록 강제하고 싶다면 추상 메서드로 선언한다.   수퍼 클래스가 추상 클래스이고 수퍼 클래스의 추상 메서드를 상속받았다면 서브 클래스 역시 추상 메서드를 가질 수 있는 추상 클래스가 되어야 한다.   서브 클래스가 일반 클래스일때 수퍼 클래스의 인스턴스를 호출하는데 수퍼 클래스는 추상 클래스이기 때문에 인스턴스를 만들 수 없다. 그러므로 서브 클래스는 구현되지 않는 메서드를 가지고 있게 되며 오류로 인식한다. 이것을 해결하기 위해 서브 클래스 역시 추상 클래스가 된다.   추상 클래스와 인터페이스 만이 추상 메서드를 가질 수 있다.   수퍼 클래스에서는 추상 메서드를 구현하면 안된다. 고로 {}를 붙일 수 없다.            서브 클래스에서 구체적인 실행을 구현하라는 의미이다.       서브 클래스마다 구현 내용이 다를 수 있다면 추상 메서드로 선언한다.       또는 서브 클래스에게 구현하도록 강제하고 싶을때도 추상 메서드로 선언한다.                    수퍼 클래스에 존재하는 추상 메서드는 추상 메서드를 상속하는 서브 클래스에서 구현해야 한다.           수퍼 클래스에서 추상 메서드의 의미는 해당 역할을 수행하는데 반드시 있어야 하는 기능을 정의하는데 의미가 있다.                           일반 클래스와 추상 메서드     상속받은 추상 클래스의 추상 메서드를 구현하지 않는다면 해당 클래스는 추상 클래스로 선언해야 한다.            상속받은 추상 메서드를 오버라이드를 붙여서 구현한다면 해당 서브 클래스는 일반 클래스로 선언할 수 있다.           템플릿 메서드 패턴 (디자인 패턴)     기본적인 실행 패턴은 수퍼 클래스에서 정의하고 구체적인 실행에 관해서는 서브 클래스에서 정의하는 설계 패턴을 템플릿 메서드 패턴이라고 한다.   추상 클래스인 수퍼 클래스에서 전체적인 논리 흐름을 일반 메서드로 정의한다.            서브 클래스들은 이 메서드를 그대로 상속받기 때문에 오버라이딩 하지 않는 이상은 그대로 작동한다.           추상 메서드로 구체적인 실행 방법이 정의되지 않은 템플릿 메서드를 선언한다.   각각의 서브 클래스에 추상 메서드를 오버라이딩 하여 구체적인 행위를 정의한다.   인터페이스(interface)     caller(호출자)와 callee(피호출자) 사이의 호출 규칙을 정의하는 문법.   메서드 형식을 의미한다.   메서드 몸체는 정의하지 않는다.            메서드 몸체는 이 규칙에 따라 만드는 클래스에서 정의하는 것이다.           인터페이스를 이행하는 클래스는 인터페이스에 선언된 모든 메서드를 반드시 구현해야만 일반 클래스(concrete class)가 된다.            만약 구현하지 않으면 추상 메서드인채로 존재한다.       따라서 추상 메서드를 가진 클래스가 된다.       추상 메서드는 추상 클래스만이 가질 수 있기 때문에 추상 클래스로 바꿔야 한다.           인터페이스를 이행하는 클래스를 구현체라고 한다.   인터페이스 구현체(implementor)는 인터페이스에 선언된 모든 메서드를 구현해야 한다.   문법            class 클래스명 implements 인터페이스명, 인터페이스명, … {…}           같은 사용 규칙에 따라 만든 클래스는 한 인터페이스 레퍼런스에 그 객체 주소를 저장할 수 있어서 편리하다.   인터페이스에 선언된 메서드를 구현한다고 해서 다 되는 것이 아니다.            반드시 implements 키워드를 사용해서 인터페이스를 구현한다고 클래스명에 선언해야 한다.       implements 키워드를 사용해서 인터페이스를 구현한다고 선언하지 않는다면 공식적으로 구현체가 아니기 때문에 레퍼런스에 담을 수 없다.           사용하려는 객체가 같은 인터페이스를 구현하였다면 동일한 사용 규칙에 따라 메서드를 호출할 수 있어 편리하다.            호출에 일관성이 있어 유지 보수에 좋다.           인터페이스 레퍼런스?            해당 인터페이스에 따라 작성된(사용규칙을 준수하는) 클래스의 인스턴스 주소를 저장한다.       다음과 같이 표현할 수 있다.                    인터페이스 사용 규칙에 따라 작성된 클래스의 인스턴스 주소를 저장하는 변수.           인터페이스를 구현한 클래스의 인스턴스 주소를 저장하는 변수.           구현체의 인스턴스 주소를 저장하는 변수.           구현체의 객체 주소를 저장하는 변수.           구현 객체를 저장하는 변수.           객체를 저장하는 변수.           객체를 가리키는 변수.                           인터페이스 문법   01     인터페이스에 정의하는 메서드는 호출 규칙이다.            규칙은 공개되어야 한다.                    그러므로 인터페이스에 선언되는 모든 메서드는 퍼블릭이다.                            생략된 것은 퍼블릭이 생략된 것이다.                                               규칙은 클래스가 따라야 한다.                    따라서 인터페이스에 선언되는 모든 메서드는 몸체를 구현하지 않는다.                            몸체를 구현하지 않아야 하기 때문에 추상 메서드로 선언한다.                                    추상 메서드임을 나타내기 위해 abstract를 붙인다.                                                                                   결론            따라서 인터페이스에 선언하는 모든 메서드는 퍼블릭이고 abstract 이다.           02     인터페이스는 규칙이기 때문에 인스턴스를 만들 수 없다.            따라서 new 명령어로 인스턴스를 생성할 수 없다.                    인터페이스에 선언되는 모든 변수는 퍼블릭으로 공개되고 스태틱으로 클래스 변수가 된다.           규칙은 변경되어선 안되기 때문에 모든 변수는 final로 선언되고 값을 바꿀 수 없다.                            final 변수는 선언과 동시에 특정 값으로 초기화해야 한다.                                   스태틱 블록을 둘 수 없다.                           결론            인터페이스의 모든 변수는 퍼블릭이고 스태틱이고 파이널 변수이다.       퍼블릭 스태틱 파이널은 생략 가능하다.           03     인터페이스의 모든 메서드는 퍼블릭이다.            인터페이스를 구현체는 내부에 존재하는 메서드의 공개 범위를 퍼블릭보다 줄일 수 없다.           04     서브 인터페이스 구현 : 수퍼 인터페이스의 메서드까지 구현해야 한다.            인터페이스 레퍼런스는 그 인터페이스를 구현한 클래스의 인스턴스를 가리킬 수 있다.                    그리고 해당 인터페이스에 선언된 메서드만 호출할 수 있다.           물론 수퍼 인터페이스의 메서드도 포함한다.                           05     다중 인터페이스 구현 : 한 클래스는 여러개의 인터페이스(규칙)를 구현할 수 있다.            규칙들 중에 메서드가 겹치더라도 메서드 명, 파라미터, 리턴 타입이 같다면 구현할 수 있다.           다중 인터페이스 구현을 했을 때 인터페이스를 레퍼런스에 담는다면 각 인터페이스의 규칙에 따라 사용할 수 있다.   06     다중 인터페이스 구현이 불가능한 경우            메서드 명과 파라미터는 같지만 리턴 타입이 다른 경우이다.       클래스는 이름이 같고 파라미터 형식이 다른 메서드를 여러개 정의할 수 있지만(오버로딩), 이름이 같고 파라미터 형식도 같고 리턴 타입이 다른 메서드를 여러개 정의할 수 없다.                    리턴 타입만 다른 메서드를 여러개 만들 수 없기 때문에 리턴 타입이 다른 메서드를 가지고 있는 각각의 인터페이스를 한 클래스에서 구현할 수 없다.                            다른 규칙을 가지고 있으면 동시에 만족시킬 수 없다.                                                  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200903/",
        "teaser": null
      },{
        "title": "2020-09-04 TIL ing",
        "excerpt":"인터페이스   기존에 구현한 인터페이스에 새 기능을 추가했을 때     인터페이스를 구현한 다른 클래스들에 오류가 생긴다.   새 기능을 추가한 새 인터페이스를 생성   인터페이스 메서드는 규칙     인터페이스와 추상 클래스는 다르다.   인터페이스는 규칙을 말하는 것이고 추상 클래스는 상속해줄 어떠한 필드나 메서드를 가지고 있으면서 추상 메서드도 가지는 것이다.   디폴트 메서드     기존 클래스에 영향을 끼치지 않으면서 새로운 규칙을 추가하는 것이 목표이다.   추상 클래스와 인터페이스 비교   A 인터페이스를 상속한 ㄱ 클래스와 ㄱ 클래스를 상속받은 ㄴ 클래스     A 인터페이스로 ㄱ 클래스와 ㄴ 클래스를 다 가리킬 수 있다.   추상 메서드의 구현     인터페이스도 스태틱 메서드를 가질 수 있다.(스태틱 블럭은 안된다.)            특정 인스턴스에 종속되지 않고 작업하는 경우에는 스태틱 메서드로 정의한다.           인터페이스는 디폴트 메서드를 가질 수 있다.            기존 프로젝트에 영향을 끼치지 않으면서 기존 규칙에 새 메서드를 추가할 때 유용하다.           인터페이스에 스태틱 메서드나 디폴트 메서드가 여러개 있더라도 그 메서드들은 이미 구현된 메서드이기 때문에 추상 메서드와 상관없다.   추상 메서드     수퍼 클래스를 추상 클래스로 만들고 추상 클래스가 인터페이스로부터 상속받은 추상 메서드 중 일부만 구현하게 하고 추상 클래스를 상속받은 추상 메서드를 서브 클래스에서 구현하도록 하는 방법을 자주 쓴다.   인터페이스를 직접 구현하면 인터페이스에 선언된 모든 메서드를 구현해야 하지만, 미리 인터페이스의 몇몇 메서드를 구현한 추상클래스(AbstractServlet)를 상속 받는다면 서브 클래스는 좀 더 쉽게 인터페이스를 구현할 수 있다.            즉 이렇게 인터페이스의 메서드가 많을 경우 일부 메서드를 미리 구현함으로써 개발자가 좀 더 쉽게 인터페이스를 구현할 수 있게 도와주는 용도로 “추상 클래스” 문법을 사용할 수 있다!           디자인 패턴 - Singleton     인스턴스를 딱 하나만 생성하여 공유하고 싶다면 Singleton 설계 방식으로 클래스를 정의한다.   방법:            1) 생성자를 정의하고 private로 선언하여 비공개로 만든다.                    비공개 생성자는 외부에서 사용할 수 없고 내부에서만 사용할 수 있다.                       2) 인스턴스를 생성해주는 메서드를 정의한다.                    인스턴스를 생성한 적이 없다면 즉시 인스턴스를 생성한다.           기존 변수에 저장된 인스턴스 변수를 리턴한다.                       3) 생성자가 존재하지만 private로 비공개되어 있기 때문에 직접 호출할 수 없다.                    생성자를 호출할 수 없으면 인스턴스를 생성할 수 없다.           다른 메서드를 호출하여 인스턴스를 생성하라는 의미아다.                       4) 인스턴스를 생성해주는 메서드를 통해 인스턴스를 얻는다.                    기존에 생성된 인스턴스 주소를 리턴해주는 것이기 때문에 주소가 계속 같다.                          ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200904/",
        "teaser": null
      },{
        "title": "2020-09-04 TIL ing",
        "excerpt":"Iterator(반복자) 패턴     객체 목록을 관리하는 컬렉션에서 목록 조회 기능을 별도의 객체로 캡슐화하는(별도의 클래스로 정의해서 메서드를 정의하는 것) 것.   컬렉션의 관리 방식(data structure)에 상관없이 일관된 목록 조회 방법을 제공할 수 있다.   컬렉션을 변경하지 않고도 다양한 방식의 목록 조회 기법을 추가할 수 있다.   Iterate     목록을 따라가면서 값을 조회하는 것            순차적으로 조회하는 것           컬렉션의 타입에 따라 호출하는 방법이 다르더라도 값을 꺼내는 방법(메서드 시그너처)을 통일            호출 규칙을 정의하는 것                    interface 문법                           중첩 클래스(nested class)     특정 클래스의 작업을 도와주는 작은 크기의 클래스를 정의할 때 주로 중첩 클래스로 정의한다.   클래스가 사용되는 곳에 위치하기 때문에 코드를 읽기 쉽고 관리하기가 쉽다.   다른 클래스 안에 위치하기 때문에 캡슐화가 더 좋아진다.  캡슐화가 더 좋아진다는 것은,  복잡한 코드는 감추고 외부로부터의 접근은 줄이고 단순화시켜서 코드를 더 관리하게 쉽게 만든다는 의미다. 또한 바깥 클래스의 멤버에 대한 접근은 더 쉬워진다.   스태틱 중첩 클래스(static nested class)     스태틱 멤버이기 때문에 인스턴스 멤버(필드나 메서드)에는 접근할 수 없다.   비록 다른 클래스 안에 있지만 일반 패키지 클래스(top-level class)처럼 사용할 수 있다.   다른 스태틱 멤버가 사용할 수 있다.   스태틱 메서드로 생각하면 편하다.   내부 클래스(non-static nested class, inner class)     인스턴스 멤버(필드나 메서드)처럼 사용한다.   그래서 바깥 클래스의 인스턴스 멤버를 직접 접근할 수 있다.   왜?  인스턴스 멤버이기 때문에 바깥 클래스의 인스턴스를 참조하는 this 내장 변수를 갖고 있다.   따라서 inner class 를 사용하려면 바깥 클래스의 인스턴스를 먼저 생성해야 한다.   내부 클래스(inner class)의 또 다른 종류가 있는데,            메서드 안에 정의하는 로컬 클래스(local class) 와  이름 없이 정의하는 익명 클래스(anonymous class) 가 있다.             ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200907/",
        "teaser": null
      },{
        "title": "2020-09-08 TIL ing",
        "excerpt":"중첩 클래스   탑 레벨 클래스와 접근제어   static nested class     하나의 소스 파일에 탑 레벨 클래스가 2개 이상일 때 하나만 퍼블릭 클래스가 될 수 있고 퍼블릭 클래스의 이름으로 소스 파일을 저장해야 한다.                     나머지는 퍼블릭이 될 수 없다.                   스태틱 중첩 클래스     this 변수를 가지고 있지 않다.   이너 클래스     인스턴스 메서드의 경우            this 변수를 가지고 있다.                    0번째 로컬 변수가 this 이다.                       그 클래스의 인스턴스 변수 주소를 담는다.       인스턴스 메서드에 있는 this 변수는 인스턴스 메서드를 호출할 때 객체 주소를 저장한다.           이너 클래스의 경우            바깥 클래스의 인스턴스 주소를 저장하기 위해 다음과 같이 코드를 작성해야 한다.                    바깥클래스명.this                       바깥 클래스의 인스턴스 주소는 바깥 클래스의 인스턴스를 가지고 이너 클래스의 인스턴스를 생성할 때 저장한다.                    즉 이너 클래스의 생성자를 호출할 때 바깥 클래스의 인스턴스 주소를 파라미터로 전달한다.           이를 위해 컴파일러는 이너 클래스를 컴파일 할 때 생성자를 변형한다.                           로컬 클래스     메서드 안에 정의하는 클래스를 로컬 클래스라 한다.   특정 메서드 안에서만 사용되는 경우 로컬 클래스로 정의한다.            노출을 줄이면 유지 보수에 좋다.           로컬 클래스는 메서드가 로딩되면 그 메서드 안에서 계속 사용할 수 있다.  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200908/",
        "teaser": null
      },{
        "title": "2020-09-11 TIL ing",
        "excerpt":"커맨드 디자인 패턴     메서드의 객체화 설계 기법   한 개의 명령어를 처리하는 메서드를 별개의 클래스로 분리   기존 소스에 손을 대지 않아서 유지 보수에 좋다.   명령 처리를 별도의 객체로 분리하기 때문에 실행 내역을 관리하기 좋고, 각 명령이 수행했던 작업을 다루기 편하다.   즉 기존 소스에 영향을 끼치지 않고 새 기능을 추가하는 방식이다.   명령처리를 별도의 객체로 분리하기 때문에 실행 내역을 관리하기 좋고, 각 명령이 수행했던 작업을 다루기가 편하다.   인터페이스를 이용하면 메서드 호출 규칙을 단일화 할 수 있기 때문에  코딩의 일관성을 높혀줄 수 있다.   단 기능 추가할 때마다 해당 기능을 처리하는 새 클래스가 추가되기 때문에  클래스 개수는 늘어난다.   그러나 유지보수 측면에서는 기존 코드를 변경하는 것 보다는  클래스 개수가 늘어나는 것이 좋다.   유지보수 관점에서는 소스 코드를 일관성 있게 유지보수 할 수 있는게 더 중요한다.   ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200911/",
        "teaser": null
      },{
        "title": "2020-09-14 TIL ing",
        "excerpt":"예외처리문법   예외 처리 문법 적용 전     계산기의 경우 유효하지 않은 연산자를 지정했을 대 제대로 계산을 수행했는지 검사히기 위해 보통 리턴 값을 검사한다.   하지만 정상적인 계산 결과가 유효하지 않은 리턴 값으로 결정된 값과 일치한다면 정상적인 계산 결과도 오류로 취급할 수 있다.   이를 방지하기 위해 오류가 발생하면 희귀한 값을 리턴하는 방식을 사용했다. 하지만 이 역시 희귀한 값이 정상적인 리턴 값일 가능성이 발생한다.            결국 리턴 값을 검사하여 오류 여부를 처리하는 방식으로는 이런 문제를 해결할 수 없다.       리턴 값으로 작업 오류를 알려주는 방식의 한계를 극복하기 위해 만든 문법이 예외처리 문법이다.                    예외 상황이 발생했을 때 호출자에게 예외 정보를 던져주는 문법이다.                       또한, 계산할 수 없는 예외 상황이 발생했을 경우 JVM이 실행을 종료하지 않고 정상적으로 실행하게 만드는 문법이 예외 처리이다.           예외처리   개념     메서드를 실행하는 중에 예외가 발생했을 때 호출자에게 알려주는 문법   메서드를 호출하는 중에 예외를 받았을 때 처리하는 문법   예외처리 문법의 의미            메서드 실행 중에 예외 상황을 만났을 때 리턴 값을 ㅗ알려주는 방식의 한계를 극복하기 위해       예외가 발생하더라도 시스템을 멈추지 않고 적절한 조치를 취한 후 계속 실행하기 위해           예외를 호출자에게 알려주는 문법     throw [Throwable 객체];            throw new String(“에외가 발생했습니다”); &lt;- 컴파일 오류           예외를 받았을 때 처리하는 문법     try {       m();   } catch (RuntimeException e) {       System.out.println(e.getMessage());   }   System.out.println(“시스템을 종료합니다.”);   catch 문 안에 들어가는 파라미터는 java.lang.throwable과 그 자식들이다.            object는 들어갈 수 없다.           예외가 발생하면 catch 블럭이 실행된다.   예외를 받지 않을때     즉시 현재 메서드의 실행을 멈추고 호출자에게 예외 처리를 위임한다.   만약에 그 호출자가 JVM이라면 프로그램 실행을 종료한다.   throw 명령어를 사용하여 예외 정보를 호출자에게 던진다.     throw [java.lang.Throwable 타입의 객체 ];   java.lang.Throwable     1) java.lang.Error (시스템 오류) // =&gt; JVM에서 발생된 오류이다. // =&gt; 개발자가 사용하는 클래스가 아니다. // =&gt; 이 오류가 발생하면 현재의 시스템 상태를 즉시 백업하고, 실행을 멈춰야 한다. // =&gt; JVM에서 오류가 발생한 경우에는 계속 실행해봐야 소용이 없다. // 근본적으로 문제를 해결할 수 없다. // =&gt; 오류의 예: // 스택 오버 플로우 오류, VM 관련 오류, AWT 윈도우 관련 오류, 스레드 종료 오류 등 // // 2) java.lang.Exception (애플리케이션 오류) // =&gt; 애플리케이션에서 발생시킨 오류이다. // =&gt; 개발자가 사용하는 클래스이다. // =&gt; 적절한 조치를 취한 후 계속 시스템을 실행하게 만들 수 있다. // =&gt; 오류의 예: // 배열의 인덱스가 무효한 오류, I/O 오류, SQL 오류, Parse 오류, 데이터 포맷 오류 등   오류를 던질 때     오류를 던진다면 반드시 메서드 선언부에 어떤 오류를 던지는지 선언해야 한다. // =&gt; 메서드 호출자에게 알려주는 것이다. //  static void m1() throws Throwable { //    throw new Throwable(); // OK! //    // 예외를 던질 때 Throwable 클래스를 직접 사용하지 말라! //    // 그 하위 클래스를 사용하라. //    // 특히 애플리케이션 오류를 의미하는 Exception 클래스를 사용하라. //  } // //  // 여러 개의 오류를 던지는 경우 메서드 선언부에 그대로 나열하라. //  static void m2() throws FileNotFoundException, RuntimeException { //    int a = 100; //    if (a &lt; 0) //      throw new FileNotFoundException(); // OK! //    else //      throw new RuntimeException(); // OK! //  } // //  public static void main(String[] args) {} }   Error 계열의 예외는 던져서는 안된다.     Error 계열의 예외는 JVM 관련 오류일 때 사용하는 클래스이다.   혹 던지게 되면 메서드 선언부에 던지는 예외 표시를 해도되고 안해도 된다.   Exception 계열의 예외를 던질 경우  / Exception 계열의 예외를 던질 경우,   //  // 반드시 메서드 선언부에 어떤 예외를 던지는지 지정해야 한다.   //  // =&gt; 보통 개발자가 애플리케이션을 작성하면서   //  // 예외를 던질 경우 이 클래스(및 하위 클래스)를 사용한다.   //  static void m1() throws Exception {   //    throw new Exception();   //    // OK! 보통 개발자가 사용하는 예외 클래스이다.   //  }   //   //  // Exception 예외를 던질 경우 반드시 메서드 선언부에 표시해야 한다.   //  static void m2() { // 컴파일 오류!   //    throw new Exception();   //  }   //   //  // 메서드의 throws 에 선언할 수 있는 클래스는 Throwable 타입만 가능한다.   //  static void m3() throws String {   //    throw new String(); // 컴파일 오류!   //    // throw 로 던질 수 있는 객체는 오직 java.lang.Throwable 타입만 가능하다.   RuntimeException  //  // RuntimeException은 클래스는 Exception의 서브클래스이다.     //  static void m() throws RuntimeException {     //    throw new RuntimeException(); // OK!     //  }     //     //  // Exception의 서브 클래스임에도 불구하고     //  // RuntimeException 객체를 던질 경우,     //  // 메서드 선언부에 예외를 던진다고 표시하지 않아도 된다.     //  // 왜?     //  // =&gt; 스텔스 모드(비유!) 를 지원하기 위해 만든 예외이다.     //  static void m2() {     //    throw new RuntimeException();     //  }   메서드에서 발생되는 예외는 메서드 선언부에 모두 나열해야 한다.    //  static void m(int i) throws Exception, RuntimeException, SQLException, IOException {   //    if (i == 0)   //      throw new Exception();   //    else if (i == 1)   //      throw new RuntimeException();   //    else if (i == 2)   //      throw new SQLException();   //    else   //      throw new IOException();   //  }   //   //  public static void main(String[] args) {} //}      메서드에서 발생하는 예외의 공통 수퍼 클래스를 지정하여 여러개를 나열하지 않을 수 있다.            그러나 호출자에게 어떤 오류가 발생하는지 정확하게 알려주는 것이 유지보수에 도움이 되므로 가능한 그 메서드에서 발생하는 예외는 모두 나열하라.           RuntimeException 계열은 생략 가능하다.   던지는 예외를 예외처리 안 했을 때     예외를 던질 수 있다고 선언된 메서드를 호출할 때 그 예외 상황에 대한 처리를 하지 않으면 컴파일 오류가 발생한다.   예외 처리 방법     1) 예외를 처리하고 싶지 않다면 상위 호출자에게 책임을 떠넘길 수 있다.            만약 상위 호출자가 main()일 경우, main() 호출자는 JVM이고, JVM은 예외를 받는 순간 즉시 실행을 멈춘다.                    그래서 main()의 호출자에게 책임을 떠넘기는 것은 바람직하지 않다.           main() 은 예외 처리의 마지막 보루이다.           main()에서 예외 처리를 하지 않는다면 프로그램은 멈춘다.                           2) try ~ catch를 사용하여 코드 실행 중에 발생된 예외를 중간에 가로챈다.            try 블록에는 예외가 발생할 수 있는 코드를 둔다.       그 예외 객체를 파라미터로 받을 수 있는 catch 문을 찾아서 실행한다.       catch 블록에서는 그 예외를 받아서 처리한다.           3) try ~ catch를 사용할 때            여러개의 예외를 받을 때 수퍼 클래스 변수를 먼저 받지 않는 것이 좋다.       수퍼 클래스 변수를 먼저 받으면 수퍼 클래스의 서브 클래스 객체도 전부 다 받게 된다.       그러므로 서브 클래스는 변수를 받지 못하고 예외 객체를 정확하게 받을 수 없게 된다.       이를 막기 위해 서브 클래스 예외를 먼저 받는다.           3-1) try ~ catch를 사용할 때            수퍼 클래스인 Exception을 변수로 사용하면 이 블록에서 예외를 모두 처리할 수 있다.       수퍼 클래스 : Exception       서브 클래스 : RuntimeException, SQLException, IOException           3-2) try ~ catch를 사용할 때            or 연산자를 사용하여 여러 개의 예외를 묶어 받을 수 있다.       Exception 변수는 따로 빼야한다.           Throwable 변수로 예외를 받지 말라!  // 가능한 Error 계열의 시스템 예외를 받지 말라!   //      // 혹 받더라도 현재 프로그램을 종료하기 전에   //      // 필수적으로 수행해야 하는 마무리 작업만 수행하도록 하라.   //      // 왜?   //      // 시스템 예외는 당장 프로그램을 정상적으로 실행할 수 없는 상태일 때 발생한다.   //      // 정상적인 복구가 안되는 예외이다.   //      // 따라서 이 예외를 처리하려 해서는 안된다.   //      // 시스템을 멈출 수 밖에 없다.   // catch 문을 작성할 때   //      // 이처럼 무심코 Throwable 변수로 선언하면   //      // 시스템 오류인 Error 까지 받기 때문에   //      // JVM에서 발생된 오류에 대해서도 예외 처리를 하는 문제가 발생한다.   //      // 시스템 오류는 애플리케이션에서 처리할 수 없다.   //      // 따라서 실무에서는 예외를 받을 때   //      // Throwable 변수를 사용하지 않는다.   // 이렇게 Exception 변수를 사용하면 //      // 애플리케이션 예외를 처리하고, //      // 시스템 예외는 main() 호출자에게 위임하게 된다. //      // 즉 JVM에게 전달한다. //      // 이렇게 Exception 계열의 애플리케이션 예외만 처리하라.   finally 블록  정상적으로 실행하든, 아니면 예외가 발생하여 catch 블록을 실행하든   //      // finally 블록은 무조건 실행한다.   //      // 즉 try ~ catch ~ 블록을 나가기 전에 반드시 실행한다.   //      // 그래서 이 블록에는   //      // try 에서 사용한 자원을 해제시키는 코드를 주로 둔다.   //      // =&gt; 자원 해제 코드를 둔다.   //      // =&gt; 자원? 파일, DB 커넥션, 소켓 커넥션, 대량의 메모리 등   public static void main(String[] args) throws Exception {   //    try {   //      m(1);   //      // m()에서 발생된 예외는   //      // try 블록에서 받지 않는다.   //      // 따라서 main() 호출자에게 위임한다.   //      // =&gt; 물론 main() 메서드 선언부에 위임할 예외의 종류를 표시해야 한다.   //      //   //    } finally {   //      // try 블록을 나가기 전에 무조건 실행해야 할 작업이 있다면   //      // catch 블록이 없어도 finally 블록만 사용할 수 있다.   //      System.out.println(“마무리 작업 실행!”);   ### finally 블록과 자원해제   // 스캐너 객체를 사용하여 키보드 입력을 읽어들인다.     //    // =&gt; 예외가 발생한다면?     //    System.out.print(“입력&gt; “);     //    int value = keyScan.nextInt();     //    System.out.println(value * value);     //     //    // 프로그램을 즉시 종료한다면,     //    // 스캐너를 다 사용하고 난 다음에 굳이 스캐너에 연결된 키보드와 연결을 끊을 필요는 없다.     //    // JVM이 종료되면 OS는 JVM이 사용한 모든 자원을 자동으로 회수하기 때문에     //    // 굳이 close()를 호출하지 않아도 된다.     //    //     //    // 그러나 365일 24시간 내내 실행되는 시스템이라면,     //    // 키보드 입력을 사용하지 않는 동안에는     //    // 다른 프로그램에서 사용할 수 있도록     //    // 스캐너와 연결된 키보드를 풀어줘야 한다.     //    //     //    // 이것을 “자원해제”라고 부른다.     //    //     //    // 보통 자원해제시키는 메서드의 이름이 “close()”이다.     //    // 당연히 Scanner 클래스에도 자원을 해제시키는 close() 메서드가 있다.     //    // 그런데 우리는 지금까지 Scanner를 사용하면서 close()를 호출하지 않았다.     //    //     //    // 왜?     //    // 프로그램이 바로 종료되기 때문이다.     //    // 그러나 우리가 자바로 프로그램을 짤 영역은 서버쪽이다.     //    // 즉 365일 24시간 내내 실행되는 서버쪽 프로그램을 개발하는 것이기 때문에,     //    // 항상 자원을 사용한 후 해제시키는 것을 습관적으로 해야 한다.     //    //     //    keyScan.close();     //     //    // 문제는 close()를 호출하기 전에 예외가 발생한다면,     //    // 제대로 자원을 해제시키지도 못한다는 것이다.     //    // 이것을 해결하는 방법은 finally 블록을 사용하는 것이다.   }   try-whit-resources 문법  자원해제시키는 코드를 매번 작성하기가 귀찮다! //    // =&gt; try-with-resources 라는 문법을 사용하면 //    // 굳이 finally 블록에서 close()를 직접 호출할 필요가 없다. //    // 자동으로 처리한다. //    // =&gt; 단 java.lang.AutoCloseable 구현체에 대해서만 가능하다! //    // =&gt; 문법 //    // try (java.lang.AutoCloseable 구현체) {…}   //    // finally 블록에서 B의 close()를 호출하지 않아도,   //    // 자동으로 호출될 것이다. 실행하여 확인하라!   A 클래스는 AutoCloseable 구현체가 아니기 때문에 여기에 선언할 수 없다.   //        //         A obj = new A(); // 컴파일 오류!   변수 선언은 반드시 괄호 안에 해야한다.  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200914/",
        "teaser": null
      },{
        "title": "2020-09-15 TIL ing",
        "excerpt":"https://nesoy.github.io/articles/2019-05/GRASP-Pattern   IO   디렉토리에 들어있는 파일이나 하위 디렉토리 정보 알아내기     listfiles   ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200915/",
        "teaser": null
      },{
        "title": "2020-09-16 TIL ing",
        "excerpt":"람다 vs 추상 메서드     다음과 같이 추상 메서드가 한 개 있는 인터페이스를 “functional interface”라고 부른다.   -이런 경우에 람다 문법으로 사용할 수 있다.        Player p1 = new Player() {     @Override     public void play() {       System.out.println(“익명 클래스”);     }   };   p1.play();       // 람다 문법으로 인터페이스 구현하기   // =&gt; 메서드 한개짜리 인터페이스를 구현한 익명 클래스를 좀 더 간단히 만드는 문법이다.   Player p2 = () -&gt; {     System.out.println(“람다”);   };   p2.play();       람다 파라미터     1) 파라미터는 괄호 안에 선언한다.   2) 파라미터 타입을 생략할 수 있다.   3) 파라미터가 여러개일 때는 괄호도 생략할 수 있다.   람다 리턴     1) 리턴 값은 return 명령을 사용하여 처리한다.   2) 한 문장으로 된 표현식(=값을 리턴하는 한 문장의 코드)인 경우 괄호 생략할 수 있다.            문장은 문장인데 값을 리턴하는 문장을 표현식(expression)이라 부른다.       단 괄호를 생략할 때 return 키워드도 생략해야 한다. 있으면 컴파일 오류다.           익명 클래스를 사용할 수 있는 곳에는 모두 람다 사용 가능     interface A {  void print();   }   // 스태틱 필드   static A obj1 = () -&gt; System.out.println(“스태틱 필드”);   //인스턴스 필드   A obj2 = () -&gt; System.out.println(“인스턴스 필드”);   public static void main(final String[] args) {   // 로컬 변수 A obj3 = () -&gt; System.out.println(\"로컬 변수!\");  // 파라미터 m1(() -&gt; System.out.println(\"파라미터\"));   }   static void m1(final A obj) {     obj.print();   }   람다 문법 - functional interface 의 자격     추상 메서드가 한개이어야 한다.            추상 메서드를 한 개만 갖고 있는 인터페이스에 대해 람다 문법으로 익명 클래스를 만들 수 있다.           추상 메서드가 두개일 경우 람다 문법을 구현할 수 없다. 오로지 한개여야 한다.   여러개의 메서드가 있어도 추상 메서드가 한개이면 구현 가능하다.            스태틱 메서드나 디폴트 메서드가 몇개이든 그 개수는 중요하지 않다.           인터페이스가 아닌 추상 클래스는 람다의 구현 대상이 아니다.   아규먼트에 람다 활용하기          로컬 클래스를 사용했을 때 public class Exam0310 { static interface Player {   void play(); }       static void testPlayer(Player p) {   p.play(); }       public static void main(String[] args) {   class MyPlayer implements Player {     @Override     public void play() {       System.out.println(“실행”);     }   }       testPlayer(new MyPlayer()); } }            익명 클래스를 사용했을 때 public class Exam0311 { static interface Player {   void play(); }       static void testPlayer(Player player) {   player.play(); }       public static void main(String[] args) {   Player player = new Player() {     @Override     public void play() {       System.out.println(“실행”);     }   };       testPlayer(player); } }            아규먼트에 익명 클래스를 넣었을 때 public class Exam0312 { static interface Player {   void play(); }       static void testPlayer(Player player) {   player.play(); }       public static void main(String[] args) {   testPlayer(new Player() {     @Override     public void play() {       System.out.println(“실행”);     }   }); } }            아규먼트에 람다를 사용했을 때 public class Exam0313 { static interface Player {   void play(); }       static void testPlayer(Player player) {   player.play(); }       public static void main(String[] args) {   testPlayer(() -&gt; System.out.println(“실행”)); }       }  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200916/",
        "teaser": null
      },{
        "title": "2020-09-17 TIL ing",
        "excerpt":"트리구조 만들기   import java.io.File;   public class Exam0710x {   public static void main(String[] args) {     //    // 1) 현재 디렉토리의 파일 및 디렉토리 이름 출력     //    File dir = new File(“.”);     //     //    File[] files = dir.listFiles();     //     //    for (File file : files) {     //      System.out.println(file.getName());     //    }   //    // 2) 디렉토리 안의 목록을 출력하는 코드를 별도의 메서드로 분리한다. //    File dir = new File(\".\"); //    printFiles(dir); //  } // //  static void printFiles(File dir) { //    File[] files = dir.listFiles(); // //    for (File file : files) { //      System.out.println(file.getName()); //    } //  }  //    // 3) 하위 디렉토리의 파일 및 디렉토리 목록도 출력한다. //    File dir = new File(\".\"); //    printFiles(dir); //  } // //  static void printFiles(File dir) { //    File[] files = dir.listFiles(); // //    for (File file : files) { //      System.out.println(file.getName()); //      if (file.isDirectory()) { //        printFiles(file); //      } //    } //  }  //    // 4) 하위 디렉토리 내용을 출력할 때는 인덴트를 추가한다. //    File dir = new File(\".\"); //    printFiles(dir, 0); //  } // //  static void printFiles(File dir, int level) { //    File[] files = dir.listFiles(); // //    for (File file : files) { //      for (int i = 0; i &lt; level; i++) { //        System.out.print(\"  \"); //      } //      System.out.println(file.getName()); //      if (file.isDirectory()) { //        printFiles(file, level + 1); //      } //    } //  }  //    // 5) 인덴트 처리 부분을 별도의 메서드로 추출한다.(extract method) //    File dir = new File(\".\"); //    printFiles(dir, 0); //  } // //  static void printFiles(File dir, int level) { //    File[] files = dir.listFiles(); // //    for (File file : files) { //      printIndent(level); //      System.out.println(file.getName()); //      if (file.isDirectory()) { //        printFiles(file, level + 1); //      } //    } //  } // //  static void printIndent(int level) { //    for (int i = 0; i &lt; level; i++) { //      System.out.print(\"  \"); //    } //  }  // 6) 트리처럼 보이게 |--를 넣어준다. File dir = new File(\".\"); printFiles(dir, 0);   }   static void printFiles(File dir, int level) {     File[] files = dir.listFiles();   for (File file : files) {   printIndent(level);   System.out.println(file.getName());   if (file.isDirectory()) {     printFiles(file, level + 1);   } }   }   static void printIndent(int level) {     for (int i = 0; i &lt; level; i++) {       System.out.print(“  “);     }     System.out.print(“|–”);   } }   바이트 단위로 읽기   // 파일 입출력 API 주요 클래스 (java.io 패키지) // 1) 데이터 읽기 // InputStream (추상 클래스) //   +– FileInputStream : 바이트 단위로 읽기 (binary stream) // // Reader (추상 클래스) //   +– FileReader : 문자 단위로 읽기 (character stream) // // 2) 데이터 쓰기 // OutputStream (추상 클래스) //   +– FileOutputStream : 바이트 단위로 쓰기 (binary stream) // // Writer (추상 클래스) //   +– FileWriter : 문자 단위로 쓰기 (character stream)   // ## 바이너리 파일 vs 텍스트 파일 // 1) 바이너리 파일 // - 기본 텍스트 편집기(메모장, vi 에디터 등)로 편집할 수 없는 파일을 말한다. // - 만약 텍스트 편집기로 변경한 후 저장하면, 파일 포맷이 깨지기 때문에 무효한 파일이 된다. // - 예) .pdf, .ppt, .xls, .gif, .mp3, .jpg, .hwp, .mov, .avi, .exe, .lib 등 // - 바이너리 파일을 편집하려면 해당 파일 포맷을 이해하는 전용 프로그램이 필요하다. // // 2) 텍스트 파일 // - 기본 텍스트 편집기(메모장, vi 에디터 등)로 편집할 수 있는 파일을 말한다. // - 예) .txt, .csv, .html, .js, .css, .xml, .bat, .c, .py, .php, .docx, .pptx, .xlsx 등 // - 텍스트 파일은 전용 에디터가 필요 없다. // - 텍스트를 편집할 수 있는 에디터라면 편집 후 저장해도 유효하다.   // ## 바이너리 데이터 읽고, 쓰기 // - 읽고 쓸 때 중간에서 변환하는 것 없이 바이트 단위로 그래도 읽고 써야 한다. // - InputStream/OutputStream 계열의 클래스를 사용하라. // // ## 텍스트 데이터 읽고, 쓰기 // - 읽고 쓸 때 중간에서 문자 코드표에 따라 변환하는 것이 필요하다. // - Reader/Writer 계열의 클래스를 사용하라.   파일을 쓸 때 사용  FileOutputStream out = new FileOutputStream(“temp/test1.data”);   파일을 읽을 때 사용  FileInputStream in = new FileInputStream(“temp/test1.data”);  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200917/",
        "teaser": null
      },{
        "title": "2020-09-18 TIL ing",
        "excerpt":"인코딩     AB가각            ms949 : 41 42 B0 A1 B0 A2       utf8 : 41 42 EA B0 80 EA B0 81       utf16be : 00 41 00 42 AC 00 AC 0       utf16be : 41 00 42 00 00 AC 01 AC           텍스트 파일 읽기   FileOutputStream     FileOutputStream 은 byte[] 을 출력   FileWriter     char[] 을 출력한다.  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200918/",
        "teaser": null
      },{
        "title": "2020-09-21 TIL ing",
        "excerpt":"io ex04 ~ ex08  입출력 중요   int 출력     out.write();            출력할 때는 맨 끝 1바이트만 출력한다.           in.read();            1바이트를 읽어 int 값으로 만든 후 리턴한다.           out.write(); 를 사용할 때 int 메모리의 모든 바이트를 출력하려면 각 바이트를 맨 끝으로 이동한 후 wirte() 로 출력한다.            이동할 때는 비트 이동 연산자를 사용한다.           str.getByte()     str.getByte(문자코드표)            ex ) out.write(str.getByte(“UTF-8));       문자열을 지정한 문자코드표에 따라 인코딩하여 바이트 배열을 만든다.           바이트 배열에 들어있는 값을 사용하여 String 인스턴스를 만든다.            new String(바이트 배열, 시작번호, 개수, 문자코드표)       ex ) new String(buf, 0, 10, “UTF-8”)           버퍼     버퍼를 사용하면 파일을 읽고 쓰는 속도가 빨라진다.   flush(); 를 사용하면 버퍼가 아직 다 차지 않은 상태에서 버퍼에 있는 데이터를 강제로 모두 내보내고 버퍼를 비운다.   상속을 통한 기능 확장의 문제점     자바는 다중 상속이 불가능하기 때문에 여러 클래스에 있는 기능을 조합하려면 별도의 클래스를 생성하여 기존 코드를 복사해 와야 한다.            결국 코드가 중복되는 문제가 발생한다.       또한 중복 코드를 갖는 클래스가 많이 생성된다.           이 문제점을 해결하기 위해 확장 기능을 붙였다 뗄 수 있게 한다.            Decoration Design Pattern                    모든 부품은 같은 유형이다.           즉, 같은 부모의 자식이 되게 한다.           다른 부품을 붙일 수 있도록 생성자를 만든다.                           부품을 추가할 때는 기존의 객체에 플러그인을 장착한다.   ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200921/",
        "teaser": null
      },{
        "title": "2020-09-22 TIL",
        "excerpt":"데코레이터 패턴     주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 객체에 추가적인 요건을 동적으로 첨가하며, 기능 확장이 필요할 때 서브 클래스를 만드는 대신 쓸 수 있는 대안   구조          https://gmlwjd9405.github.io/images/design-pattern-decorator/decorator-pattern.png       Component            기본 기능을 뜻하는 ConcreteComponent와 추가 기능을 뜻하는 Decorator의 공통 기능을 정의       즉, 클라이언트는 Component를 통해 실제 객체를 사용함           ConcreteComponent   -기본 기능을 구현하는 클래스   Decorator   -많은 수가 존재하는 구체적인 Decorator의 공통 기능을 제공   ConcreteDecoratorA, ConcreteDecoratorB   -Decorator의 하위 클래스로 기본 기능에 추가되는 개별적인 기능을 뜻함            ConcreteDecorator 클래스는 ConcreteComponent 객체에 대한 참조가 필요한데, 이는 Decorator 클래스에서 Component 클래스로의 ‘합성(composition) 관계’를 통해 표현됨 https://gmlwjd9405.github.io/2018/07/09/decorator-pattern.html           Serialize     인스턴스를 바이트 배열로 바꾸는 것            바이트 배열에는 인스턴스 필드 값 + 클래스 정보           직렬화   고유의 값(시리얼 버젼 UID)을 부여해서 데이터를 아웃, 인 할 때 동일한 데이터인지 비교한다.   시리얼 버젼 UID는 개발자가 지정하지 않으면 자동으로 생성된다.   필드를 추가하지 않고 메서드를 바꾸는 것은 시리얼 버젼 UID가 변경되지 않는다.            하지만 필드를 추가하는 경우 시리얼 버젼 UID가 변경된다.           시리얼 버젼 UID를 지정해놨을 경우 필드를 변경해도 실행 오류가 생기지 않는다.   deserialize를 통해 인스턴스가 생성될 때는 생성자가 호출되지 않는다.   데이터 왜곡을 막기 위해서 transient 명령어를 사용한다.  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200922/",
        "teaser": null
      },{
        "title": "2020-09-23 TIL",
        "excerpt":"한빛출판판네트워크 코딩 테스트 문제 유형 2020  검색해보시오   pms 30   putlic class App saveproject 확인   아래가 정상 코드   public class App {   // main(), saveBoards(), loadBoards() 가 공유하는 필드    static List boardList = new ArrayList&lt;&gt;();   static File boardFile = new File(\"./board.data\"); // 게시글을 저장할 파일 정보   // main(), saveMembers(), loadMembers() 가 공유하는 필드    static List memberList = new LinkedList&lt;&gt;();   static File memberFile = new File(\"./member.data\"); // 회원을 저장할 파일 정보   // main(), saveProjects(), loadProjects() 가 공유하는 필드    static List projectList = new LinkedList&lt;&gt;();   static File projectFile = new File(\"./project.data\"); // 프로젝트를 저장할 파일 정보   // main(), saveTasks(), loadTasks() 가 공유하는 필드    static List taskList = new ArrayList&lt;&gt;();   static File taskFile = new File(\"./task.data\"); // 작업을 저장할 파일 정보   public static void main(String[] args) {   // 파일에서 데이터 로딩 loadBoards(); loadMembers(); loadProjects(); loadTasks();  Map&lt;String,Command&gt; commandMap = new HashMap&lt;&gt;();  commandMap.put(\"/board/add\", new BoardAddCommand(boardList)); commandMap.put(\"/board/list\", new BoardListCommand(boardList)); commandMap.put(\"/board/detail\", new BoardDetailCommand(boardList)); commandMap.put(\"/board/update\", new BoardUpdateCommand(boardList)); commandMap.put(\"/board/delete\", new BoardDeleteCommand(boardList));  MemberListCommand memberListCommand = new MemberListCommand(memberList); commandMap.put(\"/member/add\", new MemberAddCommand(memberList)); commandMap.put(\"/member/list\", memberListCommand); commandMap.put(\"/member/detail\", new MemberDetailCommand(memberList)); commandMap.put(\"/member/update\", new MemberUpdateCommand(memberList)); commandMap.put(\"/member/delete\", new MemberDeleteCommand(memberList));  commandMap.put(\"/project/add\", new ProjectAddCommand(projectList, memberListCommand)); commandMap.put(\"/project/list\", new ProjectListCommand(projectList)); commandMap.put(\"/project/detail\", new ProjectDetailCommand(projectList)); commandMap.put(\"/project/update\", new ProjectUpdateCommand(projectList, memberListCommand)); commandMap.put(\"/project/delete\", new ProjectDeleteCommand(projectList));  commandMap.put(\"/task/add\", new TaskAddCommand(taskList, memberListCommand)); commandMap.put(\"/task/list\", new TaskListCommand(taskList)); commandMap.put(\"/task/detail\", new TaskDetailCommand(taskList)); commandMap.put(\"/task/update\", new TaskUpdateCommand(taskList, memberListCommand)); commandMap.put(\"/task/delete\", new TaskDeleteCommand(taskList));  commandMap.put(\"/hello\", new HelloCommand());  Deque&lt;String&gt; commandStack = new ArrayDeque&lt;&gt;(); Queue&lt;String&gt; commandQueue = new LinkedList&lt;&gt;();  loop:   while (true) {     String inputStr = Prompt.inputString(\"명령&gt; \");      if (inputStr.length() == 0) {       continue;     }      commandStack.push(inputStr);     commandQueue.offer(inputStr);      switch (inputStr) {       case \"history\": printCommandHistory(commandStack.iterator()); break;       case \"history2\": printCommandHistory(commandQueue.iterator()); break;       case \"quit\":       case \"exit\":         System.out.println(\"안녕!\");         break loop;       default:         Command command = commandMap.get(inputStr);         if (command != null) {           try {             // 실행 중 오류가 발생할 수 있는 코드는 try 블록 안에 둔다.             command.execute();           } catch (Exception e) {             // 오류가 발생하면 그 정보를 갖고 있는 객체의 클래스 이름을 출력한다.             System.out.println(\"--------------------------------------------------------------\");             System.out.printf(\"명령어 실행 중 오류 발생: %s\\n\", e);             System.out.println(\"--------------------------------------------------------------\");           }         } else {           System.out.println(\"실행할 수 없는 명령입니다.\");         }     }     System.out.println();   }  Prompt.close();  // 데이터를 파일에 저장 saveBoards(); saveMembers(); saveProjects(); saveTasks();   }   맨 앞을 바꾸니까 정상 작동함   public class App {   // main(), saveBoards(), loadBoards() 가 공유하는 필드   static List boardList = new ArrayList&lt;&gt;();   static File boardFile = new File(\"./board.data\"); // 게시글을 저장할 파일 정보   static List memberList = new LinkedList&lt;&gt;();   static File memberFile = new File(\"./member/data\");   static List projectList = new LinkedList&lt;&gt;();   static File projectFile = new File(\"./project/data\");   static List taskList = new ArrayList&lt;&gt;();   static File taskFile = new File(\"./task/data\");   public static void main(String[] args) {   // 파일에서 데이터 로딩 loadBoards(); loadMembers(); loadProjects(); loadTasks();  Map&lt;String,Command&gt; commandMap = new HashMap&lt;&gt;();  commandMap.put(\"/board/add\", new BoardAddCommand(boardList)); commandMap.put(\"/board/list\", new BoardListCommand(boardList)); commandMap.put(\"/board/detail\", new BoardDetailCommand(boardList)); commandMap.put(\"/board/update\", new BoardUpdateCommand(boardList)); commandMap.put(\"/board/delete\", new BoardDeleteCommand(boardList));   MemberListCommand memberListCommand = new MemberListCommand(memberList); commandMap.put(\"/member/add\", new MemberAddCommand(memberList)); commandMap.put(\"/member/list\", memberListCommand); commandMap.put(\"/member/detail\", new MemberDetailCommand(memberList)); commandMap.put(\"/member/update\", new MemberUpdateCommand(memberList)); commandMap.put(\"/member/delete\", new MemberDeleteCommand(memberList));  commandMap.put(\"/project/add\", new ProjectAddCommand(projectList, memberListCommand)); commandMap.put(\"/project/list\", new ProjectListCommand(projectList)); commandMap.put(\"/project/detail\", new ProjectDetailCommand(projectList)); commandMap.put(\"/project/update\", new ProjectUpdateCommand(projectList, memberListCommand)); commandMap.put(\"/project/delete\", new ProjectDeleteCommand(projectList));  commandMap.put(\"/task/add\", new TaskAddCommand(taskList, memberListCommand)); commandMap.put(\"/task/list\", new TaskListCommand(taskList)); commandMap.put(\"/task/detail\", new TaskDetailCommand(taskList)); commandMap.put(\"/task/update\", new TaskUpdateCommand(taskList, memberListCommand)); commandMap.put(\"/task/delete\", new TaskDeleteCommand(taskList));  commandMap.put(\"/hello\", new HelloCommand());  Deque&lt;String&gt; commandStack = new ArrayDeque&lt;&gt;(); Queue&lt;String&gt; commandQueue = new LinkedList&lt;&gt;();  loop:   while (true) {     String inputStr = Prompt.inputString(\"명령&gt; \");      if (inputStr.length() == 0) {       continue;     }      commandStack.push(inputStr);     commandQueue.offer(inputStr);      switch (inputStr) {       case \"history\": printCommandHistory(commandStack.iterator()); break;       case \"history2\": printCommandHistory(commandQueue.iterator()); break;       case \"quit\":       case \"exit\":         System.out.println(\"안녕!\");         break loop;       default:         Command command = commandMap.get(inputStr);         if (command != null) {           try {             // 실행 중 오류가 발생할 수 있는 코드는 try 블록 안에 둔다.             command.execute();           } catch (Exception e) {             // 오류가 발생하면 그 정보를 갖고 있는 객체의 클래스 이름을 출력한다.             System.out.println(\"--------------------------------------------------------------\");             System.out.printf(\"명령어 실행 중 오류 발생: %s\\n\", e);             System.out.println(\"--------------------------------------------------------------\");           }         } else {           System.out.println(\"실행할 수 없는 명령입니다.\");         }     }     System.out.println();   }  Prompt.close();  // 데이터를 파일에 저장 saveBoards(); saveMembers(); saveProjects(); saveTasks();   }   static void printCommandHistory(Iterator iterator) {     try {       int count = 0;       while (iterator.hasNext()) {         System.out.println(iterator.next());         count++;       if ((count % 5) == 0 &amp;&amp; Prompt.inputString(\":\").equalsIgnoreCase(\"q\")) {       break;     }   } } catch (Exception e) {   System.out.println(\"history 명령 처리 중 오류 발생!\"); }   }   private static void saveBoards() {     FileOutputStream out = null;   try {   // 파일로 데이터를 출력할 때 사용할 도구를 준비한다.   out = new FileOutputStream(boardFile);    out.write(boardList.size() &gt;&gt; 24);   out.write(boardList.size() &gt;&gt; 16);   out.write(boardList.size() &gt;&gt; 8);   out.write(boardList.size());    for (Board board : boardList) {     // 게시글 목록에서 게시글 데이터를 꺼내 바이너리 형식으로 출력한다.     // =&gt; 게시글 번호 출력 (4바이트)     out.write(board.getNo() &gt;&gt; 24);     out.write(board.getNo() &gt;&gt; 16);     out.write(board.getNo() &gt;&gt; 8);     out.write(board.getNo());      // =&gt; 게시글 제목 출력     //    문자열의 바이트 길이(2바이트) + 문자열의 바이트 배열     byte[] bytes = board.getTitle().getBytes(\"UTF-8\");     out.write(bytes.length &gt;&gt; 8);     out.write(bytes.length);     out.write(bytes);      // =&gt; 게시글 내용 출력     //    문자열의 바이트 길이(2바이트) + 문자열의 바이트 배열     bytes = board.getContent().getBytes(\"UTF-8\");     out.write(bytes.length &gt;&gt; 8);     out.write(bytes.length);     out.write(bytes);      // =&gt; 게시글 작성자 출력     //    문자열의 바이트 길이(2바이트) + 문자열의 바이트 배열     bytes = board.getWriter().getBytes(\"UTF-8\");     out.write(bytes.length &gt;&gt; 8);     out.write(bytes.length);     out.write(bytes);      // =&gt; 게시글 등록일 출력 (10바이트)     bytes = board.getRegisteredDate().toString().getBytes(\"UTF-8\");     out.write(bytes);      // =&gt; 게시글 조회수 출력     out.write(board.getViewCount() &gt;&gt; 24);     out.write(board.getViewCount() &gt;&gt; 16);     out.write(board.getViewCount() &gt;&gt; 8);     out.write(board.getViewCount());    }   System.out.printf(\"총 %d 개의 게시글 데이터를 저장했습니다.\\n\", boardList.size());  } catch (IOException e) {   System.out.println(\"게시글 데이터의 파일 쓰기 중 오류 발생! - \" + e.getMessage());  } finally {   try {     out.close();   } catch (IOException e) {     // FileWriter를 닫을 때 발생하는 예외는 무시한다.   } }   }   private static void loadBoards() {     FileInputStream in = null;   try {   // 파일을 읽을 때 사용할 도구를 준비한다.   in = new FileInputStream(boardFile);    // 데이터의 개수를 먼저 읽는다. (4바이트)   int size = in.read() &lt;&lt; 24;   size += in.read() &lt;&lt; 16;   size += in.read() &lt;&lt; 8;   size += in.read();    for (int i = 0; i &lt; size; i++) {     Board board = new Board();      // 출력 형식에 맞춰서 파일에서 데이터를 읽는다.     // =&gt; 게시글 번호 읽기     int value = in.read() &lt;&lt; 24;     value += in.read() &lt;&lt; 16;     value += in.read() &lt;&lt; 8;     value += in.read();     board.setNo(value);      // 문자열을 읽을 바이트 배열을 준비한다.     byte[] bytes = new byte[30000];      // =&gt; 게시글 제목 읽기     int len = in.read() &lt;&lt; 8 | in.read();     in.read(bytes, 0, len);     board.setTitle(new String(bytes, 0, len, \"UTF-8\"));      // =&gt; 게시글 내용 읽기     len = in.read() &lt;&lt; 8 | in.read();     in.read(bytes, 0, len);     board.setContent(new String(bytes, 0, len, \"UTF-8\"));      // =&gt; 게시글 작성자 읽기     len = in.read() &lt;&lt; 8 | in.read();     in.read(bytes, 0, len);     board.setWriter(new String(bytes, 0, len, \"UTF-8\"));      // =&gt; 게시글 등록일 읽기     in.read(bytes, 0, 10);     board.setRegisteredDate(Date.valueOf(new String(bytes, 0, 10, \"UTF-8\")));      // =&gt; 게시글 조회수 읽기     value = in.read() &lt;&lt; 24;     value += in.read() &lt;&lt; 16;     value += in.read() &lt;&lt; 8;     value += in.read();     board.setViewCount(value);      // 게시글 객체를 Command가 사용하는 목록에 저장한다.     boardList.add(board);   }   System.out.printf(\"총 %d 개의 게시글 데이터를 로딩했습니다.\\n\", boardList.size());  } catch (Exception e) {   System.out.println(\"게시글 파일 읽기 중 오류 발생! - \" + e.getMessage());   // 파일에서 데이터를 읽다가 오류가 발생하더라도   // 시스템을 멈추지 않고 계속 실행하게 한다.   // 이것이 예외처리를 하는 이유이다!!! } finally {   try {     in.close();   } catch (Exception e) {     // close() 실행하다가 오류가 발생한 경우 무시한다.     // 왜? 닫다가 발생한 오류는 특별히 처리할 게 없다.   } }   }   private static void saveMembers() { FileOutputStream out = null;  try {   out = new FileOutputStream(memberFile);    out.write(memberList.size() &gt;&gt; 24);   out.write(memberList.size() &gt;&gt; 16);   out.write(memberList.size() &gt;&gt; 8);   out.write(memberList.size());    for (Member member : memberList) {      out.write(member.getNo() &gt;&gt; 24);     out.write(member.getNo() &gt;&gt; 16);     out.write(member.getNo() &gt;&gt; 8);     out.write(member.getNo());      byte[] bytes = member.getName().getBytes(\"UTF-8\");     out.write(bytes.length &gt;&gt; 8);     out.write(bytes.length);     out.write(bytes);      bytes = member.getEmail().getBytes(\"UTF-8\");     out.write(bytes.length &gt;&gt; 8);     out.write(bytes.length);     out.write(bytes);      bytes = member.getPassword().getBytes(\"UTF=8\");     out.write(bytes.length &gt;&gt; 8);     out.write(bytes.length);     out.write(bytes);      bytes = member.getPhoto().getBytes(\"UTF-8\");     out.write(bytes.length &gt;&gt; 8);     out.write(bytes.length);     out.write(bytes);      bytes = member.getTel().getBytes(\"UTF-8\");     out.write(bytes.length &gt;&gt; 8);     out.write(bytes.length);     out.write(bytes);      // =&gt; 게시글 등록일 출력 (10바이트)     bytes = member.getRegisteredDate().toString().getBytes(\"UTF-8\");     out.write(bytes);    }   System.out.printf(\"총 %d 개의 게시글 데이터를 저장했습니다.\\n\", memberList.size());  } catch (IOException e) {   System.out.println(\"게시글 데이터의 파일 쓰기 중 오류 발생! - \" + e.getMessage());  } finally {   try {     out.close();   } catch (IOException e) {     // FileWriter를 닫을 때 발생하는 예외는 무시한다.   } }   }   private static void loadMembers() {     FileInputStream in = null;   try {   // 파일을 읽을 때 사용할 도구를 준비한다.   in = new FileInputStream(memberFile);    int size = in.read() &lt;&lt; 24;   size += in.read() &lt;&lt; 16;   size += in.read() &lt;&lt; 8;   size += in.read();    for (int i = 0; i &lt; size; i++) {     Member member = new Member();      // 출력 형식에 맞춰서 파일에서 데이터를 읽는다.     // =&gt; 게시글 번호 읽기     int value = in.read() &lt;&lt; 24;     value += in.read() &lt;&lt; 16;     value += in.read() &lt;&lt; 8;     value += in.read();     member.setNo(value);      // 문자열을 읽을 바이트 배열을 준비한다.     byte[] bytes = new byte[30000];      int len = in.read() &lt;&lt; 8 | in.read();     in.read(bytes, 0, len);     member.setName(new String(bytes, 0, len, \"UTF-8\"));      len = in.read() &lt;&lt; 8 | in.read();     in.read(bytes, 0, len);     member.setEmail(new String(bytes, 0, len, \"UTF-8\"));      len = in.read() &lt;&lt; 8 | in.read();     in.read(bytes, 0, len);     member.setPassword(new String(bytes, 0, len, \"UTF-8\"));      len = in.read() &lt;&lt; 8 | in.read();     in.read(bytes, 0, len);     member.setPhoto(new String(bytes, 0, len, \"UTF-8\"));      len = in.read() &lt;&lt; 8 | in.read();     in.read(bytes, 0, len);     member.setTel(new String(bytes, 0, len, \"UTF-8\"));      // =&gt; 게시글 등록일 읽기     in.read(bytes, 0, 10);     member.setRegisteredDate(Date.valueOf(new String(bytes, 0, 10, \"UTF-8\")));      // 게시글 객체를 Command가 사용하는 목록에 저장한다.     memberList.add(member);   }   System.out.printf(\"총 %d 개의 게시글 데이터를 로딩했습니다.\\n\", memberList.size()); } catch (Exception e) {   System.out.println(\"게시글 파일 읽기 중 오류 발생! - \" + e.getMessage()); } finally {   try {     in.close();   } catch (Exception e) {     // close() 실행하다가 오류가 발생한 경우 무시한다.     // 왜? 닫다가 발생한 오류는 특별히 처리할 게 없다.   } }   }   private static void saveProjects() {     FileOutputStream out = null;   try {   // 파일로 데이터를 출력할 때 사용할 도구를 준비한다.   out = new FileOutputStream(projectFile);    out.write(projectList.size() &gt;&gt; 24);   out.write(projectList.size() &gt;&gt; 16);   out.write(projectList.size() &gt;&gt; 8);   out.write(projectList.size());    for (Project project : projectList) {      out.write(project.getNo() &gt;&gt; 24);     out.write(project.getNo() &gt;&gt; 16);     out.write(project.getNo() &gt;&gt; 8);     out.write(project.getNo());      byte[] bytes = project.getTitle().getBytes(\"UTF-8\");     out.write(bytes.length &gt;&gt; 8);     out.write(bytes.length);     out.write(bytes);      bytes = project.getContent().getBytes(\"UTF-8\");     out.write(bytes.length &gt;&gt; 8);     out.write(bytes.length);     out.write(bytes);      bytes = project.getStartDate().toString().getBytes(\"UTF-8\");     out.write(bytes);      bytes = project.getEndDate().toString().getBytes(\"UTF-8\");     out.write(bytes);      bytes = project.getOwner().getBytes(\"UTF=8\");     out.write(bytes.length &gt;&gt; 8);     out.write(bytes.length);     out.write(bytes);      bytes = project.getMembers().getBytes(\"UTF-8\");     out.write(bytes.length &gt;&gt; 8);     out.write(bytes.length);     out.write(bytes);    }   System.out.printf(\"총 %d 개의 게시글 데이터를 저장했습니다.\\n\", memberList.size());  } catch (IOException e) {   System.out.println(\"게시글 데이터의 파일 쓰기 중 오류 발생! - \" + e.getMessage());  } finally {   try {     out.close();   } catch (IOException e) {     // FileWriter를 닫을 때 발생하는 예외는 무시한다.   } }   }   private static void loadProjects() {     FileInputStream in = null;   try {   // 파일을 읽을 때 사용할 도구를 준비한다.   in = new FileInputStream(projectFile);    int size = in.read() &lt;&lt; 24;   size += in.read() &lt;&lt; 16;   size += in.read() &lt;&lt; 8;   size += in.read();    for (int i = 0; i &lt; size; i++) {     Project project = new Project();      // 출력 형식에 맞춰서 파일에서 데이터를 읽는다.     // =&gt; 게시글 번호 읽기     int value = in.read() &lt;&lt; 24;     value += in.read() &lt;&lt; 16;     value += in.read() &lt;&lt; 8;     value += in.read();     project.setNo(value);      // 문자열을 읽을 바이트 배열을 준비한다.     byte[] bytes = new byte[30000];      int len = in.read() &lt;&lt; 8 | in.read();     in.read(bytes, 0, len);     project.setTitle(new String(bytes, 0, len, \"UTF-8\"));      len = in.read() &lt;&lt; 8 | in.read();     in.read(bytes, 0, len);     project.setContent(new String(bytes, 0, len, \"UTF-8\"));      in.read(bytes, 0, 10);     project.setStartDate(Date.valueOf(new String(bytes, 0, 10, \"UTF-8\")));      in.read(bytes, 0, 10);     project.setEndDate(Date.valueOf(new String(bytes, 0, 10, \"UTF-8\")));      len = in.read() &lt;&lt; 8 | in.read();     in.read(bytes, 0, len);     project.setOwner(new String(bytes, 0, len, \"UTF-8\"));      len = in.read() &lt;&lt; 8 | in.read();     in.read(bytes, 0, len);     project.setMembers(new String(bytes, 0, len, \"UTF-8\"));      projectList.add(project);   }   System.out.printf(\"총 %d 개의 게시글 데이터를 로딩했습니다.\\n\", projectList.size()); } catch (Exception e) {   System.out.println(\"게시글 파일 읽기 중 오류 발생! - \" + e.getMessage()); } finally {   try {     in.close();   } catch (Exception e) {     // close() 실행하다가 오류가 발생한 경우 무시한다.     // 왜? 닫다가 발생한 오류는 특별히 처리할 게 없다.   } }   }   private static void saveTasks() {     FileOutputStream out = null;   try {   // 파일로 데이터를 출력할 때 사용할 도구를 준비한다.   out = new FileOutputStream(taskFile);    out.write(taskList.size() &gt;&gt; 24);   out.write(taskList.size() &gt;&gt; 16);   out.write(taskList.size() &gt;&gt; 8);   out.write(taskList.size());    for (Task task : taskList) {      out.write(task.getNo() &gt;&gt; 24);     out.write(task.getNo() &gt;&gt; 16);     out.write(task.getNo() &gt;&gt; 8);     out.write(task.getNo());      byte[] bytes = task.getContent().getBytes(\"UTF-8\");     out.write(bytes.length &gt;&gt; 8);     out.write(bytes.length);     out.write(bytes);      bytes = task.getDeadline().toString().getBytes(\"UTF-8\");     out.write(bytes);      out.write(task.getStatus() &gt;&gt; 24);     out.write(task.getStatus() &gt;&gt; 16);     out.write(task.getStatus() &gt;&gt; 8);     out.write(task.getStatus());      bytes = task.getOwner().getBytes(\"UTF-8\");     out.write(bytes.length &gt;&gt; 8);     out.write(bytes.length);     out.write(bytes);    }   System.out.printf(\"총 %d 개의 게시글 데이터를 저장했습니다.\\n\", taskList.size());  } catch (IOException e) {   System.out.println(\"게시글 데이터의 파일 쓰기 중 오류 발생! - \" + e.getMessage());  } finally {   try {     out.close();   } catch (IOException e) {     // FileWriter를 닫을 때 발생하는 예외는 무시한다.   } }   }   private static void loadTasks() {     FileInputStream in = null;   try {   // 파일을 읽을 때 사용할 도구를 준비한다.   in = new FileInputStream(taskFile);    int size = in.read() &lt;&lt; 24;   size += in.read() &lt;&lt; 16;   size += in.read() &lt;&lt; 8;   size += in.read();    for (int i = 0; i &lt; size; i++) {     Task task = new Task();      // 출력 형식에 맞춰서 파일에서 데이터를 읽는다.     // =&gt; 게시글 번호 읽기     int value = in.read() &lt;&lt; 24;     value += in.read() &lt;&lt; 16;     value += in.read() &lt;&lt; 8;     value += in.read();     task.setNo(value);      // 문자열을 읽을 바이트 배열을 준비한다.     byte[] bytes = new byte[30000];      int len = in.read() &lt;&lt; 8 | in.read();     in.read(bytes, 0, len);     task.setContent(new String(bytes, 0, len, \"UTF-8\"));      in.read(bytes, 0, 10);     task.setDeadline(Date.valueOf(new String(bytes, 0, 10, \"UTF-8\")));      value = in.read() &lt;&lt; 24;     value += in.read() &lt;&lt; 16;     value += in.read() &lt;&lt; 8;     value += in.read();     task.setStatus(value);      len = in.read() &lt;&lt; 8 | in.read();     in.read(bytes, 0, len);     task.setOwner(new String(bytes, 0, len, \"UTF-8\"));      // 게시글 객체를 Command가 사용하는 목록에 저장한다.     taskList.add(task);   }   System.out.printf(\"총 %d 개의 게시글 데이터를 로딩했습니다.\\n\", taskList.size()); } catch (Exception e) {   System.out.println(\"게시글 파일 읽기 중 오류 발생! - \" + e.getMessage()); } finally {   try {     in.close();   } catch (Exception e) {     // close() 실행하다가 오류가 발생한 경우 무시한다.     // 왜? 닫다가 발생한 오류는 특별히 처리할 게 없다.   } }   }   }  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200923/",
        "teaser": null
      },{
        "title": "2020-09-24 TIL",
        "excerpt":"바이너리 포맷 VS 텍스트 포맷     바이너리 포맷            바이너리 포맷은 사람이 보기가 불편하다.       바이너리 포맷을 이해하는 전용 애플리케이션을 이용해야만 읽고 쓸 수 있다.       텍스트 포맷에 비해 크기가 작다.                    바이너리 포맷은 각 데이터의 크기를 규정해 놓고 쓰고 읽는다.                       일반 바이너리 포맷은 이기종 프로그래밍 언어간 교환이 가능하다.                    그러나 자바의 serialize와 같은 특정 포맷은 다른 언어에서 읽고 쓸 수 없다.           포토샵 같은 특정 애플리케이션 전용 포맷은 다른 언어에서 읽고 쓸 수 없다.                           텍스트 포맷            사람이 직접 보고 편집할 수 있다.       메모장과 같은 텍스트 에디터만 있으면 읽고 쓸 수 있다.       바이너리 포맷에 비해 크기가 크다.                    텍스트 포맷은 메타 데이터(예: 태그)를 이용하여 데이터를 구분한다.                       텍스트 포맷은 이기종 프로그래밍 언어에서도 자유롭게 읽고 쓸 수 있다.                    그래서 텍스트 포맷은 이 기종 플랫폼이나 애플리케이션 간에 데이터를 교환할 때 주로 사용한다.           예) XML, CSV, HTML                           ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200924/",
        "teaser": null
      },{
        "title": "2020-09-25 TIL",
        "excerpt":"JSON     속성-값 또는 키-값 으로 된 데이터 객체를 텍스트로 표현하는 개방형 표준 데이터 포맷이다.     {속성:값, 속성:값, ...} 예) {\"no\":1,\"name\":\"1\",\"email\":\"1\",\"password\":\"1\",\"photo\":\"1\",\"tel\":\"1\"}           텍스트 형식이기 때문에 프로그래밍 언어나 운영체제에 영향을 받지 않는다.   바이너리 방식에 비해 데이터 커지는 문제가 있지만, 모든 프로그래밍 언어에서 다룰 수 있다는 장점이 있다.   인터넷 상에서 애플리케이션 간에 데이터를 주고 받을 때 주로 사용한다.   특히 이기종 플랫폼(OS, 프로그래밍 언어 등) 간에 데이터를 교환할 때 유용하다.   JSON 공식 홈인 https://www.json.org 사이트에 자세한 내용이 있다.   JSON 라이브러리     JSON 데이터 포맷을 다루는 라이브러리다.   JSON 홈페이지에 다양한 프로그래밍 언어에서 사용할 수 있는 라이브러리를 소개한다.   Gson     구글에서 제공하는 JSON 자바 라이브러리다.   자바 객체를 JSON 형식의 텍스트로 변환하는 기능을 제공한다.   JSON 형식의 텍스트를 자바 객체로 변환하는 기능을 제공한다.   DSL     Domain Specific Language   전길남 박사     https://jinyoungez.tistory.com/2   네트워크 NIC     https://ko.wikipedia.org/wiki/네트워크_인터페이스_컨트롤러   Lan Card = 네트워크 인터페이스 컨트롤러   랜 카드 고유번호 = 닉 어드레스 = 맥 어드레스   브라우저 동작 과정 (네트워크)     https://d2.naver.com/helloworld/59361   new Socket(IP Address, port);     아이피 주소에 도메인 주소가 올 수 있다.   local host : 현재 pc를 가리킨다.     ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200925/",
        "teaser": null
      },{
        "title": "2020-09-28 TIL",
        "excerpt":"소켓     https://recipes4dev.tistory.com/153   대기열     클라이언트가 접속을 요청하면 대기열에 클라이언트 정보를 저장한다.   저장은 큐(FIFO) 방식으로 관리한다.   대기열의 크기가 클라이언트의 연결을 허락하는 최대 개수이다.   대기열을 초과하여 클라이언트 요청이 들어왔을 때 서버는 응답하지 않는다.   클라이언트는 내부에 설정된 시간 동안 기다리다 응답을 받지 못하면 예외를 던지고 연결 요청을 취소한다.            new ServerSocket(포트번호, 대기열 크기);           대기열의 개수를 지정하지 않으면 기본이 50개이다.   대기열이 가득 차면 대기열의 개수를 넘어서는 클라이언트 접속이 불가능해진다.   accept()를 호출하는 순간 대기열의 맨 앞의 클라이언트의 정보를 꺼내 연결한다.            대기열에 자리가 비기 때문에 접속하지 못했던 클라이언트의 접속이 가능해진다.           소켓     https://recipes4dev.tistory.com/153   BufferedInput/OutputStream     flush()를 사용하지 않으면 buffer에 데이터가 쌓여있기 때문에 클라이언트가 데이터를 보내도 서버에 도착하지 않는다.            그러므로 BufferedInputStream, BufferedOutputStream을 사용할 경우 flush()를 사용하여 데이터가 버퍼에서 보내지도록 해야한다.          ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200928/",
        "teaser": null
      },{
        "title": "2020-09-29 TIL",
        "excerpt":"character stream     printwriter가 char stream을 전송할 때 flush()를 호출해야 한다.   byte stream은 flush()가 없어도 된다.   헷갈린다면 무조건 flush()를 호출한다.   TCP / UDP     https://simhyejin.github.io/2016/07/04/connectionoriented-connectionless/   connectionfull - stateful / stateless   stateful     stateful 방식  =&gt; 서버와 연결한 후, 클라이언트에서 연결을 끊을 때까지   계속해서 연결을 유지하며 클라이언트 요청을 처리한다.  =&gt; 단점:   한 번 연결하면 클라이언트가 연결을 끊을 때까지 계속 유지한다.   클라이언트가 작업을 요청하지 않더라도 계속  서버에 연결정보를 계속 유지하기 때문에  서버 메모리를 많이 차지하고  동시에 많은 클라이언트의 요청을 처리하기 힘들다.   만약 서버가 순차적으로 클라이언트와 연결을 수행한다면 이전에 연결했던 클라이언트가 연결을 끊기 전까지는  다음 클라이언트와 연결되지 못하는 문제가 있다.   =&gt; 장점:   한 번 서버에 연결되면 클라이언트가 연결을 끊을 때까지 유지되기 때문에 요청할 때 마다 매번 연결 작업을 수행할 필요가 없다.   따라서 요청에 대한 응답이 빠르다.   또한 연결된 상태에서 수행한 작업  정보를 서버에 유지할 수 있어 영속성이 필요한 작업을 처리하는데 유리하다.  =&gt; 작업 시간:   = 데이터 전송 시간 + 작업 처리 시간 + 데이터 수신 시간   즉 작업을 요청할 때마다 연결할 필요가 없기 때문에 연결하는데 시간이 걸리지 않는다.   =&gt; 대표적인 예:     게임 서버 연결: 서버에 한 번 연결되면 게임을 마칠 때까지 데이터를 주고 받는다.   화상 통신: 한 번 연결하면 연결을 끊을 때까지 데이터를 주고 받는다.   채팅 서버: 전용 클라이언트를 이용한 채팅   텔렛: 원격 제어 프로그램   FTP: 파일 전송 프로그램   오프라인 예: 건강보험문의, 상담 등   =&gt; 통신  클라이언트            서버      |——————&gt;| 연결      |——————&gt;| 데이터 수신      |&lt;——————| 데이터 전송      |——————&gt;| 데이터 수신      |&lt;——————| 데이터 전송      |——————&gt;| 데이터 수신      |&lt;——————| 데이터 전송      |——–X———&gt;| 끊기     즉 한 번 연결하면 연결을 끊을 때까지 계속 데이터를 주고 받는다.   # stateless     stateless  =&gt; 서버에 작업을 요청할 때 연결하고, 서버로부터 응답을 받으면 연결을 끊는다.  =&gt; 즉 요청/응답을 한 번만 수행한다.  =&gt; 단점:   요청할 때마다 매번 서버에 연결해야 하기 때문에 실행 시간이 많이 걸린다.   실행시간 = 연결하는데 걸린 시간 + 데이터 전송 시간 + 작업 처리 시간 + 데이터 수신 시간   서버와 연결할 때,  사용자 인증(authentication; 아이디, 암호 유효 여부 검사)이나  사용권한 확인(authorization; 사용자에게 허락된 작업 범위를 확인) 같은  작업을 반드시 수행하는 경우 연결하는데 더더욱 많은 시간이 걸린다.  =&gt; 장점:   서버에 계속 연결된 상태가 아니기 때문에 서버 입장에서는 메모리를 많이 사용하지 않는다.   왜?  클라이언트와 연결을 계속 유지하지 않기 때문에  작업을 처리하는 동안만 연결정보를 유지한다.  그래서 같은 메모리라도 stateful 방식 보다는  더 많은 클라이언트의 요청을 처리할 수 있다.  =&gt; 대표적인 예:   HTTP 통신: 웹브라우저가 서버에 연결한 후 요청을 하고 서버가 응답한 후 연결을 끊는다.   메신저: 메신저 서버에 연결하고 메시지 전송 후 연결 끊는다.   메일 전송: 메일서버에 데이터 전송 후 연결 끊는다.   오프라인 예: 114 안내, 배달 등   =&gt; 통신  클라이언트 서버  |——————&gt;| 연결  |——————&gt;| 데이터 수신  |&lt;——————| 데이터 전송  |——–X———&gt;| 끊기  |——————&gt;| 연결  |——————&gt;| 데이터 수신  |&lt;——————| 데이터 전송  |——–X———&gt;| 끊기  |——————&gt;| 연결  |——————&gt;| 데이터 수신  |&lt;——————| 데이터 전송  |——–X———&gt;| 끊기     서버에 요청할 때 마다 연결하고 응답을 받으면 즉시 연결을 끊는다.   따라서 비영속적인 단일 작업을 처리할 때 적합한 통신 방식이다.   ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL200929/",
        "teaser": null
      },{
        "title": "2020-10-05 TIL",
        "excerpt":"HTTP     HTTP는 Hypertext Transfer Protocol의 약자로, 전 세계의 웹브라우저, 서버, 웹 애플리케이션이 모두 사용하는 인터넷 공용어        신뢰성 있는 데이터 전송 프로토콜 사용; 인터넷의 결함 및 약점에 대한 걱정 없이 기능 구현 가능            HTTP 요청 프로토콜  ———————————  GET [자원주소] HTTP/1.1 (CRLF)  Host: [서버주소] (CRLF)  (CRLF)  ———————————            프로토콜(protocol)?  =&gt; 클라이언트/서버 간의 통신 규칙.  =&gt; 데이터를 주고 받는 규칙.       HTTP 응답 프로토콜  ——————————–  HTTP/1.1 200 OK(CRLF)  Content-Type: text/html; charset=UTF-8(CRLF)  (CRLF)  보낼 데이터  ——————————–   상태 코드     클라이언트의 요청의 성공 여부 등을 알려주는 세 자리 숫자   모든 HTTP 응답 메시지는 상태 코드와 함께 반환   1xx : 정보 제공   2xx : 성공   3xx : 리다이렉션   4xx : 클라이언트 요청 오류        5xx : 서버에서 오류가 발생함       200 OK   301 Moved Permanently   400 Bad Request   403 Forbidden   404 Not Found   MIME     HTTP는 수천 개의 데이터 타입을 다루기 때문에 ‘MIME (Multipurpose Internet Mail Extensions, 다목적 인터넷 메일 확장)‘라는 데이터 포맷 라벨을 웹에서 전송되는 객체 각각에 붙임 쉽게 말하면, 이 웹 콘텐츠가 어떤 데이터 타입인지 알려주는 라벨   표현 형식: ‘주 타입/부 타입’            HTML 데이터 타입 = ‘text/html’       JPEG 이미지 데이터 타입 = ‘image/jpeg’       GIF 이미지 데이터 타입 = ‘image/gif’           포트번호     Port 번호는 16bit : 총 65536개의 port number가 존재   0 ~ 1023 번 - Well Known Port (IANA에서 할당한 TCP, UDP 포트) : 유명한 서버, 특정 서버들.   1024 ~ 49151 번 - Registered Port (기관이나 사업자들을 위해 IANA에서 관리하는 포트)   49152 ~ 65535 번 - Dynamic Port (일반 사용자들이 자유롭게 사용할 수있는 포트)   Port 번호는 일반적으로 IP address 뒤에 콜론(:)을 이용하여 표기            ex) 182.143.421.211:443 (포트번호 443)           잘 알려진 포트 20 - FTP(data)  21 - FTP(제어)  22 - SSH  23 - Telnet   25 - SMTP  53 - DNS &lt;TCP, UDP&gt; 80 - HTTP &lt;TCP, UDP&gt; 110 - POP3  443 - HTTPS    인코딩 문제     인코딩을 스캐너로 인풋할 때 미리 지정하면 한글 깨짐 현상을 해결할 수 있다.   URI &gt; URL, URN     https://mygumi.tistory.com/139   웹크롤링     https://lyb1495.tistory.com/17   base64     https://effectivesquid.tistory.com/entry/Base64-%EC%9D%B8%EC%BD%94%EB%94%A9%EC%9D%B4%EB%9E%80   html은 텍스트 파일이기 때문에 jpg 파일을 직접 삽입할 수 없다.            그러므로 jpg 파일(바이너리 파일)을 텍스트 파일로 변환시켜서 삽입해야 한다.       이 때 사용되는 규칙이 Base64 이다.           Base64 인코딩      =&gt; 바이너리 데이터를 문자화시킨다.      =&gt; 바이너리 값을 6비트식 잘라서(2의 6승)   64진수으로 만든 후 Base64 표에 정의된 대로  해당 값을 문자로 변환한다.      =&gt; 보통 바이너리 데이터를 텍스트로 전송하고 싶을 때 많이 사용한다.      =&gt; “ABC012가간” 문자열  414243303132EAB080EAB081(UTF-8 코드)  4142 ==&gt; 0100000101000010… (2진수)  010000 010100 0010… (6비트씩 자른 것)  6비트로 자른 것을 다시 10진수로 표현하면 ==&gt; 16 20 …  16을 Base64 코드표에 따라 문자로 바꾸면 ==&gt; Q  20을 Base64 코드표에 따라 문자로 바꾸면 ==&gt; U  …  이런 식으로 문자열을 Base64로 바꾸면 결과는 다음과 같다.  QUJDMDEy6rCA6rCB6rCE  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL201005/",
        "teaser": null
      },{
        "title": "계산기 서버, 클라이언트 만들기",
        "excerpt":"계산기 서버와 클라이언트 만들기   Client 01) 단순히 서버에 요청하고 응답을 받아 출력한다.   public class CalculatorClient {   public static void main(String[] args) {      try (Socket socket = new Socket(\"localhost\", 8888);         PrintStream out = new PrintStream(socket.getOutputStream());         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {        String input = in.readLine();       System.out.println(input);        input = in.readLine();       System.out.println(input);        input = in.readLine();       System.out.println(input);      } catch (Exception e) {       e.printStackTrace();     }    } }   Server 01) 단순히 클라이언트 요청에 응답하기   public class CalculatorServer {   public static void main(String[] args) {      try (ServerSocket serverSocket = new ServerSocket(8888)) {       System.out.println(\"서버 실행 중...\");        try (Socket socket = serverSocket.accept();           BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));           PrintStream out = new PrintStream(socket.getOutputStream());) {          out.println(\"계산기 서버에 오신 걸 환영합니다!\");         out.println(\"계산식을 입력하세요!\");         out.println(\"예) 23 + 7\");         out.flush();       }      } catch (Exception e) {       e.printStackTrace();     }   } }   Calculator 02) 응답의 종료 조건을 설정하기   public class CalculatorClient {   public static void main(String[] args) {      try (Socket socket = new Socket(\"localhost\", 8888);         PrintStream out = new PrintStream(socket.getOutputStream());         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {        02)         while (true) {         String input = in.readLine();         if (input.length() == 0) {           // 빈 줄을 읽었다면 읽기를 끝낸다.           break;         }         System.out.println(input);       }      } catch (Exception e) {       e.printStackTrace();     }    } }   Server 02) 응답의 종료 조건을 설정하기   public class CalculatorServer {   public static void main(String[] args) {      try (ServerSocket serverSocket = new ServerSocket(8888)) {       System.out.println(\"서버 실행 중...\");        try (Socket socket = serverSocket.accept();           BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));           PrintStream out = new PrintStream(socket.getOutputStream());) {          out.println(\"계산기 서버에 오신 걸 환영합니다!\");         out.println(\"계산식을 입력하세요!\");         out.println(\"예) 23 + 7\");          02)         out.println(); // 응답의 끝을 표시하는 빈 줄을 보낸다.          out.flush();       }      } catch (Exception e) {       e.printStackTrace();     }   } }   Calculator 03) 응답을 읽는 코드를 별도의 메서드로 분리한다   public class CalculatorClient {   public static void main(String[] args) {      try (Socket socket = new Socket(\"localhost\", 8888);         PrintStream out = new PrintStream(socket.getOutputStream());         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {        03)       readResponse(in);      } catch (Exception e) {       e.printStackTrace();     }    }    03)   static void readResponse(BufferedReader in) throws Exception {     while (true) {       String input = in.readLine();       if (input.length() == 0) {         // 빈 줄을 읽었다면 읽기를 끝낸다.         break;       }       System.out.println(input);     }   } }  Server 03) 안내 메세지 전송 코드를 별도의 메서드로 분리한다   public class CalculatorServer {   public static void main(String[] args) {      try (ServerSocket serverSocket = new ServerSocket(8888)) {       System.out.println(\"서버 실행 중...\");        try (Socket socket = serverSocket.accept();           BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));           PrintStream out = new PrintStream(socket.getOutputStream());) {          03)         sendIntroMessage(out);       }      } catch (Exception e) {       e.printStackTrace();     }   }    03)   static void sendIntroMessage(PrintStream out) throws Exception {     out.println(\"[비트캠프 계산기]\");     out.println(\"계산기 서버에 오신 걸 환영합니다!\");     out.println(\"계산식을 입력하세요!\");     out.println(\"예) 23 + 7\");     out.println(); // 응답의 끝을 표시하는 빈 줄을 보낸다.     out.flush();   } }  ","categories": ["Howto"],
        "tags": [],
        "url": "http://localhost:4000/howto/%EA%B3%84%EC%82%B0%EA%B8%B0-%EC%84%9C%EB%B2%84-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8/",
        "teaser": null
      },{
        "title": "2020-10-07 TIL",
        "excerpt":"Thread     https://brunch.co.kr/@kd4/3   정규 표현식     https://hamait.tistory.com/342   https://www.slideshare.net/ibare/ss-39274621?qid=c5a51df1-3b85-4b2e-9daa-363e4de5b924&amp;v=&amp;b=&amp;from_search=1   프로토콜     https://blockdmask.tistory.com/185   멀티태스킹(Multi-tasking)     동시에 여러 작업을 실행   구현방법            멀티 프로세싱 : 프로세스를 여러개 복제하여 실행       멀티 스레딩 : 멀티 태스킹이 필요한 작업만 분리하여 여러개 실행           CPU 스케쥴링     여러 개의 프로세스를 동시에 실행하기 위해 cpu 사용을 관리하는 방법            1) Round-Robin                    각 프로세스에 균등한 실행 시간 부여           Window OS                       2) Priority + Aging                    우선 순위가 높은 프로세스에 cpu 사용 권한을 더 많이 배분한다.           단 우선 순위가 낮아서 실행이 연기될 때마다 우선 순위 레벨(age)을 높여서 결국 실행하게 만든다.           Lunux, macOS, Unix                           멀티 프로세싱 &lt;- 예전의 멀티태스킹 구현방식     부모 프로세스 -&gt; 복제 -&gt; 자식 프로세스   프로세스는 힙, 스택 등의 메모리를 가지고 있다   메모리 그대로 복제   부모 프로세스 종료해도 자식은 종료하지 않는다.            단순히 복제(fork) -&gt; 구현(코딩)이 쉽다.       메모리를 그대로 복제 -&gt; 메모리 낭비가 심하다       자식 프로세스가 부모에 종속되지 않는다.           멀티 스레딩 &lt;- 현재의 멀티태스킹 구현방식     프로세스가 스레드 생성            스레드는 스택 메모리만 가지고 있음       힙 메모리는 프로세스의 힙 메모리를 공유해서 사용함           스레드 생성 -&gt; 구현이 조금 더 복잡   프로세스의 힙을 공유한다 -&gt; 메모리 절약   스레드가 프로세스에 종속 -&gt; 프로세스 종료 = 스레드 종료   Java 스레드 구현     Thread &lt;—— MyThread 의 run() {독립적으로 수행할 작업}            new MyThread().start();           «interface» Runnavle &lt;- - - MyRunnable 의 run() {독립적으로 수행할 작업}            new Thread(new MyRunnable객체).start();           스레드     모든 스레드는 일회용이다.   모든 스레드는 각각 다른 실로 이루어져 있다.   한 번 실행된 스레드는 다시 사용할 수 없다.   main() 메서드는 스레드 실행이 완료될 때 까지 종료되지 않고 기다린다.   main 스레드의 실행을 모든 스레드 완료 후로 미루고 싶으면 join()을 사용한다.   sleep() 을 사용하면 cpu가 멈추고 main 스레드를 잠재우기 때문에 실행을 지연시킬 수 있다.   ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL201007/",
        "teaser": null
      },{
        "title": "2020-10-08 TIL",
        "excerpt":"데이터 레이스     스레드를 시작시키는 순간 running 상태로 접어든다.            running 상태는 실행하고 있는 상태 뿐만 아니라,   CPU를 받을 수 있는 상태이기도 하다.       CPU는 OS의 관리 정책에 따라 스레드나 프로세스에 배분된다.    물론 OS가 CPU를 배분한 후 임의시간 후에    다시 회수하여 다른 스레드(현재 스레드 포함)나 프로세스에 배분한다.   때에 따라서 같은 스레드가 연속해서 배분 받는 경우도 있을 것이다.           멀티 쓰레드 환경에서 여러 쓰레드가 공유자원에 동시에 접근할 때 쓰레드의 경쟁에 유발되는 문제   데이터 레이스를 없애는 가장 직접적인 방법은 Lock을 사용하는 것            속도 저하 문제가 발생           Lock을 덜 사용하도록 프로그램을 변경            어렵다       완전히 Lock을 없앨 수 없다           데이터레이스를 없애기 위해 데이터레이스 앞뒤로 락을 두면 엄청난 속도 저하가 있음   락을 덜 사용하도록 데이터레이스가 적게 프로그램을 변경하는 것은 어렵고 데이터레이스를 완전히 없앨 수 없다.            데이터레이스를 없앤다는 것은 스레드끼리 서로 공유 메모리를 통해 데이터를 주고받지 않겠다는 것인데 이것은 줄일수는 없애도 완전히 없앨수 없다. 완전히 없앤다는 것은 스레드끼리 데이터를 주고 받는 일이 없도록 만들어 협업하지 않도록 프로그래밍을 한다는 이야기이다.           락을 회피하는 프로그래밍            데이터레이스를 줄여서 락의 필요성을 줄인다.       데이터레이스가 있지만 전후 사정을 잘 파악해서 락을 넣지 않아도 잘 수행되도록 프로그래밍 한다.           동기화     데이터 레이스를 방지하기 위해 동기화 기법을 사용   스레드끼리 데이터를 주고받거나 실행 순서를 맞추는 행위   협업을 위해 필수   컨텍스트 스위칭(Context Switching)     https://agh2o.tistory.com/12   프로세스나 스레드를 실행하기 위해 실행 정보를 읽어오고 저장하는 것   멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 교체하는 작업을 Context Switch(Context Switching)라고 한다.   동시에 여러 개의 프로세스나 스레드를 실행할 때 CPU 사용권을 뺏어 다른 프로세스나 스레드에게 주기 전에 현재까지 실행한 코드의 위치 정보를 저장해야 한다. 또한 CPU 사용권을 주기 전에 그 프로세스나 스레드가 이전에 어디까지 실행했었는지 이전 실행 위치 정보를 로딩해야 한다. 즉 실행 위치에 대한 정보를 저장하고 로딩하는 것을 말한다.   프로세스(스레드) 스케줄링     OS가 프로세스나 스레드에 CPU 사용을 배분하는 정책            1) Round-Robin 방식                    Windows 운영체제에서 사용하는 방식이다.           우선 순위 보다는 일정 시간 위주로 프로세스나 스레드에게 CPU를 배분하는 방식이다.                       2) Priority + Aging 방식                    Unix나 Linux 운영체제에서 사용하는 방식이다.           우선 순위가 높은 프로세스나 스레드에게 CPU를 먼저 배분하는 방식이다.           우선 순위 배분 방식에서는 우선 순위가 낮은 경우 실행에서 소외되는 문제가 발생하기 때문에                           우선 순위가 높은 프로세스나 스레드 때문에 실행 순서가 밀릴 때 마다 원래의 낮은 순위를 높임으로써(aging) 결국에는 모든 프로세스와 스레드의 실행을 완료할 수 있게 한다.   우선순위          우선 순위가 높으면 CPU 사용 배분을 좀 더 자주 받는다.    =&gt; 스레드는 JVM에서 관리하는 것이 아니라 OS가 관리한다.    =&gt; 즉 OS의 스레드를 이용하는 것이다.    =&gt; 따라서 우선 순위에 따라 실행 스케줄을 어떻게 관리할지는 OS에 따라 다르다.    =&gt; Windows OS는 우선 순위를 크게 고려하지 않는다. 그래서 Windows에서 실행할 때는 우선 순위에 영향을 적게 받을 것이다.    =&gt; Unix, Linux 계열 OS는 우선 순위를 고려한다. 그래서 이런 OS에서 실행할 때는 우선 순위에 영향을 받을 것이다.       주의!    =&gt; Java 의 캐치프레이즈가 “Write Once, Run Anywhere!” 이다.    =&gt; 즉 OS에 상관없이 동일하게 동작하게 만드는 것이 자바의 목적이다.    =&gt; 그런데 우선 순위에 따라 실행률이 달라지고, OS 마다 차이가 난다면, 자바의 목적에 부합하는 것이 아니다.    =&gt; 그래서 가능한 OS에 영향을 덜 받는 방식으로 코딩해야 한다.    =&gt; 이런 이유로 스레드를 다룰 때 우선 순위를 고려하는 방식으로 프로그래밍을 하지 말라!       비동기 방식으로 인한 문제          여러 개의 스레드가    같은 객체에 대해 메서드를 호출하여 동시에 값을 변경하려 할 때    서로 그 메모리의 값을 덮어쓰는 문제가 발생한다.    이처럼 여러 스레드가 동시에 실행할 때 문제를 일으키는 코드를    “임계 구역(Critical Section; Critical Region)”이라 부른다.    이 예제에서는 여러 스레드가 동시에 호출하고,    같은 인스턴스의 변수 값을 변경하는 메서드인 “withdraw()”가    critical section이다.       해결책?    =&gt; 한 번에 한 스레드 만이 크리티컬 섹션을 실행하도록 접근을 제한하면 된다.    주의!    =&gt; 동시에 여러 스레드가 같은 메모리에 대해 값을 조회할 때는 문제가 발생하지 않는다.       세마포어(n); semaphore    =&gt; 크리티컬 섹션에 진입할 수 있는 스레드의 수를 지정한다.    =&gt; 자바에서는 세마포어를 지원하지 않는다.    =&gt; 개발자가 직접 처리해야 한다.       뮤텍스; mutex(mutual exclusion, 상호배제)    =&gt; 한 번에 오직 한 개의 스레드만이 크리티컬 섹션에 접근할 수 있다.    =&gt; 예) 선풍기 풍량세기, 라디오 채널, TV 채널 등    =&gt; semaphore(1)과 같다.    =&gt; 자바는 synchronized 키워드를 통해 뮤텍스를 사용할 수 있다.       용어정리!  임계 구역(critical section)   여러 스레드가 동시에 실행할 때 문제가 발생하는 코드 블록을 말한다.   critical region 이라고도 부른다.   같은 메모리에 여러 스레드가 동시에 접근하여 값을 변경하려 할 때 문제가 발생하는 것이다.  즉 다른 스레드가 사용하는 변수의 값을 임의로 변경하면 원래의 의도대로 동작하지 않게 되는 것이다.   “스레드 안전(thread safe)하지 않다”라고 말한다.   스레드 안전(thread safe)     여러 스레드가 동시에 실행하더라도 아무런 문제가 되지 않는 코드를 말한다.   여러 스레드가 같은 메모리에 접근하더라도 읽기만 한다면 아무런 문제가 되지 않는다.   세마포어(semaphore)     critical section에 접근하는 스레드의 수를 제어하는 기법   보통 다음의 형식으로 표시한다.  semaphore(n)  n은 개수를 의미한다.  예) semaphore(3) : 동시에 3개의 스레드가 접근할 수 있다는 의미다.   자바는 2개 이상의 접근을 허용하지 않는다. 오직 한 개만 가능하다.   뮤텍스(mutual exclusion; MUTEX)     critical section에 오직 한 개의 스레드만이 접근하는 것.   semaphore(1) 과 같다.   자바에서 synchronized 는 해당 블록(critical section)을 뮤텍스로 선언하는 것이다.   뮤텍스     데드락을 피해야 한다.   어느 하나의 스레드가 메모리에 들어가서 특정 조건이 만족되면 락을 해제하고 나오려고 하는데, 다른 스레드가 특정 조건이 만족되면 들어가려고 하는 상황.   예) 화장실 변기칸에서 안에 있는 사람은 이름을 적으면 문을 열고 나온다고 하고 밖에 있는 사람은 문을 열어주면 이름을 적는다고 하는 상황.   실행 멈춤.   특정 개수의 스레드만이 진입할 수 있도록 통제하는 것을 세마포어라고 한다.            자바 기본 문법이 없다.       직접 구현해야 한다.           sleep()     해당 시간동안 cpu 사용권을 받지 않겠다는 의미.  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL201008/",
        "teaser": null
      },{
        "title": "2020-10-12 TIL",
        "excerpt":"Observer 패턴     특정 객체의 상태 변화에 따라 작업을 수행하고 싶을 때 사용하는 패턴.   메일 구독 서비스   특정 객체의 상태 변화에 따라 수행해야 하는 작업이 있을 경우, 기존 코드를 손대지 않고 손쉽게 기능을 추가하거나 제거할 수 있는 설계 기법이다.   발행/구독 모델이라고 부르기도 한다.   발행(publisher) 측에서는 구독 객체(subscriber)의 목록을 유지할 컬렉션을 가지고 있다.   구독 객체를 리스너(listener) 또는 관찰자(observer)라 부르기도 한다.   ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL201012/",
        "teaser": null
      },{
        "title": "2020-10-13 TIL",
        "excerpt":"33 파일 입출력에 옵저버 디자인 적용하기   디자인 패턴을 적용하는 이유     코드 구조가 복잡해지더라도 기존 기능에 다른 기능을 추가하거나 삭제하는 것을 조금 더 쉽게 하기 위해서   옵저버 등록     인터페이스는 호출 규칙   App 에서 기능을 추가할 때 인터페이스인 ApplicationContextListener를 통해서 AppInitListener를 등록한다.   웹 서버에 등록할 때는     @WebServlet 라는 애노테이션을 통해서 클래스를 등록할 수 있다.   패키지를 만들 때     특정 클래스에서만 쓸때는 그 특정 클래스가 포함된 패키지 아래에 패키지를 생성하지만 범용으로 사용할 때는 도메인 아래에 패키지를 생성하는 것이 좋다.   예)            eomcs/context/ApplicationContextListener       eomcs/pms/App       eomcs/pms/listner/AppInitListener           앱과 옵저버 사이의 데이터 공유     데이터를 공유할 수 있도록 규칙에 파라미터를 추가한다.            1) App에서 key value를 사용하는 Map을 생성       2) 메서드 호출       3) Observer에서 맵에 저장된 값을 사용해서 작업을 수행       4) 작업 결과를 맵에 저장       5) 맵에 저장된 결과 값을 App에서 꺼낸다.           hashtable/ hashmap     hashmap은 키나 밸류에 null을 허용한다.   hashtable은 키내 밸류에 null을 허용하지 않는다.   hashmap은 멀티스레드 환경에서 사용되는 것을 보장하지 않는다.            여러 스레드가 해시맵에 접근하는 것을 허용       락을 걸지 않는다.                    스레드 세이프 하지 않는다.                           hashtable은 여러 스레드가 접근하지 못하도록 한다.            하나의 스레드가 접속했을 경우 다른 스레드는 기다려야 한다.       락을 건다.           인아웃 파라미터     인 파라미터 = 값을 받는 파라미터   아웃 파라미터 = 값을 리턴하는 파라미터   값을 받거나 리턴하는 것을 동시에 할 수 있는 파라미터 = 인아웃 파라미터   옵저버가 작업한 결과를 맵에서 꺼낼 때     자바는 옵저버가 작업한 결과를 맵에서 꺼낼 때 확인을 할 수 없기 때문에 경고를 띄운다.   데이터핸들러리스너에서 데이터를 로딩할 때     로딩한 파일을 해시테이블에 put(String key, Object value)을 이용해서 저장한다.   34 네트워크 API를 활용하여 애플리케이션 사이에 데이터 주고받기 - stateful 통신   이클립스 설정     폴더 준비   해당 폴더에서 gradle init   build 파일 수정 id ‘eclipse’            eclipse에 임포트 하기 위해 필요한 설정 파일을 생성하기 위한 플러그인을 준비한다.           gradle eclipse            빌드 파일 수정 시 gradle cleaneclipse 후 gradle eclipse       설정 파일 생성           네크워크 API를 사용하여 간단한 메시지를 주고 받는 클라이언트 만들기를 연습     소켓 클래스를 이용하여 서버에 접속한다.   소켓의 입출력 스트림을 이용하여 서버와 데이터를 주고 받는다.  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL201013/",
        "teaser": null
      },{
        "title": "2020-10-14 TIL",
        "excerpt":"34-c 사용자가 입력한 명령 처리     stateful            1) c/s projcet 준비       2) c/s 간에 메시지 송수신 테스트       3) 사용자 입력값 송수신       4) 다중 클라이언트 요청 처리       5) 스레드 적용           stateless            6) stateful -&gt; stateless 전환       7) 스레드 재활용 -&gt; 스레드풀       8) 기능을 옮긴다           사용자가 입력한 명령을 서버에 전송하기 - 클라이언트앱     프롬프트를 가져온다.   클라이언트 앱을 변경해서 사용자가 입력한 명령을 보낼 수 있게 만든다.   terminal     백엔드에 서버가 있고 사람들은 terminal을 사용했다.   1980 년대 IBM terminal   터미널에는 모니터, 키보드 네트워크 연결만 있다.        본체 하나에 여러 터미널이 연결되어 있어서 멀티 프로세싱 개념이 있었다.       pc가 발달하면서 pc 하나를 여러 사람이 썼다.   개인별 pc가 지급된 다음에는 파일을 외부 pc를 하나 두고 파일을 저장했다.            여러 사람이 중복으로 사용했을 대 파일을 덮어쓰는 문제가 발생함.       이를 해결하기 위해 순서를 정해서 각자 시간차를 두고 사용함.           불편함을 해결하기 위해 pc에 app을 설치하고 그 앱이 파일을 관리하도록 하고 개인별 pc의 앱은 요청을 하도록 했다.   어플리케이션 아키텍처     데스크탑   c/s 어플리케이션   어플리케이션 서버   웹 어플리케이션 서버   입출력     FileDB            파일 입출력을 위해 만들어 둔 프로그램       파일끼리의 관련이 없는 경우에 사용함           c/s            클라이언트(pc)와 서버(DB)로 나눠서 사용       해킹 문제가 생김       프로그램이 업그레이드 될때마다 재설치           WAS(Web Application Server)            어플리케이션을 실행하는 서버       데이터베이스 서버       pc는 어플리케이션을 실행하는 서버에 접속하도록 한다.       웹이 발달       어플리케이션을 실행하는 서버는 웹 서버       클라이언트는 브라우저 사용           모바일 환경이 발달            화면이 다름       프론트 HTML, Css, java script / 백 java, sql / 모바일 android, ios 로 세분화 됨           반복해서 클라이언트의 요청을 처리한다 - 서버앱     앱 변경            반복해서 클라이언트에게 응답한 후 종료하지 않고 계속 요청을 처리한다.       클라이언트가 quit 명령을 보내면 클라이언트와 연결을 끊는다.           응답 프로토콜 정의     응답을 완료한 다음에는 종료의 의미로 빈줄을 보낸다.   클라이언트 연결     클라이언트와 연결을 끊은 후 다음 클라이언트와 연결한다.   34-e     서버앱의 핸들 클라이언트에서 예외를 던졌을 때 아무도 받지 않으면 아래쪽의 캐치문에서 예외를 받아서 그대로 서버를 종료해버린다.            이 문제를 해결하기 위해서 던져진 예외를 핸들 클라이언트를 호출한 쪽에서 받아서 처리하거나 아래쪽의 핸들 클라이언트 메서드 안에서 자체적으로 처리하게 할 수도 있다.       이것은 선택의 문제.       보통 스레드라면 메서드 안에서 자체적으로 처리해야 한다.                    스레드는 실이고 하나의 라인           스레드를 별도로 만드는 것은 별도의 실을 만드는 것           다른 실에서 발생한 예외를 메인 스레드가 받을 방법이 없다.                       스레드가 아니라면 호출한 쪽에서 처리해도 괜찮다.           stateful 방식으로 하면 한 명이 서버에 접속했을 때 다른 사람이 서버에 접속할 수가 없다.            그래서 멀티 스레드가 필요하다.           서버가 윈도우일때            java -Dfile.encoding=UTF-8 -cp bin/main com.eomcs.pms.ServerApp       윈도우즈가 서버일 때 자바 프로그램은 밖에서 들어오는 것을 다 ms949로 인식하고 있다.       클라이언트가 맥일 경우 보내는 파일은 utf-8이다.           같이 통신하려면 같은 네트워크에 있어야 한다.   43-f 동시에 여러 사람의 요청을 처리하고 싶을 때 - 멀티스레딩          클라이언트의 요청을 처리할 clientHandler를 새로 만든다.            try (Socket socket = this.socket;       BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));       PrintWriter out = new PrintWriter(socket.getOutputStream())) {       while (true) {   String request = in.readLine();   sendResponse(out, request);   if (request.equalsIgnoreCase(\"quit\"))     break; }           } catch (Exception e) {     System.out.println(“클라이언트와의 통신 오류”);   }       System.out.printf(“클라이언트(%s)와의 연결을 끊었습니다.\\n”, address.getHostAddress()); }            this.socket을 socket으로 다시 받는 이유는 이렇게 하면 try 블록에서 떠날 때 close()를 자동 호출할 수 있기 때문이다.       인스턴스 멤버를 사용하지 않는 필드는 스태틱으로 하는 것이 원칙이다.   ex) private static void sendResponse(PrintWriter out, String message) {   out.println(message);   out.println();   out.flush(); }   하지만 받은 파라미터 값만 사용할 때도 인스턴스로 만들 때가 있다.   ex)    private void sendResponse(PrintWriter out, String message) { out.println(message); out.println(); out.flush();   }        왜냐? 지금은 인스턴스를 사용하지 않지만 나중에 인스턴스 멤버를 사용하는 코드가 삽입될 수가 있기 때문에 처음부터 인스턴스 멤버로 만든다.       서버 변경            클라이언트 요청 처리를 클라이언트 핸들러에게 맡긴다.           중첩 클래스     중첩 클래스가 바깥 클래스의 인스턴스 멤버를 쓴다는 것은 바깥 클래스의 특정 인스턴스에 종속된다는 것이다.            마깥 클래스의 특정 인스턴스 멤버를 사용할 일이 없기 때문에 static nested class로 만든다.       인스턴스 멤버인 경우 inner class           3) 중첩 클래스로 만들었을 경우 서버와 연결하는 것은 스레드 밖으로 빼야한다.            왜? 서버와 연결된 다음에 스레드를 실행해야 하기 때문에.       스레드 안으로 넣으면 안된다.           4) 익명 클래스의 코드를 바깥 클래스의 멤버로 만들어 놓고 사용한다.            왜? 코드를 읽기 쉽도록 하기 위해서       코드가 여러 블록에 중첩되면 될수록 들여쓰기를 하면서 코드를 읽기가 불편해진다.           5) 람다 문법 적용            인터페이스인 경우 메서드 명 지우기       메서드 바디만 남기기       화살표       한 줄일 경우 중괄호 없앨 수 있음           34-g pms 코드를 c/s로 분리     1) Json 데이터 포맷을 다룰 Gson 라이브러리를 추가한다.            build.gradle 파일에 gson 라이브러리 정보를 추가한다.       터미널을 사용해 폴더에서 gradle eclipse 를 실행한다.       리프레시           2) 기존 애플리케이션에서 관련된 패키지 및 클래스를 가져온다.            도메인 패키지       핸들러 패키지       컨텍스트 패키지       리스너 패키지       앱 클래스에서 옵저버 패턴과 관련된 코드           3) client 의 stop 명령을 처리한다.            서버앱에 stop 변수 추가       클라이언트와 연결할 때 stop의 상태가 true 이면 서버를 멈춘다.                4) 서버에 stop 명령을 보내면 클라이언트를 즉시 종료한다.       5) 서버앱에 옵저버를 추가한다.            서버를 띄울 때 터미널을 사용하면 gson 파일이 없다고 나온다.       외부 라이브러리를 사용하기 때문에.                    .classpath 가 라이브러리 정보를 가지고 있다.           .classpath의 정보를 가지고 이클립스가 command Line을 만들어서 실행한다.                       클라이언트의 요청을 처리하는 command 객체를 준비한다.                    RequestMappingListener 클래스를 만들고 App에서 필요한 코드를 복사해온다.           context에 리스트와 커맨드 객체가 다 담겨있다.                       RequestMappingListener를 등록한다.           6) 클라이언트 명령이 들어오면 커맨드 객체를 찾아 실행한다.  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL201014/",
        "teaser": null
      },{
        "title": "2020-10-15 TIL",
        "excerpt":"34-g     클라이언트 명령이 들어오면 커맨드 객체를 찾아 실행한다.   pms.handler.Command 변경   execute() 를 execute(PrintWriter out)로 변경   서버앱을 수정(쓸모없는 코드는 삭제)   if (command != null) {           command.execute(out);         } else {           out.println(“해당 명령을 수행할 수 없습니다.”);         }         out.println(); // 응답의 끝을 알려주는 빈문자열         out.flush();   06) Command를 상속받는 handler 클래스들을 수정  - XxxListCommand 의 execute()가 파라미터를 받게 만들고 system.out.print() 메서드를 out.print()로 수정하여 out을 사용하게 만든다. ## 07) 클라이언트에게 입력값을 요구할 수 있도록 프로토콜을 변경한다.   [클라이언트]                [서버] 명령      ---------------&gt; 작업수행 \"/board/detail\" 출력      &lt;--------------- 출력 문자열                           \"번호\" 사용자 입력 &lt;--------------- 입력을 요구하는 명령                           !{}! 입력값     ---------------&gt; 작업 수행 \"1\" 출력      &lt;--------------- 출력 문자열                           \"제목 : 하하하\" 출력      &lt;--------------- 출력 문자열                           \"내용 : ㅋㅋㅋ\" 출력      &lt;--------------- 출력 문자열                           \"작성자 : 홍길동\" 완료      &lt;--------------- 빈 문자열 사용자 입력 &lt;--------------- !{}! 입력값     ---------------&gt; 작업 수행 출력      &lt;--------------- 출력 문자열 완료      &lt;--------------- \"\" 빈 문자열   07)     Command 인터페이스 변경            클라이언트가 보낸 데이터를 읽을 때 사용할 입력 스트림을 파라미터로 받는다.       void execute(PrintWriter out, BufferedReader in);           prompt 수정            input* 코드들을 오버로딩한다.                    파라미터 수정           클라이언트에게 출력하고 입력을 받도록 코드 수정                                                                       Xxx[Add               Delete               Detail               Update]Command 수정                                               클라이언트 앱도 변경해줘야 한다.                    서버가 입력 값을 요구하면 사용자로부터 읽어서 보낸다.                           private static void receiveResponse(PrintWriter out, BufferedReader in) throws Exception {   while (true) {     String response = in.readLine();     if (response.length() == 0) {       break;     } else if (response.equals(“!{}!”)) {       // 사용자로부터 값을 입력을 받아서 서버에 보낸다.       // !{}!는 출력되면 안되기 때문에 빈 문자를 보낸다.       out.println(Prompt.inputString(“”));       out.flush();     } else {       System.out.println(response);     }       System.out.println(response);   } }           파라미터가 다르더라도 같은 일을 하는 메서드에 대해서 같은 이름을 부여하는 것으로 프로그래밍에 일관성을 제공해 주는 것이 오버로딩이다.   상속받은 메서드가 서브 클래스의 역할에 맞지 않을 때 재정의 하는 것을 오버라이딩이라고 한다.   OOP     캡슐화, 상속, 다형성 + 디자인 패턴, 리팩토링            목표: 소스 코드를 보다 쉽게 관리하는 것                    1) 읽기 쉬워야 한다.           2) 기능 추가, 변경, 삭제할 때 기존 코드를 최소로 손대야 한다.                           ServerApp            Command 패턴 -&gt; 새 명령을 쉽게 추가할 수 있다.       c/s 어플리케이션 아키텍처                    기능 추가를 하더라도 사용자 pc에 프로그램을 재설치 할 필요가 없다.                           08)     디자인 패턴과 c/s 애플리케이션 아키텍처의 유용성을 확인            계산기 클래스를 새로 삽입해서 기존 소스 코드를 최소한으로 손대면서 새 기능을 추가하는 것을 확인한다.           35 서버   01) quit, stop 명령어 처리   35 클라이언트   stateful 을 stateless로 바꾼다.     네이버같은 불특정 다수를 상대로 하는 사이트는 stateless 방식을 사용한다.   게임이나 스트리밍은 statefull 방식을 사용한다.   01) 서버에 연결할 때 한번만 요청/응답하도록 변경한다.     서버에 연결하면 quit 명령을 보낼 때까지 계속 연결되어 있는 기존의 stateful 통신 방법을 서버에 연결했을때 한번만 요청하고 응답하는 stateless 통신 방법으로 변경한다.  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL201015/",
        "teaser": null
      },{
        "title": "mini-pms 34a",
        "excerpt":"Server   01) 간단한 메시지를 송수신 할 수 있도록 한다.   public class ServerApp {   public static void main(String[] args) {      // 8888 포트에서 클라이언트를 기다리는 서버 소켓을 생성한다.     try (ServerSocket serverSocket = new ServerSocket(8888)) {       System.out.println(\"서버 실행 중\");        // 클라이언트가 연결된 소켓을 리턴 받는다.       // 소켓을 통해 문자열 메시지를 입출력 할 수 있도록 스트림 객체를 준비한다.       try (Socket socket = serverSocket.accept();           BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));           PrintWriter out = new PrintWriter(socket.getOutputStream());           ) {          // 클라이언트가 보낸 메시지를 읽고, 다시 클라이언트에게 리턴해준다.         String request = in.readLine();          out.println(request);         out.flush();       }     } catch (Exception e) {       e.printStackTrace();     }   } }   02) 사용자가 quit 명령을 입력할 때까지 반복한다.   public class ServerApp {   public static void main(String[] args) {      try (ServerSocket serverSocket = new ServerSocket(8888)) {       System.out.println(\"서버 실행 중\");        try (Socket socket = serverSocket.accept();           BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));           PrintWriter out = new PrintWriter(socket.getOutputStream());           ) {         // while 문을 사용하여 반복문을 돌려 서버가 종료되지 않도록 한다.         while (true) {           String request = in.readLine();            out.println(request);           out.flush();            // quit 명령어를 입력받으면 종료하게 만든다.           if (request.equalsIgnoreCase(\"quit\")) {             break;           }         }       }     } catch (Exception e) {       e.printStackTrace();     }   } }   03) 응답의 끝에는 빈 줄을 보내도록 응답 프로토콜을 정의한다.   public class ServerApp {   public static void main(String[] args) {      try (ServerSocket serverSocket = new ServerSocket(8888)) {       System.out.println(\"서버 실행 중\");        try (Socket socket = serverSocket.accept();           BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));           PrintWriter out = new PrintWriter(socket.getOutputStream());           ) {          while (true) {           String request = in.readLine();            // 응답 프로토콜을 정의한 메서드를 실행한다.           sendResponse(out, request);            // quit 명령어를 입력받으면 종료하게 만든다.           if (request.equalsIgnoreCase(\"quit\")) {             break;           }         }       }     } catch (Exception e) {       e.printStackTrace();     }   }    // 응답의 끝에는 빈 줄을 보내도록 응답 프로토콜을 정의한다.   private static void sendResponse(PrintWriter out, String message) {     out.println(message);     out.println();     out.flush();   } }   04) 다중 클라이언트 요청 처리 - 접속 순서대로 처리함     클라이언트 요청이 끊어지면 다음 클라이언트와 연결하는 것을 반복한다.   public class ServerApp {   public static void main(String[] args) {      try (ServerSocket serverSocket = new ServerSocket(8888)) {       System.out.println(\"서버 실행 중\");        // 클라이언트의 요청이 있을 때까지 대기하는 것을 반복한다.       while (true) {         handleClient(serverSocket.accept());       }     } catch (Exception e) {       e.printStackTrace();     }   }    private static void sendResponse(PrintWriter out, String message) {     out.println(message);     out.println();     out.flush();   }    // 클라이언트 연결이 끊어지면 다음 클라이언트와 연결하는 것을 반복한다.   private static void handleClient(Socket clientSocket) {     try (Socket socket = clientSocket;         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));         PrintWriter out = new PrintWriter(socket.getOutputStream());         ) {        while (true) {         String request = in.readLine();          sendResponse(out, request);          if (request.equalsIgnoreCase(\"quit\")) {           break;         }       }     } catch (Exception e) {       System.out.println(\"클라이언트와의 통신 오류\");     }   } }      클라이언트가 접속하거나 연결을 끊으면 로그를 남기도록 한다.   public class ServerApp {   public static void main(String[] args) {      try (ServerSocket serverSocket = new ServerSocket(8888)) {       System.out.println(\"서버 실행 중\");        while (true) {         handleClient(serverSocket.accept());       }     } catch (Exception e) {       e.printStackTrace();     }   }    private static void sendResponse(PrintWriter out, String message) {     out.println(message);     out.println();     out.flush();   }    private static void handleClient(Socket clientSocket) {      // 클라이언트가 접속하면 로그를 남긴다.     InetAddress address = clientSocket.getInetAddress();     System.out.printf(\"클라이언트(%s)가 연결되었습니다.\\n\",         address.getHostAddress());      try (Socket socket = clientSocket;         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));         PrintWriter out = new PrintWriter(socket.getOutputStream());         ) {        while (true) {         String request = in.readLine();          sendResponse(out, request);          if (request.equalsIgnoreCase(\"quit\")) {           break;         }       }     } catch (Exception e) {       System.out.println(\"클라이언트와의 통신 오류\");     }      // 클라이언트가 연결을 끊으면 로그를 남긴다.     System.out.printf(\"클라이언트(%s)와의 연결을 끊었습니다.\\n\",         address.getHostAddress());   } }   05) 다중 클라이언트의 동시 접속 처리     클라이언트의 요청 처리를 별도의 스레드로 분리한다.            ClientHandler 클래스 추가                    Runnable 인터페이스를 구현한다.           클라이언트의 요청 처리를 담당한다.           ServerApp 에서 해당 코드를 가져온다.                       ServerApp 클래스 변경                    클라이언트 요청 처리를 ClientHandler에게 맡긴다.                           // 클라이언트 요청을 처리하는 일을 한다. public class ClientHandler implements Runnable {   Socket socket;    // ClientHandler의 내장 변수 socket에 클라이언트가 접속한 소켓을 저장한다.   public ClientHandler(Socket socket) {     this.socket = socket;   }    @Override   public void run() {     InetAddress address = this.socket.getInetAddress();     System.out.printf(\"클라이언트(%s)가 연결되었습니다.\\n\",         address.getHostAddress());      // this.socket으로 하면 try 문을 떠날 때 close(); 가 자동으로 호출된다.     try (Socket socket = this.socket;         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));         PrintWriter out = new PrintWriter(socket.getOutputStream());         ) {        while (true) {         String request = in.readLine();          sendResponse(out, request);          if (request.equalsIgnoreCase(\"quit\")) {           break;         }       }     } catch (Exception e) {       System.out.println(\"클라이언트와의 통신 오류\");     }      System.out.printf(\"클라이언트(%s)와의 연결을 끊었습니다.\\n\",         address.getHostAddress());   }    private static void sendResponse(PrintWriter out, String message) {     out.println(message);     out.println();     out.flush();   } }      다중 클라이언트의 동시 접속을 처리한다.   public class ServerApp {   public static void main(String[] args) {      try (ServerSocket serverSocket = new ServerSocket(8888)) {       System.out.println(\"서버 실행 중\");        // 스레드를 생성해서 메인 스레드와 클라이언트의 요청을 수행하는       // 클라이언트 핸들러 스레드를 분리해서 실행한다.       // 이렇게 하면 클라이언트가 접속할 때마다       // 새로운 스레드를 실행하기 때문에 다중 클라이언트의 동시 접속을 처리할 수 있다.       while (true) {         //        ClientHandler clientHandler = new ClientHandler(serverSocket.accept());         //        Thread t = new Thread(clientHandler);         //        t.start();         new Thread(new ClientHandler(serverSocket.accept())).start();        }     } catch (Exception e) {       e.printStackTrace();     }   } }      ClientHandler 클래스를 중첩 클래스로 만든다.   public class ServerApp {   public static void main(String[] args) {      try (ServerSocket serverSocket = new ServerSocket(8888)) {       System.out.println(\"서버 실행 중\");        while (true) {         new Thread(new ClientHandler(serverSocket.accept())).start();       }     } catch (Exception e) {       e.printStackTrace();     }   }    // ClientHandler 클래스를 ServerApp의 스태틱 중첩 클래스로 선언한다.   // 다른 클래스가 사용할 일이 없기 때문에 private로 선언한다.   // 바깥 클래스의 특정 인스턴스 멤버를 사용할 일이 없기 때문에   // static nested class로 선언한다.   private static class ClientHandler implements Runnable {     Socket socket;      public ClientHandler(Socket socket) {       this.socket = socket;     }      @Override     public void run() {       InetAddress address = this.socket.getInetAddress();       System.out.printf(\"클라이언트(%s)가 연결되었습니다.\\n\",           address.getHostAddress());        try (Socket socket = this.socket;           BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));           PrintWriter out = new PrintWriter(socket.getOutputStream());           ) {          while (true) {           String request = in.readLine();            sendResponse(out, request);            if (request.equalsIgnoreCase(\"quit\")) {             break;           }         }       } catch (Exception e) {         System.out.println(\"클라이언트와의 통신 오류\");       }        System.out.printf(\"클라이언트(%s)와의 연결을 끊었습니다.\\n\",           address.getHostAddress());     }      private static void sendResponse(PrintWriter out, String message) {       out.println(message);       out.println();       out.flush();     }   } }      익명 클래스로 만든다.            상속 + 내부 클래스       클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고 오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다.       재사용을 안할 것 같은 클래스를 익명 클래스로 만든다.           public class ServerApp {   public static void main(String[] args) {      try (ServerSocket serverSocket = new ServerSocket(8888)) {       System.out.println(\"서버 실행 중\");        while (true) {         Socket clientSocket = serverSocket.accept();          // 익명 클래스 문법 사용         new Thread(new Runnable() {           @Override           public void run() {             InetAddress address = clientSocket.getInetAddress();             System.out.printf(\"클라이언트(%s)가 연결되었습니다.\\n\",                 address.getHostAddress());              try (Socket socket = clientSocket;                 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));                 PrintWriter out = new PrintWriter(socket.getOutputStream());                 ) {                while (true) {                 String request = in.readLine();                  sendResponse(out, request);                  if (request.equalsIgnoreCase(\"quit\")) {                   break;                 }               }             } catch (Exception e) {               System.out.println(\"클라이언트와의 통신 오류\");             }              System.out.printf(\"클라이언트(%s)와의 연결을 끊었습니다.\\n\",                 address.getHostAddress());           }            private void sendResponse(PrintWriter out, String message) {             out.println(message);             out.println();             out.flush();           }         }).start();         new Thread(new ClientHandler(serverSocket.accept())).start();       }     } catch (Exception e) {       e.printStackTrace();     }   } }      익명 클래스를 람다 문법으로 정의한다.            코드가 여러 블록에 중첩되면 될수록 들여쓰기를 하면서 코드를 읽기가 불편해진다.       익명 클래스의 코드를 바깥 클래스의 멤버로 만든 후 그 바깥 클래스의 멤버를 호출한다.       만약 익명 클래스가 메서드 한개짜리 인터페이스를 구현하고 그 코드도 간단하다면 람다 문법을 사용하면 간편하게 할 수 있다.           public class ServerApp {   public static void main(String[] args) {      try (ServerSocket serverSocket = new ServerSocket(8888)) {       System.out.println(\"서버 실행 중\");        while (true) {         // 익명 클래스의 바깥 클래스의 멤버를 사용         Socket clientSocket = serverSocket.accept();          // 람다 문법 적용         //        new Thread(new Runnable() {         //          @Override         //          public void run() {         //            handleClient(clientSocket);         //          }         //        }).start();         new Thread(() -&gt; handleClient(clientSocket)).start();       }     } catch (Exception e) {       e.printStackTrace();     }   }    private static void handleClient(Socket clientSocket) {     InetAddress address = clientSocket.getInetAddress();     System.out.printf(\"클라이언트(%s)가 연결되었습니다.\\n\",         address.getHostAddress());      try (Socket socket = clientSocket;         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));         PrintWriter out = new PrintWriter(socket.getOutputStream());         ) {        while (true) {         String request = in.readLine();         sendResponse(out, request);         if (request.equalsIgnoreCase(\"quit\")) {           break;         }       }     } catch (Exception e) {       System.out.println(\"클라이언트와의 통신 오류\");     }      System.out.printf(\"클라이언트(%s)와의 연결을 끊었습니다.\\n\",         address.getHostAddress());   }    private static void sendResponse(PrintWriter out, String message) {     out.println(message);     out.println();     out.flush();   } }   Client   01) 간단한 메시지를 송수신 할 수 있도록 한다.   public class ClientApp {   public static void main(String[] args) {     // 서버주소 : localhost     // 서버포트 : 8888     try (Socket socket = new Socket(\"localhost\", 8888);         PrintWriter out = new PrintWriter(socket.getOutputStream());         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {        out.println(\"Hello\");       out.flush();        String response = in.readLine();       System.out.println(response);      } catch (Exception e) {       e.printStackTrace();     }   } }   02) 사용자가 quit 명령을 입력할 때까지 반복한다.     com.eomcs.util 에 Prompt 클래스를 만든다.   public class Prompt {   static Scanner keyboardScan = new Scanner(System.in);    // 다른 패키지에서 메서드를 호출할 수 있도록 사용 범위를 public 으로 공개한다.   public static String inputString(String title) {     System.out.print(title);     return keyboardScan.nextLine();   }    public static int inputInt(String title) {     return Integer.parseInt(inputString(title));   }    public static Date inputDate(String title) {     return Date.valueOf(inputString(title));   }    // 프롬프트의 사용이 모두 끝났으면   // 이 메서드를 호출하여 System.in 입력 스트림 자원을 해제하도록 한다.   public static void close() {     keyboardScan.close();   } }      ClientApp 에서 Prompt 를 사용해 명령을 입력받도록 한다.   public class ClientApp {   public static void main(String[] args) {     try (Socket socket = new Socket(\"localhost\", 8888);         PrintWriter out = new PrintWriter(socket.getOutputStream());         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {        // 명령어를 입력받도록 만든다.       String input = Prompt.inputString(\"명령&gt; \");       out.println(input);       out.flush();        String response = in.readLine();       System.out.println(response);      } catch (Exception e) {       e.printStackTrace();     }   } }      quit 명령어를 입력받으면 종료하게 만든다.   public class ClientApp {   public static void main(String[] args) {     // 서버주소 : localhost     // 서버포트 : 8888     try (Socket socket = new Socket(\"localhost\", 8888);         PrintWriter out = new PrintWriter(socket.getOutputStream());         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {        // quit 명령어를 입력받으면 종료하게 만든다.       while (true) {         String input = Prompt.inputString(\"명령&gt; \");         out.println(input);         out.flush();          String response = in.readLine();         System.out.println(response);          if (input.equalsIgnoreCase(\"quit\")) {           break;         }       }      } catch (Exception e) {       e.printStackTrace();     }   } }   03) 서버가 빈 줄을 보낼 때까지 응답을 읽는다.   public class ClientApp {   public static void main(String[] args) {     // 서버주소 : localhost     // 서버포트 : 8888     try (Socket socket = new Socket(\"localhost\", 8888);         PrintWriter out = new PrintWriter(socket.getOutputStream());         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {        // quit 명령어를 입력받으면 종료하게 만든다.       while (true) {         String input = Prompt.inputString(\"명령&gt; \");         out.println(input);         out.flush();          // 응답을 읽는 메서드를 호출한다.         receiveResponse(in);          if (input.equalsIgnoreCase(\"quit\")) {           break;         }       }      } catch (Exception e) {       e.printStackTrace();     }   }    // 서버가 빈 줄을 보낼 때까지 응답을 읽는 메서드를 정의한다.   private static void receiveResponse(BufferedReader in) throws Exception {     while (true) {       String response = in.readLine();       if (response.length() == 0) {         break;       }       System.out.println(response);     }   } }   04) 다중 클라이언트 요청 처리 - 접속 순서대로 서버에서 리턴받음     애플리케이션 아규먼트를 통해 서버의 주소와 포트 번호를 입력 받는다.   다른 서버에 접속하기 위해서 주소와 포트 번호를 알아야 한다.   public class ClientApp {   public static void main(String[] args) {      // 애플리케이션 아규먼트를 통해 서버의 주소와 포트 번호를 입력 받는다.     if (args.length != 2) {       System.out.println(\"프로그램 사용법\");       System.out.println(\"java -cp ... ClientApp 서버주소 포트번호\");       // JVM 강제 종료 - 정상종료       // 비정상 종료일 때는 종료 상태값이 1이 된다.       System.exit(0);     }      try (Socket socket = new Socket(\"localhost\", 8888);         PrintWriter out = new PrintWriter(socket.getOutputStream());         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {        while (true) {         String input = Prompt.inputString(\"명령&gt; \");         out.println(input);         out.flush();          receiveResponse(in);          if (input.equalsIgnoreCase(\"quit\")) {           break;         }       }      } catch (Exception e) {       e.printStackTrace();     }   }    private static void receiveResponse(BufferedReader in) throws Exception {     while (true) {       String response = in.readLine();       if (response.length() == 0) {         break;       }       System.out.println(response);     }   } }   05) 04와 동일   ","categories": ["pms"],
        "tags": [],
        "url": "http://localhost:4000/pms/mini-pms-34/",
        "teaser": null
      },{
        "title": "2020-10-16 TIL",
        "excerpt":"스레드풀   스레드풀     스테이스리스는 요청이 들어와서 스레드를 만들 때마다 가비지가 생성된다.            이 방식의 문제점을 해결하기 위한 것이 스레드 풀이다.           스레드를 미리 만들어 놓고 사용하는 것   프로그램의 성능 저하를 방지한다.            매번 발생되는 작업을 병렬 처리하기 위해 스레드를 생성하고 수거하는데 따르는 부담이 프로그램의 전체적인 퍼포먼스를 저하시킬 수 있다.       다수의 사용자의 요청을 수용하고 빠르게 처리하고 대응할 수 있다.           pooling 기법을 사용한다            = Flywieght 디자인 패턴           cross reference 문제 주의            MyThread와 MyThreadPool 이 상호 참조 관계일 때       상호 참조를 하면 서로 변화가 있을 때마다 컴파일을 하기 때문에 무한 컴파일을 하게 된다.       현재 컴파일러는 성능이 좋기 때문에 한번만 컴파일을 하지만 객체 지향에서는 사용하지 않는 것이 좋은 방식이다.       이 문제점을 해결하기 위해서 ThreadPool을 만들어 MyThreadPool이 ThreadPool을 구현하도록 하고 MyThread는 ThreadPool을 사용하도록 한다.       이렇게 하면 상호 참조 관계를 해소할 수 있다.           자바로 만든 스레드는 전부 이 방식으로 돌아간다.   // 멀티 스레드 재사용 - Pooling 기법을 이용하여 생성된 객체를 재활용하기 package com.eomcs.concurrent.ex6;  import java.util.ArrayList; import java.util.Scanner;  public class Exam0210 {    static class MyThread extends Thread {     ThreadPool pool;     int count;      public MyThread(String name, ThreadPool pool) {       super(name);       this.pool = pool;     }      public void setCount(int count) {       // 객체에 줄 값을 설정       this.count = count;       synchronized (this) {         // 객체에 알림을 주는 것         notify();       }     }      @Override     public void run() {       synchronized (this) {         try {           while (true) {             // 작업하라는 알림이 올 때까지 기다린다.             // not runnable 상태             wait();              // 알림이 오면 작업을 실행한다.             for (int i = count; i &gt; 0; i--) {               System.out.printf(\"[%s] %d\\n\", getName(), i);               Thread.sleep(2000);             }              // 작업이 끝났으면 스레드풀로 돌아간다.             pool.add(this);           }         } catch (Exception e) {           e.printStackTrace();         }       }     }   }    // 상호 참조 관계를 해소하기 위해서   // 인터페이스를 준비했다.   interface ThreadPool {     Thread get();      void add(Thread obj);   }    static class MyThreadPool implements ThreadPool {     ArrayList&lt;MyThread&gt; list = new ArrayList&lt;&gt;();      public MyThreadPool() {       // 사용할 스레드 객체를 미리 생성한다.       // - 나중에 MyThread가 Pool로 다시 리턴될 수 있도록       //   스레드 객체를 생성할 때 Pool의 주소를 알려준다.       MyThread t1 = new MyThread(\"1번 스레드=&gt;\", this);       MyThread t2 = new MyThread(\"2번 스레드***&gt;\", this);       MyThread t3 = new MyThread(\"3번 스레드--&gt;\", this);        // 생성된 스레드를 컬렉션에 보관한다.       t1.start();       t2.start();       t3.start();        // 일단 무조건 스레드를 미리 실행해 놓는다.       list.add(t1);       list.add(t2);       list.add(t3);     }      // 스레드 풀에서 한 개의 스레드를 꺼낸다.     // 오버라이딩 할 때 하위 클래스로 바꾸는 것은 OK     // 먹을것 중에 라면을 주는 것     @Override     public MyThread get() {       if (list.size() &gt; 0) { // 컬렉션에 남아있는 스레드가 있다면         return list.remove(0);       }       return null; // 없으면 null을 리턴한다.       // 현재 이 예제에서는 오직 3개의 스레드만 쓰도록 하였다.     }      // 스레드를 다 쓴 후에는 다시 스레드 풀에 돌려준다.     @Override     public void add(Thread t) {       list.add((MyThread) t);     }   }    public static void main(String[] args) {      // 스레드풀 준비!     MyThreadPool threadPool = new MyThreadPool();      Scanner keyScan = new Scanner(System.in);      while (true) {       System.out.print(\"카운트? \");       String str = keyScan.nextLine();       if (str.equals(\"quit\")) {         break;       }        int count = Integer.parseInt(str);        // 스레드풀에서 스레드를 한 개 꺼낸다.       MyThread t = threadPool.get();       if (t == null) {         System.out.println(\"남는 스레드가 없습니다!\");         continue;       }        // 스레드의 카운트를 설정한다. 그러면 카운트를 시작할 것이다.       t.setCount(count);     }      System.out.println(\"main 스레드 종료!\");     keyScan.close();   } }   이클립스에서 실행이 안될 때(Could not find of load)     빈 파일에서 컴파일 된 것이 있는지 확인   클린하고 재컴파일   그레이들 클린이클립스   그레이들 이클립스   시스템 개발     요구사항 수집            기존 시스템 분석 / 업무 분석       UI prototype 제작           요구사항 분석            1) who?                    actor -&gt; 시스템을 사용하는 사람 (예 : 은행원, 고객) / 프로세스 (예 : 타이머, 다른 시스템, ATM)                            Primary Actor -&gt; 시스템을 사용               Secondary Actor(Supplementery Actor) -&gt; 시스템이 사용하는 외부 시스템               회원 -&gt; sns 통합 조회 앱 -&gt; 유튜브, 구글지도(외부 시스템)               회원이 primary, 외부 시스템이 secondary                                   actor diagram                            Primary Actor                                    사용자                                            일반 회원                                                    카페지기                                                                       관리자                                                           타이머                   atm기기                                               Secondary Actor                                    구글 지도                   네이버                   페이스북                   기상청                   다음 우편번호                                                                   액터를 식별하는 것을 identify 한다고 한다.                           ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL201016/",
        "teaser": null
      },{
        "title": "mini-pms 34g",
        "excerpt":"PMS 코드를 C/S로 분리   Server   01) json 데이터 포맷을 다룰 Gson 라이브러리를 추가한다.     build.gradle 파일에 gson 라이브러리 정보를 추가한다.            $ gradle eclipse 를 실행하여 라이브러리를 프로젝트에 추가한다.       이클립스 IDE에서 프로젝트를 refresh 한다.           plugins {     id 'java'     id 'application'     id 'eclipse' } repositories {     jcenter()  dependencies {     //json     implementation 'com.google.code.gson:gson:2.8.6'     implementation 'com.google.guava:guava:29.0-jre'     testImplementation 'junit:junit:4.13' } application {     mainClassName = 'com.eomcs.pms.ServerApp' }   02) 기존 애플리케이션에서 관련된 패키지 및 클래스를 가져온다.     serverApp을 코드에 맞춰 고친다.   public class ServerApp {    // 옵저버에 관련된 코드를 가져온다.   //옵저버와 공유할 맵 객체   Map&lt;String,Object&gt; context = new Hashtable&lt;&gt;();    // 옵저버를 보관할 컬렉션 객체   List&lt;ApplicationContextListener&gt; listeners = new ArrayList&lt;&gt;();    // 옵저버를 등록하는 메서드   public void addApplicationContextListener(ApplicationContextListener listener) {     listeners.add(listener);   }    // 옵저버를 제거하는 메서드   public void removeApplicationContextListener(ApplicationContextListener listener) {     listeners.remove(listener);   }    // service() 실행 전에 옵저버에게 통지한다.   private void notifyApplicationContextListenerOnServiceStarted() {     for (ApplicationContextListener listener : listeners) {       listener.contextInitialized(context);     }   }    // service() 실행 후에 옵저버에게 통지한다.   private void notifyApplicationContextListenerOnServiceStopped() {     for (ApplicationContextListener listener : listeners) {       // 서비스가 종료되었으니 마무리 작업하라고,       // 마무리 작업에 관심있는 각 옵저버에게 통지한다.       // =&gt; 옵저버에게 맵 객체를 넘겨준다.       // =&gt; 옵저버는 작업 결과를 파라미터로 넘겨준 맵 객체에 담아 줄 것이다.       listener.contextDestroyed(context);     }   }    // 지정된 포트를 파라미터로 받는다.   private void service(int port) {      // 서비스가 시작되기 전에 옵저버에게 통지하는 코드를 추가한다.     notifyApplicationContextListenerOnServiceStarted();      try (ServerSocket serverSocket = new ServerSocket(port)) {       System.out.println(\"서버 실행 중\");        while (true) {         Socket clientSocket = serverSocket.accept();          // 람다 문법 적용         new Thread(() -&gt; handleClient(clientSocket)).start();       }     } catch (Exception e) {       e.printStackTrace();     }      // 서비스가 끝났을 때 옵저버에게 통지하는 코드를 추가한다.     notifyApplicationContextListenerOnServiceStopped();   }    public static void main(String[] args) {      ServerApp serverApp = new ServerApp();      // 옵저버 등록     serverApp.addApplicationContextListener(new AppInitListener());     serverApp.addApplicationContextListener(new DataHandlerListener());      // 지정된 포트를 파라미터로 받는다.     serverApp.service(8888);    }    private static void handleClient(Socket clientSocket) {     InetAddress address = clientSocket.getInetAddress();     System.out.printf(\"클라이언트(%s)가 연결되었습니다.\\n\",         address.getHostAddress());      try (Socket socket = clientSocket;         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));         PrintWriter out = new PrintWriter(socket.getOutputStream());         ) {        while (true) {         String request = in.readLine();         sendResponse(out, request);         if (request.equalsIgnoreCase(\"quit\")) {           break;         }       }     } catch (Exception e) {       System.out.println(\"클라이언트와의 통신 오류\");     }      System.out.printf(\"클라이언트(%s)와의 연결을 끊었습니다.\\n\",         address.getHostAddress());   }    private static void sendResponse(PrintWriter out, String message) {     out.println(message);     out.println();     out.flush();   } }   03) 클라이언트의 stop 명령어를 처리한다.     ServerApp 변경   public class ServerApp {    // 클라이언트가 \"stop\" 명령을 보내면 이 값이 true로 변경된다.   // - 이 값이 true 이면 다음 클라이언트가 접속할 때 서버를 종료한다.   static boolean stop = false;    // 다른 클래스에서도 사용해야 하기 때문에 context를 static으로 바꾼다.   static Map&lt;String,Object&gt; context = new Hashtable&lt;&gt;();    List&lt;ApplicationContextListener&gt; listeners = new ArrayList&lt;&gt;();    public void addApplicationContextListener(ApplicationContextListener listener) {     listeners.add(listener);   }    public void removeApplicationContextListener(ApplicationContextListener listener) {     listeners.remove(listener);   }    private void notifyApplicationContextListenerOnServiceStarted() {     for (ApplicationContextListener listener : listeners) {       listener.contextInitialized(context);     }   }    private void notifyApplicationContextListenerOnServiceStopped() {     for (ApplicationContextListener listener : listeners) {       listener.contextDestroyed(context);     }   }    private void service(int port) {      notifyApplicationContextListenerOnServiceStarted();      try (ServerSocket serverSocket = new ServerSocket(port)) {       System.out.println(\"서버 실행 중\");        while (true) {         Socket clientSocket = serverSocket.accept();          new Thread(() -&gt; handleClient(clientSocket)).start();       }     } catch (Exception e) {       e.printStackTrace();     }      notifyApplicationContextListenerOnServiceStopped();   }    public static void main(String[] args) {      ServerApp serverApp = new ServerApp();      serverApp.service(8888);    }    private static void handleClient(Socket clientSocket) {     InetAddress address = clientSocket.getInetAddress();     System.out.printf(\"클라이언트(%s)가 연결되었습니다.\\n\",         address.getHostAddress());      try (Socket socket = clientSocket;         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));         PrintWriter out = new PrintWriter(socket.getOutputStream());         ) {        while (true) {         String request = in.readLine();          // stop 명령어를 처리하도록 코드를 변경한다.         if (request.equalsIgnoreCase(\"quit\")) {           out.println(\"안녕\");           out.println();           out.flush();           break;         } else if (request.equalsIgnoreCase(\"stop\")) {           stop = true;           out.println(\"서버를 종료하는 중입니다.\");           out.println();           out.flush();           break;         }          Command command = (Command) context.get(request);         if (command != null) {           command.execute();         } else {           out.println(\"해당 명령을 처리할 수 없습니다.\");         }          // 응답의 끝을 알리는 빈 문자열을 보낸다.         out.println();         out.flush();        }     } catch (Exception e) {       System.out.println(\"클라이언트와의 통신 오류\");     }      System.out.printf(\"클라이언트(%s)와의 연결을 끊었습니다.\\n\",         address.getHostAddress());   }      private static void sendResponse(PrintWriter out, String message) {       out.println(message);       out.println();       out.flush();     } }   04) 파일에서 JSON 데이터를 로딩하고 파일로 저장하는 옵저버를 등록한다.     ServerApp 변경            AppInitListener 를 등록한다.       DataHandlerListener 를 등록한다.           public class ServerApp { . . .   public static void main(String[] args) {      ServerApp serverApp = new ServerApp();      // AppInitListener와 DataHandlerlistener를 등록한다.     serverApp.addApplicationContextListener(new AppInitListener());     serverApp.addApplicationContextListener(new DataHandlerListener());      serverApp.service(8888);    } . . . }   05) 클라이언트의 요청을 처리하는 Command 객체를 준비한다.     05-01) RequestMappingListener 생성            DataHandlerListener 가 준비한 데이터를 가지고 Command 객체를 생성한다.           // 클라이언트 요청을 처리할 커맨드 객체를 준비한다. public class RequestMappingListener implements ApplicationContextListener {    @SuppressWarnings(\"unchecked\")   @Override   public void contextInitialized(Map&lt;String,Object&gt; context) {     // 옵저버가 작업한 결과를 맵에서 꺼낸다.     List&lt;Board&gt; boardList = (List&lt;Board&gt;) context.get(\"boardList\");     List&lt;Member&gt; memberList = (List&lt;Member&gt;) context.get(\"memberList\");     List&lt;Project&gt; projectList = (List&lt;Project&gt;) context.get(\"projectList\");     List&lt;Task&gt; taskList = (List&lt;Task&gt;) context.get(\"taskList\");      context.put(\"/board/add\", new BoardAddCommand(boardList));     context.put(\"/board/list\", new BoardListCommand(boardList));     context.put(\"/board/detail\", new BoardDetailCommand(boardList));     context.put(\"/board/update\", new BoardUpdateCommand(boardList));     context.put(\"/board/delete\", new BoardDeleteCommand(boardList));      MemberListCommand memberListCommand = new MemberListCommand(memberList);     context.put(\"/member/add\", new MemberAddCommand(memberList));     context.put(\"/member/list\", memberListCommand);     context.put(\"/member/detail\", new MemberDetailCommand(memberList));     context.put(\"/member/update\", new MemberUpdateCommand(memberList));     context.put(\"/member/delete\", new MemberDeleteCommand(memberList));      context.put(\"/project/add\", new ProjectAddCommand(projectList, memberListCommand));     context.put(\"/project/list\", new ProjectListCommand(projectList));     context.put(\"/project/detail\", new ProjectDetailCommand(projectList));     context.put(\"/project/update\", new ProjectUpdateCommand(projectList, memberListCommand));     context.put(\"/project/delete\", new ProjectDeleteCommand(projectList));      context.put(\"/task/add\", new TaskAddCommand(taskList, memberListCommand));     context.put(\"/task/list\", new TaskListCommand(taskList));     context.put(\"/task/detail\", new TaskDetailCommand(taskList));     context.put(\"/task/update\", new TaskUpdateCommand(taskList, memberListCommand));     context.put(\"/task/delete\", new TaskDeleteCommand(taskList));      context.put(\"/hello\", new HelloCommand());   }    @Override   public void contextDestroyed(Map&lt;String,Object&gt; context) {   } }      05-02) ServerApp 에 RequestMappingListener 를 등록한다.   public class ServerApp { . . .    public static void main(String[] args) {      ServerApp serverApp = new ServerApp();      serverApp.addApplicationContextListener(new AppInitListener());     serverApp.addApplicationContextListener(new DataHandlerListener());     // RequestMappingListener를 등록한다.     serverApp.addApplicationContextListener(new RequestMappingListener());      serverApp.service(8888);    } . . . }   06) 클라이언트 명령이 들어오면 커맨드 객체를 찾아 실행하고 클라이언트에게 입력 값을 요구할 수 있도록 프로토콜을 변경한다.     06-01) Command 객체가 클라이언트에게 응답할 수 있도록 출력 스트림 객체를 넘겨주고 입력 값을 읽을 수 있도록 파라미터에 입력 스트림을 추가한다.            Command 클래스 변경           // 사용자의 명령을 처리하는 객체에 대해 호출할 메서드 규칙을 정의 한다. public interface Command {    // 클라이언트에게 응답할 때 사용할 출력 스트림을 파리미터로 받는다.   // 클라이언트가 보낸 데이터를 읽을 때 사용할 입력 스트림을 파라미터로 받는다.   void execute(PrintWriter out, BufferedReader in); }      06-02) Command 인터페이스 변경에 따라 execute() 메서드의 코드를 수정한다.            ServerApp 클래스 변경       XxxListCommand 클래스들 변경           public class ServerApp { . . .  private static void handleClient(Socket clientSocket) {     InetAddress address = clientSocket.getInetAddress();     System.out.printf(\"클라이언트(%s)가 연결되었습니다.\\n\",         address.getHostAddress());      try (Socket socket = clientSocket;         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));         PrintWriter out = new PrintWriter(socket.getOutputStream());         ) {        while (true) {         String request = in.readLine();          if (request.equalsIgnoreCase(\"quit\")) {           out.println(\"안녕\");           out.println();           out.flush();           break;         } else if (request.equalsIgnoreCase(\"stop\")) {           stop = true;           out.println(\"서버를 종료하는 중입니다.\");           out.println();           out.flush();           break;         }          Command command = (Command) context.get(request);         if (command != null) {           // execute에 파라미터를 받는다.           command.execute(out, in);         } else {           out.println(\"해당 명령을 처리할 수 없습니다.\");         }          out.println();         out.flush();        }     } catch (Exception e) {       System.out.println(\"클라이언트와의 통신 오류\");     }      System.out.printf(\"클라이언트(%s)와의 연결을 끊었습니다.\\n\",         address.getHostAddress());   } }      06-03) Prompt 클래스 변경            파라미터로 받은 출력 스트림으로 프롬프트 제목을 출력하고 파라미터로 받은 입력 스트림에서 값을 읽어 리턴하는 메서드를 추가한다.           public class Prompt {   static Scanner keyboardScan = new Scanner(System.in);    // 다른 패키지에서 메서드를 호출할 수 있도록 사용 범위를 public 으로 공개한다.   public static String inputString(String title) {     System.out.print(title);     return keyboardScan.nextLine();   }    public static String inputString(       String title,       PrintWriter out,       BufferedReader in) throws Exception {     // 클라이언트로 출력할 때는 제목 다음에 \"!{}!\" 문자열을 보내     // 클라이언트가 사용자로부터 값을 입력받아 다시 서버에 보내도록 요청한다.     out.print(title); // 클라이언트가 출력할 프롬프트 제목     out.println(\"!{}!\"); // 클라이언트에게 값을 보내라는 요청     out.flush(); // 주의! 출력하면 버퍼에 쌓이기 때문에 flush()를 호출해서 서버로 보낸다.     return in.readLine(); // 클라이언트가 보낸 값을 읽기    }    public static int inputInt(String title) {     return Integer.parseInt(inputString(title));   }    public static int inputInt(       String title,       PrintWriter out,       BufferedReader in) throws Exception {     return Integer.parseInt(inputString(title, out, in));   }    public static Date inputDate(String title) {     return Date.valueOf(inputString(title));   }    public static Date inputDate(       String title,       PrintWriter out,       BufferedReader in) throws Exception {     return Date.valueOf(inputString(title, out ,in));   }    // 프롬프트의 사용이 모두 끝났으면   // 이 메서드를 호출하여 System.in 입력 스트림 자원을 해제하도록 한다.   public static void close() {     keyboardScan.close();   } }      06-04) Xxx[Add, Detail, Update, Delete]Command 구현체 변경            Command 인터페이스 변경에 따라 execute() 메서드의 코드를 수정한다.                    System.out.println 은 out.println으로 변경           그 외의 prompt를 사용하는 등의 것은 out, in을 추가한다.           예외가 발생하는 경우에는 try-catch 를 사용한다.                           Client   01) 서버에 stop 명령을 보내면 클라이언트를 종료하게 만든다.   public class ClientApp {   public static void main(String[] args) {     if (args.length != 2) {       System.out.println(\"프로그램 사용법\");       System.out.println(\"java -cp ... ClientApp 서버주소 포트번호\");       System.exit(0);     }      // 클라이언트가 서버에 stop 명령을 보내면 다음 변수를 true로 변경한다.     boolean stop = false;      try (Socket socket = new Socket(\"localhost\", 8888);         PrintWriter out = new PrintWriter(socket.getOutputStream());         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {        while (true) {         String input = Prompt.inputString(\"명령&gt; \");         out.println(input);         out.flush();          receiveResponse(in);          if (input.equalsIgnoreCase(\"quit\")) {           break;           // 클라이언트가 서버에 stop 명령을 보내면 다음 변수를 true로 변경한다.         } else if (input.equalsIgnoreCase(\"stop\")) {           stop = true;           break;         }       }     } catch (Exception e) {       e.printStackTrace();     }      if (stop) {       // 서버를 멈추기 위해 그냥 접속했다가 끊는다.       try (Socket socket = new Socket(args[0], Integer.parseInt(args[1]))) {         // 아무것도 안한다.         // 서버가 stop 하게 만들기 위해서 접속했다가 끊을 뿐이다.       } catch (Exception e) {         // 아무것도 안한다.       }     }   }    private static void receiveResponse(BufferedReader in) throws Exception {     while (true) {       String response = in.readLine();       if (response.length() == 0) {         break;       }       System.out.println(response);     }   } }   02) 서버가 입력 값을 요구하면 사용자로부터 입력 값을 받아 보낸다.   public class ClientApp {   public static void main(String[] args) {     if (args.length != 2) {       System.out.println(\"프로그램 사용법\");       System.out.println(\"java -cp ... ClientApp 서버주소 포트번호\");       System.exit(0);     }      boolean stop = false;      try (Socket socket = new Socket(\"localhost\", 8888);         PrintWriter out = new PrintWriter(socket.getOutputStream());         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {        while (true) {         String input = Prompt.inputString(\"명령&gt; \");         out.println(input);         out.flush();          // 사용자로부터 값을 입력받는 파라미터를 만든다.         receiveResponse(out, in);          if (input.equalsIgnoreCase(\"quit\")) {           break;         } else if (input.equalsIgnoreCase(\"stop\")) {           stop = true;           break;         }       }     } catch (Exception e) {       e.printStackTrace();     }      if (stop) {       try (Socket socket = new Socket(args[0], Integer.parseInt(args[1]))) {       } catch (Exception e) {       }     }   }    // 사용자로부터 값을 입력받는 파라미터를 만든다.   private static void receiveResponse(PrintWriter out, BufferedReader in) throws Exception {     while (true) {       String response = in.readLine();       if (response.length() == 0) {         break;       } else if (response.equals(\"!{}!\")) {         // 사용자로부터 값을 입력받아서 서버에 보낸다.         out.println(Prompt.inputString(\"\"));         out.flush();       } else {         System.out.println(response);       }     }   } }  ","categories": ["pms"],
        "tags": [],
        "url": "http://localhost:4000/pms/mini-pms-34g/",
        "teaser": null
      },{
        "title": "mini-pms 35",
        "excerpt":"Stateful 을 Stateless로 만들기   Server   클라이언트에게 응답하고 나면 연결을 끊는 방식으로 바꾼다.   . . .   private static void handleClient(Socket clientSocket) {     InetAddress address = clientSocket.getInetAddress();     System.out.printf(\"클라이언트(%s)가 연결되었습니다.\\n\",         address.getHostAddress());      try (Socket socket = clientSocket;         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));         PrintWriter out = new PrintWriter(socket.getOutputStream())) {        // 한번만 통신하고 끊기 때문에 while 문으로 반복할 필요가 없다.       // 클라이언트가 보낸 요청을 읽는다.       String request = in.readLine();        // quit이 필요없기 때문에 삭제한다.       //        if (request.equalsIgnoreCase(\"quit\")) {       //          out.println(\"안녕!\");       //          out.println();       //          out.flush();       //          break;       //        } else        if (request.equalsIgnoreCase(\"stop\")) {         stop = true;         out.println(\"서버를 종료하는 중입니다!\");         out.println();         out.flush();         return;       }        Command command = (Command) context.get(request);       if (command != null) {         command.execute(out, in);       } else {         out.println(\"해당 명령을 처리할 수 없습니다!\");       }        out.println();       out.flush();       } catch (Exception e) {       System.out.println(\"클라이언트와의 통신 오류!\");     }      System.out.printf(\"클라이언트(%s)와의 연결을 끊었습니다.\\n\",         address.getHostAddress());   } }   Client   서버에 연결할 때 한 번만 요청/응답하도록 변경한다.   public class ClientApp {    // host 와 port 변수를 준비한다.   static String host;   static int port;    public static void main(String[] args) {      if (args.length != 2) {       System.out.println(\"프로그램 사용법\");       System.out.println(\"java -cp ... ClientApp 서버주소 포트번호\");       System.exit(0);     }      // host는 args의 0번째에 들어있고 port 번호는 args의 1번째에 들어있다.     host = args[0];     port = Integer.parseInt(args[1]);      // quit 일때 바로 클라이언트를 종료한다.     while (true) {       String input = Prompt.inputString(\"명령&gt; \");       if (input.equalsIgnoreCase(\"quit\")) {         break;       }        // request를 수행한다.       request(input);        // stop 일때 서버를 종료한다.       if (input.equalsIgnoreCase(\"stop\")) {         break;       }     }     System.out.println(\"안녕!\");    }     // request를 수행하는 메서드   private static void request(String message) {     // stop의 값을 false로 설정해 둔다.     boolean stop = false;      // socket을 통해 서버와 통신한다.     try (Socket socket = new Socket(\"localhost\", 8888);         PrintWriter out = new PrintWriter(socket.getOutputStream());         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {        // 메시지를 보낸다.       out.println(message);       out.flush();        // 서버의 리턴을 받는다.       receiveResponse(out, in);        // 만약 메시지가 stop 이라면 stop의 불린 값을 true로 바꾼다.       if (message.equalsIgnoreCase(\"stop\")) {         stop = true;       }     } catch (Exception e) {       e.printStackTrace();     }      // 만약 stop이 참이라면 서버에 한 번 접속했다가 끊는다.     if (stop) {       try (Socket socket = new Socket(host, port)) {       } catch (Exception e) {       }     }   }    // 사용자로부터 값을 입력받는 파라미터를 만든다.   private static void receiveResponse(PrintWriter out, BufferedReader in) throws Exception {     while (true) {       String response = in.readLine();       if (response.length() == 0) {         break;       } else if (response.equals(\"!{}!\")) {         // 사용자로부터 값을 입력받아서 서버에 보낸다.         out.println(Prompt.inputString(\"\"));         out.flush();       } else {         System.out.println(response);       }     }   } }  ","categories": ["pms"],
        "tags": [],
        "url": "http://localhost:4000/pms/mini-pms-35/",
        "teaser": null
      },{
        "title": "2020-10-19 TIL",
        "excerpt":"요구사항 분석   Use-case (what)     사용 사례   액터가 시스템을 사용하여 달성하려는 업무 목표   use-case identity (식별방법)            적정크기 (2주~6주) : RUP 개발 프로세스 &lt;-&gt; 에자일 개발 방법론(1시간~1일)                    개발 단위 : 분석 -&gt; 설계 -&gt; 구현 -&gt; 테스트                       (개발할) 시스템을 사용해서 처리하는 업무       한 사람이 한 번에 한 순간에 수행하는 업무                    예) 메일 보내는 일                            메일 임시 보관하기               메일 보내기                                               카운트가 가능(업무의 시작과 끝이 명확)한 단위로 업무를 쪼갠다.           특별한 예            업무가 아닌데도 use-case로 식별하는 경우                    여러 use-case의 공통 시나리오 일 때                            게시글 등록, 변경, 삭제 : 로그인 &lt;- 업무는 아니다 : 다른 use-case 들의 관리를 쉽게하기 위해 따로 추출한다 -&gt; 개발 편의성                                                   use-case 통합            CRUD 게시글 관리ㄴ                    게시글 등록 Create           게시글 조회 Read / Retreive           게시글 변경 Update           게시글 삭제 Delete                            서로 관련된 업무인 경우 업무의 편의성을 위해 한개의 use-case로 합치기도 한다.                                    XxxManage, XxxHandler, XxxService                   단, 합친 use-case는 2주에서 6주 범위에서 개발 가능해야 한다.                                                                                   use-case diagram            actor -&gt; use-case -&gt; secondary actor                    비회원 -&gt; 회원 가입하기(join member) -&gt; 카카오 주소검색 서비스                           use-case diagram 2            비회원 -&gt; 회원가입 —&gt;(include) 주소검색(유스케이스로 뽑음) -&gt; 카카오 주소검색                    실행흐름                            회원가입 - 주소검색 - 끝 (주소 검색을 하지 않고 끝으로 가는 방법은 없는 경우 : Include)                                   회원가입(주소 검색을 클릭) &lt;— (extend : 선택사항) 주소검색 -&gt; 카카오 주소검색                            회원가입 - 끝               회원가입 주소검색 - 주소검색 - 끝                                                   use-case 예)            회원                    -&gt; 프로젝트 관리           -&gt; 작업 관리           -&gt; 게시글 관리           -&gt; 회원 탈퇴                       관리자                    -&gt; 회원관리           회원가입 &lt;- 비회원           로그인 &lt;- 비회원                           개발방법론 - RUP     래셔널 통합 프로세스   Rational Unified Process   소프트웨어 개발 과정에서 누가, 언제, 어떻게, 무엇을 수행해야 하는가를 기술한다.            작업자(Workers) : ‘누가(who)’에 해당       액티비티(Activities) : ‘어떻게(how)’에 해당       산출물(Artifacts) : ‘무엇을(what)’에 해당       웍플로우(Workflows) : ‘언제(when)’에 해당           스레드풀   ExcutorService     1) Runnable을 상속하는 클래스를 만들어서 run() 메서드에서 별도의 스레드로 독립적으로 실행해야 하는 일을 정의한다.   2) execute()를 호출하면   3) ExecutorService가 스레드를 생성한다.   4) 스레드가 클래스를 실행한다.   public class Exam0110 {     public static void main(String[] args) {       // 스레드풀을 생성한다.       // - 최대 3개의 스레드를 생성한다.       ExecutorService executorService = Executors.newFixedThreadPool(3);          // 스레드풀에 작업 수행을 요청한다.       // - 작업은 Runnable 구현체로 작성하여 넘겨준다.(람다 문법 사용)       // - 스레드풀은 스레드를 생성하여 작업을 수행시킨다.        //    class X implements Runnable {     //      @Override     //      public void run() {     //        System.out.printf(\"%s 스레드 실행\", Thread.currentThread().getName());     //      }     //    }      //    new Runnable() {     //      @Override     //      public void run() {     //        System.out.printf(\"%s 스레드 실행\", Thread.currentThread().getName());     //      }     //    };      //    Runnable obj = new Runnable() {     //      @Override     //      public void run() {     //        System.out.printf(\"%s 스레드 실행\", Thread.currentThread().getName());     //      }     //    };     //     //    threadPool.execute(obj);      threadPool.execute(() -&gt;     System.out.printf(\"%s 스레드 실행\", Thread.currentThread().getName()));      System.out.println(\"main() 종료\");          System.out.println(\"main() 종료!\");       // JVM은 main 스레드가 종료하더라도 나머지 스레드가 종료할 때까지 기다린다.       // 스레드풀에서 생성한 스레드가 요청한 작업을 마치더라도       // 다음 작업을 수행하기 위해 계속 실행된 채로 대기하고 있기 때문에       // JVM은 종료하지 않는다.     } }   ExecutorExcutorService - 스레드풀 종료     jvm 종료   public class Exam0120 {    public static void main(String[] args) {     ExecutorService executorService = Executors.newFixedThreadPool(3);     executorService.execute(() -&gt; System.out.printf(\"%s - Hello!\\n\",         Thread.currentThread().getName()));      // 스레드풀에 있는 모든 스레드들이 요청한 작업을 끝내면 종료하게 한다.     // 모든 스레드가 종료될 때까지 기다리지 않고 바로 리턴한다.     // shutdown() 호출 이후에는 새 작업 요청을 받지 않는다.     // 즉 execute()를 호출하면 예외가 발생한다.     executorService.shutdown();      System.out.println(\"main() 종료!\");   } }   고정 크기 스레드풀 - newFixedThreadPool(숫자)   public class Exam0210 {     static class MyRunnable implements Runnable {       int millisec;          public MyRunnable(int millisec) {         this.millisec = millisec;       }          @Override       public void run() {         try {           System.out.printf(\"[%s] 스레드 실행 중...\\n\",               Thread.currentThread().getName());              Thread.sleep(millisec);              System.out.printf(\"[%s] 스레드 종료!\\n\",               Thread.currentThread().getName());         } catch (Exception e) {           System.out.printf(\"[%s] 스레드 실행 중 오류 발생!\\n\", Thread.currentThread().getName());         }       }     }     public static void main(String[] args) {       ExecutorService executorService = Executors.newFixedThreadPool(3);          // 일단 스레드풀의 크기(3개)만큼 작업 수행을 요청한다.       // - 작업은 큐에 등록된 순서대로 보관된다.       // - 스레드풀은 큐에서 작업을 꺼내 스레드에게 일을 시킨다.       //       executorService.execute(new MyRunnable(6000));       executorService.execute(new MyRunnable(3000));       executorService.execute(new MyRunnable(9000));          // 스레드풀의 크기를 초과해서 작업 수행을 요청한다면?       // - 놀고 있는 스레드가 없을 경우,       //   다른 스레드의 작업이 끝날 때까지 작업큐에 대기하고 있는다.       // - 작업을 끝낸 스레드가 생기면 큐에서 작업을 꺼내 실행한다.       //       executorService.execute(new MyRunnable(2000));       executorService.execute(new MyRunnable(4000));          System.out.println(\"main() 종료!\");     } }   가변 크기 스레드풀 - newCachedThreadPool()     문제점 : 한번에 백만명이 접속하면 스레드가 한번에 백만개가 생성된다.   public class Exam0220 { . . .     public static void main(String[] args) throws Exception {          // 스레드의 수를 고정하지 않고 필요할 때마다 스레드를 생성하는 스레드풀이다.       // 물론 작업을 끝낸 스레드는 다시 사용할 수 있도록 pool에 보관한다.       ExecutorService executorService = Executors.newCachedThreadPool();          // 놀고 있는 스레드가 없으면 새 스레드를 생성한다.       //       executorService.execute(new MyRunnable(6000));       executorService.execute(new MyRunnable(3000));       executorService.execute(new MyRunnable(9000));       executorService.execute(new MyRunnable(2000));          // 작업을 끝낸 스레드가 생길 때까지 일부러 기다린다.       //       Thread.sleep(3000);          // 그러면 새 스레드를 생성하지 않고       // 작업을 끝낸 스레드가 요청한 작업을 처리한다.       //       executorService.execute(new MyRunnable(4000));          System.out.println(\"main() 종료!\");     } }   한 개의 스레드를 갖는 스레드풀 - newSingleThreadExecutor()   public class Exam0230 { . . .   public static void main(String[] args) throws Exception {      // 한 개의 스레드만 갖는 스레드풀이다.     ExecutorService executorService = Executors.newSingleThreadExecutor();      // 스레드가 한 개이기 때문에 순차적으로 실행한다.     executorService.execute(new MyRunnable(6000));     executorService.execute(new MyRunnable(3000));     executorService.execute(new MyRunnable(9000));     executorService.execute(new MyRunnable(2000));     executorService.execute(new MyRunnable(4000));      System.out.println(\"main() 종료!\");   } }   작업 실행 : execute() 와 submit()     execute()            리턴 타입이 void       스레드풀에 수행할 작업을 등록한다.       스레드풀은 execute()를 호출한 순서대로 작업큐에 작업을 보관한다.       그리고 놀고 있는 스레드가 있다면, 작업큐에서 작업을 꺼 수행시킨다.       놀고 있는 스레드가 없으면, 새로 스레드를 생성한다.       놀고 있는 스레드가 없으면, 새로 스레드를 생성한다.                    수행한 작업의 종료 여부를 확인할 수 없다.                           submit()            execute()와 같다.                    단 작업의 종료 상태를 확인할 수 있는 Future 객체를 리턴한다.                            리턴 타입이 future                                   특정 작업이 끝날 때까지 기다리고 싶을 때 future를 쓴다.                           public class Exam0320 { . . .  public static void main(String[] args) throws Exception {     ExecutorService executorService = Executors.newFixedThreadPool(3);      Future&lt;?&gt; future1 = executorService.submit(new MyRunnable(2000));     Future&lt;?&gt; future2 = executorService.submit(new MyRunnable(4000));      // Future.get()     // =&gt; 요청한 작업이 완료될 때 까지 기다린다.(pending)     // =&gt; 요청한 작업이 완료되면 null을 리턴한다.          // if 문은 해당 작업이 끝나면 null을 리턴하는 것을 확인시키기 위해 사용하는 것이다.     if (future2.get() == null)       System.out.println(\"두 번째 작업이 끝났음\");      if (future1.get() == null)       System.out.println(\"첫 번째 작업이 끝났음\");      //    future2.get(); // 해당 작업이 끝날 때까지 기다리다가, 끝나 null을 리턴한다.     //    System.out.println(\"두 번째 작업이 끝났음\");     //     //    future1.get(); // // 해당 작업이 끝날 때까지 기다리다가, 끝나 null을 리턴한다.     //    System.out.println(\"첫 번째 작업이 끝났음\");      System.out.println(\"main() 종료!\");   } }   스레드풀 종료 - shutdown()     shutdown을 호출하면 이전에 요청한 작업들이 완료될 때 까지 기다렸다가 스레드풀이 종료된다.   shutdown을 호출한 다음에 작업을 요청하면 예외가 발생된다.   public class Exam0410 { . . .   public static void main(String[] args) {     ExecutorService executorService = Executors.newFixedThreadPool(3);      executorService.execute(new MyRunnable(6000));     executorService.execute(new MyRunnable(2000));     executorService.execute(new MyRunnable(4000));     executorService.execute(new MyRunnable(4000));     executorService.execute(new MyRunnable(4000));     executorService.execute(new MyRunnable(4000));      // 더이상 작업 요청을 받지 말고     // 이전에 요청한 작업들이 완료되면     // 스레드를 종료하도록 예약한다.     executorService.shutdown();      // 작업 요청을 거절한다.     // =&gt; 예외 발생!     executorService.execute(new MyRunnable(4000));      // 위에서 예외가 발생했기 때문에 \"main() 종료\" 는 출력되지 않는다.     System.out.println(\"main() 종료!\");   } }   스레드풀 즉시 종료 - shutdownNow()     실행중인 작업은 즉시 멈추고 대기중인 작업은 리턴한다.   public class Exam0420 { . . .  public static void main(String[] args) {     ExecutorService executorService = Executors.newFixedThreadPool(3);      executorService.execute(new MyRunnable(6000));     executorService.execute(new MyRunnable(2000));     executorService.execute(new MyRunnable(4000));     executorService.execute(new MyRunnable(5000));     executorService.execute(new MyRunnable(6000));     executorService.execute(new MyRunnable(7000));      // 현재 수행 중인 작업들을 모두 멈추도록 지시한다.     // =&gt; 대기 중인 작업들은 취소한다.     // =&gt; 그리고 취소한 작업 목록을 리턴해준다.     List&lt;Runnable&gt; tasks = executorService.shutdownNow();     for (Runnable task : tasks) {       System.out.println(((MyRunnable) task).millisec);     }     // 물론 새 작업 요청도 거절한다.     // =&gt; 예외 발생!     executorService.execute(new MyRunnable(4000));      System.out.println(\"main() 종료!\");   } }   shutdown() vs shutdownNow()     shutdown() : 진행 중인 작업을 완료하고 대기 중인 작업도 완료한 다음 종료.   shutdownNow() : 진행 중인 작업은 즉시 완료하고 대기 중인 작업은 리턴한다.   스레드풀 종료 대기 -  awaitTermination()     지정한 시간이 경과될 때까지 종료되지 않고 기다렸다가 지정된 시간이 지나면 더 이상 기다리지 않고 메인을 종료하고 종료되지 않은 스레드가 마감될 때 까지 기다린다.   public class Exam0510 { . . .  public static void main(String[] args) throws Exception {     ExecutorService executorService = Executors.newFixedThreadPool(3);      executorService.execute(new MyRunnable(6000));     executorService.execute(new MyRunnable(2000));     executorService.execute(new MyRunnable(4000));     executorService.execute(new MyRunnable(3000));      executorService.shutdown();      // 스레드풀의 모든 스레드가 종료되면 즉시 true를 리턴한다.     // 만약 지정된 시간이 경과할 때 까지 종료되지 않았다면     // false를 리턴한다.     if (!executorService.awaitTermination(10, TimeUnit.SECONDS)) {       System.out.println(\"아직 종료 안된 작업이 있다.\");     } else {       System.out.println(\"모든 작업을 종료하였다.\");     }      System.out.println(\"main() 종료!\");   } }      결과     pool-1-thread-1 스레드 실행 중... pool-1-thread-3 스레드 실행 중... pool-1-thread-2 스레드 실행 중... pool-1-thread-2 스레드 종료! pool-1-thread-2 스레드 실행 중... pool-1-thread-3 스레드 종료! pool-1-thread-1 스레드 종료! 아직 종료 안된 작업이 있다. main() 종료! pool-1-thread-2 스레드 종료!       awaitTermination()과 shutdownNow()를 함께 사용했을 때   public class Exam0520 { . . .   public static void main(String[] args) throws Exception {     ExecutorService executorService = Executors.newFixedThreadPool(3);      executorService.execute(new MyRunnable(6000));     executorService.execute(new MyRunnable(2000));     executorService.execute(new MyRunnable(4000));     executorService.execute(new MyRunnable(20000));      executorService.shutdown();      // 스레드풀의 모든 스레드가 종료될 때까지 기다린다.     if (!executorService.awaitTermination(10, TimeUnit.SECONDS)) {       System.out.println(\"아직 종료 안된 작업이 있다.\");       System.out.println(\"남아 있는 작업의 강제 종료를 시도하겠다.\");       // =&gt; 만약 10초가 경과될 때까지 종료되지 않으면,       //    수행 중인 작업을 강제 종료하라고 지시하고,       //    대기 중인 작업은 취소한다.       executorService.shutdownNow();        // 그리고 다시 작업이 종료될 때까지 기다린다.       if (!executorService.awaitTermination(5, TimeUnit.SECONDS)) {         System.out.println(\"스레드풀의 강제 종료를 완료하지 못했다.\");       } else {         System.out.println(\"모든 작업을 강제 종료했다.\");       }      }      System.out.println(\"main() 종료!\");   } }      결과     pool-1-thread-2 스레드 실행 중... pool-1-thread-3 스레드 실행 중... pool-1-thread-1 스레드 실행 중... pool-1-thread-2 스레드 종료! pool-1-thread-2 스레드 실행 중... pool-1-thread-3 스레드 종료! pool-1-thread-1 스레드 종료! 아직 종료 안된 작업이 있다. 남아 있는 작업의 강제 종료를 시도하겠다. pool-1-thread-2 스레드 실행 중 오류 발생! 모든 작업을 강제 종료했다. main() 종료!      ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL2010019/",
        "teaser": null
      },{
        "title": "mini-pms 33a",
        "excerpt":"Observer 패턴 적용   01) App 클래스의 스태틱 멤버(필드와 메서드)를 인스턴트 멤버로 전환한다.   public class App {    public static void main(String[] args) throws Exception {     App01 app = new App01();     app.service();   }    // 스태틱 멤버들이 공유하는 변수가 아니라면 로컬 변수로 만든다.   public void service() throws Exception {     List&lt;Board&gt; boardList = new ArrayList&lt;&gt;();     File boardFile = new File(\"./board.json\");      List&lt;Member&gt; memberList = new LinkedList&lt;&gt;();     File memberFile = new File(\"./member.json\");       List&lt;Project&gt; projectList = new LinkedList&lt;&gt;();     File projectFile = new File(\"./project.json\");       List&lt;Task&gt; taskList = new ArrayList&lt;&gt;();     File taskFile = new File(\"./task.json\");      loadObjects(boardList, boardFile, Board[].class);     loadObjects(memberList, memberFile, Member[].class);     loadObjects(projectList, projectFile, Project[].class);     loadObjects(taskList, taskFile, Task[].class);      Map&lt;String,Command&gt; commandMap = new HashMap&lt;&gt;();      commandMap.put(\"/board/add\", new BoardAddCommand(boardList));     commandMap.put(\"/board/list\", new BoardListCommand(boardList));     commandMap.put(\"/board/detail\", new BoardDetailCommand(boardList));     commandMap.put(\"/board/update\", new BoardUpdateCommand(boardList));     commandMap.put(\"/board/delete\", new BoardDeleteCommand(boardList));      MemberListCommand memberListCommand = new MemberListCommand(memberList);     commandMap.put(\"/member/add\", new MemberAddCommand(memberList));     commandMap.put(\"/member/list\", memberListCommand);     commandMap.put(\"/member/detail\", new MemberDetailCommand(memberList));     commandMap.put(\"/member/update\", new MemberUpdateCommand(memberList));     commandMap.put(\"/member/delete\", new MemberDeleteCommand(memberList));      commandMap.put(\"/project/add\", new ProjectAddCommand(projectList, memberListCommand));     commandMap.put(\"/project/list\", new ProjectListCommand(projectList));     commandMap.put(\"/project/detail\", new ProjectDetailCommand(projectList));     commandMap.put(\"/project/update\", new ProjectUpdateCommand(projectList, memberListCommand));     commandMap.put(\"/project/delete\", new ProjectDeleteCommand(projectList));      commandMap.put(\"/task/add\", new TaskAddCommand(taskList, memberListCommand));     commandMap.put(\"/task/list\", new TaskListCommand(taskList));     commandMap.put(\"/task/detail\", new TaskDetailCommand(taskList));     commandMap.put(\"/task/update\", new TaskUpdateCommand(taskList, memberListCommand));     commandMap.put(\"/task/delete\", new TaskDeleteCommand(taskList));      commandMap.put(\"/hello\", new HelloCommand());      Deque&lt;String&gt; commandStack = new ArrayDeque&lt;&gt;();     Queue&lt;String&gt; commandQueue = new LinkedList&lt;&gt;();      loop:       while (true) {         String inputStr = Prompt.inputString(\"명령&gt; \");          if (inputStr.length() == 0) {           continue;         }          commandStack.push(inputStr);         commandQueue.offer(inputStr);          switch (inputStr) {           case \"history\": printCommandHistory(commandStack.iterator()); break;           case \"history2\": printCommandHistory(commandQueue.iterator()); break;           case \"quit\":           case \"exit\":             System.out.println(\"안녕!\");             break loop;           default:             Command command = commandMap.get(inputStr);             if (command != null) {               try {                 command.execute();               } catch (Exception e) {                 System.out.println(\"--------------------------------------------------------------\");                 System.out.printf(\"명령어 실행 중 오류 발생: %s\\n\", e);                 System.out.println(\"--------------------------------------------------------------\");               }             } else {               System.out.println(\"실행할 수 없는 명령입니다.\");             }         }         System.out.println();       }      Prompt.close();      saveObjects(boardList, boardFile);     saveObjects(memberList, memberFile);     saveObjects(projectList, projectFile);     saveObjects(taskList, taskFile);   }       // 스태틱 멤버들이 공유하는 변수가 아니라면 로컬 변수로 만든다.   void printCommandHistory(Iterator&lt;String&gt; iterator) {     try {       int count = 0;       while (iterator.hasNext()) {         System.out.println(iterator.next());         count++;          if ((count % 5) == 0 &amp;&amp; Prompt.inputString(\":\").equalsIgnoreCase(\"q\")) {           break;         }       }     } catch (Exception e) {       System.out.println(\"history 명령 처리 중 오류 발생!\");     }   }       // 스태틱 멤버들이 공유하는 변수가 아니라면 로컬 변수로 만든다.   private void saveObjects(Collection&lt;?&gt; list, File file) {     BufferedWriter out = null;      try {       out = new BufferedWriter(new FileWriter(file));        Gson gson = new Gson();       String jsonStr = gson.toJson(list);       out.write(jsonStr);        out.flush();        System.out.printf(\"총 %d 개의 객체를 '%s' 파일에 저장했습니다.\\n\",           list.size(), file.getName());      } catch (IOException e) {       System.out.printf(\"객체를 '%s' 파일에  쓰는 중 오류 발생! - %s\\n\",           file.getName(), e.getMessage());      } finally {       try {         out.close();       } catch (IOException e) {       }     }   }       // 스태틱 멤버들이 공유하는 변수가 아니라면 로컬 변수로 만든다.   private &lt;T&gt; void loadObjects(       Collection&lt;T&gt; list, // 객체를 담을 컬렉션       File file, // JSON 문자열이 저장된 파일       Class&lt;T[]&gt; clazz // JSON 문자열을 어떤 타입의 배열로 만들 것인지 알려주는 클래스 정보       ) {     BufferedReader in = null;      try {       in = new BufferedReader(new FileReader(file));       list.addAll(Arrays.asList(new Gson().fromJson(in, clazz)));        System.out.printf(\"'%s' 파일에서 총 %d 개의 객체를 로딩했습니다.\\n\",           file.getName(), list.size());      } catch (Exception e) {       System.out.printf(\"'%s' 파일 읽기 중 오류 발생! - %s\\n\",           file.getName(), e.getMessage());      } finally {       try {         in.close();       } catch (Exception e) {       }     }   } }   02) 애플리케이션을 시작하거나 종료할 때 실행할 옵저버의 메서드 호출 규칙을 정의한다.     com.eomcs.context.ApplicationContextListener 생성   // 애플리케이션의 상태가 변경되었을 때 호출할 메서드 규칙을 정의한다. // 즉 애플리케이션 상태 변경에 대해 보고를 받을 \"Observer\" 규칙을 정의한다. // 보통 옵저버를 \"리스너(listener)/구독자(subscriber)\"라 부른다.  public interface ApplicationContextListener {   // 발행자(애플리케이션)가 애플리케이션 시작을 알리기 위해 호출하는 메서드   void contextInitialized();    // 발행자(애플리케이션)가 애플리케이션 종료를 알리기 위해 호출하는 메서드   void contextDestroyed(); }   03) 옵저버를 저장할 컬렉션 객체와 옵저버를 추가하고 제거하는 메서드를 추가한다.   public class App {    // 옵저버를 보관할 컬렉션 객체   List&lt;ApplicationContextListener&gt; listeners = new ArrayList&lt;&gt;();    // 옵저버를 등록하는 메서드   public void addApplicationContextListener(ApplicationContextListener listener) {     listeners.add(listener);   }    // 옵저버를 제거하는 메서드   public void removeApplicationContextListener(ApplicationContextListener listener) {     listeners.remove(listener);   }    public static void main(String[] args) throws Exception {     App app = new App();     app.service();   } . . . }   04) 애플리케이션의 service() 실행 전/후에 옵저버에게 통지하는 코드를 추가한다.   public class App {    List&lt;ApplicationContextListener&gt; listeners = new ArrayList&lt;&gt;();    public void addApplicationContextListener(ApplicationContextListener listener) {     listeners.add(listener);   }    public void removeApplicationContextListener(ApplicationContextListener listener) {     listeners.remove(listener);   }    // service() 실행 전에 옵저버에게 통지한다.   private void notifyApplicationContextListenerOnServiceStarted() {     // 곧 서비스를 시작할테니 준비하라고, 서비스 시작에 관심있는 각 옵저버에게 통지한다.     for (ApplicationContextListener listener : listeners) {       listener.contextInitialized();     }   }    // service() 실행 후에 옵저버에게 통지한다.   private void notifyApplicationContextListenerOnServiceStopped() {     // 서비스가 종료되었으니 마무리 작업하라고, 마무리 작업에 관심있는 각 옵저버에게 통지한다.     for (ApplicationContextListener listener : listeners) {       listener.contextDestroyed();     }   }     public static void main(String[] args) throws Exception {     App app = new App();     app.service();   }    public void service() throws Exception {      // 옵저버에게 통지한다.     notifyApplicationContextListenerOnServiceStarted();      List&lt;Board&gt; boardList = new ArrayList&lt;&gt;();     File boardFile = new File(\"./board.json\");       List&lt;Member&gt; memberList = new LinkedList&lt;&gt;();     File memberFile = new File(\"./member.json\");       List&lt;Project&gt; projectList = new LinkedList&lt;&gt;();     File projectFile = new File(\"./project.json\");       List&lt;Task&gt; taskList = new ArrayList&lt;&gt;();     File taskFile = new File(\"./task.json\");       loadObjects(boardList, boardFile, Board[].class);     loadObjects(memberList, memberFile, Member[].class);     loadObjects(projectList, projectFile, Project[].class);     loadObjects(taskList, taskFile, Task[].class);      Map&lt;String,Command&gt; commandMap = new HashMap&lt;&gt;();      commandMap.put(\"/board/add\", new BoardAddCommand(boardList));     commandMap.put(\"/board/list\", new BoardListCommand(boardList));     commandMap.put(\"/board/detail\", new BoardDetailCommand(boardList));     commandMap.put(\"/board/update\", new BoardUpdateCommand(boardList));     commandMap.put(\"/board/delete\", new BoardDeleteCommand(boardList));      MemberListCommand memberListCommand = new MemberListCommand(memberList);     commandMap.put(\"/member/add\", new MemberAddCommand(memberList));     commandMap.put(\"/member/list\", memberListCommand);     commandMap.put(\"/member/detail\", new MemberDetailCommand(memberList));     commandMap.put(\"/member/update\", new MemberUpdateCommand(memberList));     commandMap.put(\"/member/delete\", new MemberDeleteCommand(memberList));      commandMap.put(\"/project/add\", new ProjectAddCommand(projectList, memberListCommand));     commandMap.put(\"/project/list\", new ProjectListCommand(projectList));     commandMap.put(\"/project/detail\", new ProjectDetailCommand(projectList));     commandMap.put(\"/project/update\", new ProjectUpdateCommand(projectList, memberListCommand));     commandMap.put(\"/project/delete\", new ProjectDeleteCommand(projectList));      commandMap.put(\"/task/add\", new TaskAddCommand(taskList, memberListCommand));     commandMap.put(\"/task/list\", new TaskListCommand(taskList));     commandMap.put(\"/task/detail\", new TaskDetailCommand(taskList));     commandMap.put(\"/task/update\", new TaskUpdateCommand(taskList, memberListCommand));     commandMap.put(\"/task/delete\", new TaskDeleteCommand(taskList));      commandMap.put(\"/hello\", new HelloCommand());      Deque&lt;String&gt; commandStack = new ArrayDeque&lt;&gt;();     Queue&lt;String&gt; commandQueue = new LinkedList&lt;&gt;();      loop:       while (true) {         String inputStr = Prompt.inputString(\"명령&gt; \");          if (inputStr.length() == 0) {           continue;         }          commandStack.push(inputStr);         commandQueue.offer(inputStr);          switch (inputStr) {           case \"history\": printCommandHistory(commandStack.iterator()); break;           case \"history2\": printCommandHistory(commandQueue.iterator()); break;           case \"quit\":           case \"exit\":             System.out.println(\"안녕!\");             break loop;           default:             Command command = commandMap.get(inputStr);             if (command != null) {               try {                 command.execute();               } catch (Exception e) {                 System.out.println(\"--------------------------------------------------------------\");                 System.out.printf(\"명령어 실행 중 오류 발생: %s\\n\", e);                 System.out.println(\"--------------------------------------------------------------\");               }             } else {               System.out.println(\"실행할 수 없는 명령입니다.\");             }         }         System.out.println();       }      Prompt.close();      saveObjects(boardList, boardFile);     saveObjects(memberList, memberFile);     saveObjects(projectList, projectFile);     saveObjects(taskList, taskFile);      // 옵저버에게 통지한다.     notifyApplicationContextListenerOnServiceStopped();   } . . . }   05) 애플리케이션을 시작하고 종료할 때 간단한 안내 메시지를 출력하는 옵저버를 추가한다.     com.eomcs.pms.listener.AppInitListener 클래스 생성   public class AppInitListener implements ApplicationContextListener {   @Override   public void contextInitialized() {     System.out.println(\"프로젝트 관리 시스템(PMS)에 오신 걸 환영합니다!\");   }    @Override   public void contextDestroyed() {     System.out.println(\"프로젝트 관리 시스템(PMS)을 종료합니다!\");   } }      service() 호출 전에 옵저버를 등록한다.     public class App04 { . . . public static void main(String[] args) throws Exception {   App04 app = new App04();    // 안내 메시지를 출력하는 옵저버 등록   app.addApplicationContextListener(new AppInitListener());    app.service(); } . . . }          ","categories": ["pms"],
        "tags": [],
        "url": "http://localhost:4000/pms/mini-pms-33a/",
        "teaser": null
      },{
        "title": "mini-pms 33b",
        "excerpt":"Observer 객체를 통하여 파일 다루기     ApplicationContextListener 인터페이스 변경   // 애플리케이션의 상태가 변경되었을 때 // 호출할 메서드 규칙을 정의한다. // 즉 애플리케이션 상태 변경에 대해 보고를 받을 \"Observer\" 규칙을 정의한다. // 보통 옵저버를 \"리스너(listener)/구독자(subscriber)\"라 부른다. // public interface ApplicationContextListener {   // 발행자(애플리케이션)가 애플리케이션 시작을 알리기 위해 호출하는 메서드   // - 발행자와 옵저버 간에 데이터를 공유하기 위해 맵 파라미터 추가   // - 호출자가 옵저버의 실행 결과를 받을 수 있도록 파라미터로 맵 객체를 전달할 것이다.   // - 리턴 값으로 결과를 전달하지 않고 파라미터로 넘어온 저장소에 보관하는 방법을 사용한다.   // - 왜 이런 방식을 사용하는가?   // - 파라미터 방식은 메서드에게 작업에 필요한 정보를 전달할 수 있기 때문이다.   // - Map을 사용하여 파라미터로 전달하는 방식은 데이터의 In/Out이 가능하다.   void contextInitialized(Map&lt;String,Object&gt; context);    // 발행자(애플리케이션)가 애플리케이션 종료를 알리기 위해 호출하는 메서드   void contextDestroyed(Map&lt;String,Object&gt; context); }      AppInitListener 클래스 변경   public class AppInitListener implements ApplicationContextListener {   @Override   // 변경된 규칙에 따라 파라미터 추가   public void contextInitialized(Map&lt;String,Object&gt; context) {     System.out.println(\"프로젝트 관리 시스템(PMS)에 오신 걸 환영합니다!\");   }    @Override   // 변경된 규칙에 따라 파라미터 추가   public void contextDestroyed(Map&lt;String,Object&gt; context) {     System.out.println(\"프로젝트 관리 시스템(PMS)을 종료합니다!\");   } }     App 변경   public class App {    Map&lt;String,Object&gt; context = new Hashtable&lt;&gt;();    List&lt;ApplicationContextListener&gt; listeners = new ArrayList&lt;&gt;();    public void addApplicationContextListener(ApplicationContextListener listener) {     listeners.add(listener);   }    public void removeApplicationContextListener(ApplicationContextListener listener) {     listeners.remove(listener);   }    // service() 실행 전에 옵저버에게 통지한다.   private void notifyApplicationContextListenerOnServiceStarted() {     for (ApplicationContextListener listener : listeners) {       // 곧 서비스를 시작할테니 준비하라고,       // 서비스 시작에 관심있는 각 옵저버에게 통지한다.       // =&gt; 옵저버에게 맵 객체를 넘겨준다.       // =&gt; 옵저버는 작업 결과를 파라미터로 넘겨준 맵 객체에 담아 줄 것이다.       listener.contextInitialized(context);     }   }    // service() 실행 후에 옵저버에게 통지한다.   private void notifyApplicationContextListenerOnServiceStopped() {     for (ApplicationContextListener listener : listeners) {       // 서비스가 종료되었으니 마무리 작업하라고,       // 마무리 작업에 관심있는 각 옵저버에게 통지한다.       // =&gt; 옵저버에게 맵 객체를 넘겨준다.       // =&gt; 옵저버는 작업 결과를 파라미터로 넘겨준 맵 객체에 담아 줄 것이다.       listener.contextDestroyed(context);     }   }     public static void main(String[] args) throws Exception {     App app = new App();      app.addApplicationContextListener(new AppInitListener());      app.service();   }    @SuppressWarnings(\"unchecked\")   public void service() throws Exception {      notifyApplicationContextListenerOnServiceStarted();      List&lt;Board&gt; boardList = (List&lt;Board&gt;) context.get(\"boardList\");     List&lt;Member&gt; memberList = (List&lt;Member&gt;) context.get(\"memberList\");     List&lt;Project&gt; projectList = (List&lt;Project&gt;) context.get(\"projectList\");     List&lt;Task&gt; taskList = (List&lt;Task&gt;) context.get(\"taskList\");      Map&lt;String,Command&gt; commandMap = new HashMap&lt;&gt;();      commandMap.put(\"/board/add\", new BoardAddCommand(boardList));     commandMap.put(\"/board/list\", new BoardListCommand(boardList));     commandMap.put(\"/board/detail\", new BoardDetailCommand(boardList));     commandMap.put(\"/board/update\", new BoardUpdateCommand(boardList));     commandMap.put(\"/board/delete\", new BoardDeleteCommand(boardList));      MemberListCommand memberListCommand = new MemberListCommand(memberList);     commandMap.put(\"/member/add\", new MemberAddCommand(memberList));     commandMap.put(\"/member/list\", memberListCommand);     commandMap.put(\"/member/detail\", new MemberDetailCommand(memberList));     commandMap.put(\"/member/update\", new MemberUpdateCommand(memberList));     commandMap.put(\"/member/delete\", new MemberDeleteCommand(memberList));      commandMap.put(\"/project/add\", new ProjectAddCommand(projectList, memberListCommand));     commandMap.put(\"/project/list\", new ProjectListCommand(projectList));     commandMap.put(\"/project/detail\", new ProjectDetailCommand(projectList));     commandMap.put(\"/project/update\", new ProjectUpdateCommand(projectList, memberListCommand));     commandMap.put(\"/project/delete\", new ProjectDeleteCommand(projectList));      commandMap.put(\"/task/add\", new TaskAddCommand(taskList, memberListCommand));     commandMap.put(\"/task/list\", new TaskListCommand(taskList));     commandMap.put(\"/task/detail\", new TaskDetailCommand(taskList));     commandMap.put(\"/task/update\", new TaskUpdateCommand(taskList, memberListCommand));     commandMap.put(\"/task/delete\", new TaskDeleteCommand(taskList));      commandMap.put(\"/hello\", new HelloCommand());      Deque&lt;String&gt; commandStack = new ArrayDeque&lt;&gt;();     Queue&lt;String&gt; commandQueue = new LinkedList&lt;&gt;();      loop:       while (true) {         String inputStr = Prompt.inputString(\"명령&gt; \");          if (inputStr.length() == 0) {           continue;         }          commandStack.push(inputStr);         commandQueue.offer(inputStr);          switch (inputStr) {           case \"history\": printCommandHistory(commandStack.iterator()); break;           case \"history2\": printCommandHistory(commandQueue.iterator()); break;           case \"quit\":           case \"exit\":             System.out.println(\"안녕!\");             break loop;           default:             Command command = commandMap.get(inputStr);             if (command != null) {               try {                 command.execute();               } catch (Exception e) {                 System.out.println(\"--------------------------------------------------------------\");                 System.out.printf(\"명령어 실행 중 오류 발생: %s\\n\", e);                 System.out.println(\"--------------------------------------------------------------\");               }             } else {               System.out.println(\"실행할 수 없는 명령입니다.\");             }         }         System.out.println();       }      Prompt.close();      notifyApplicationContextListenerOnServiceStopped();   } . . . }   02) 파일에서 데이터를 로딩하고 저장하는 기능을 옵저버로 옮긴다.     DataHandlerListener 클래스 생성     // 게시물, 회원, 프로젝트, 작업 데이터를 파일에서 로딩하고 파일로 저장하는 일을 한다. public class DataHandlerListener implements ApplicationContextListener {  List&lt;Board&gt; boardList = new ArrayList&lt;&gt;(); File boardFile = new File(\"./board.json\"); // 게시글을 저장할 파일 정보  List&lt;Member&gt; memberList = new LinkedList&lt;&gt;(); File memberFile = new File(\"./member.json\"); // 회원을 저장할 파일 정보  List&lt;Project&gt; projectList = new LinkedList&lt;&gt;(); File projectFile = new File(\"./project.json\"); // 프로젝트를 저장할 파일 정보  List&lt;Task&gt; taskList = new ArrayList&lt;&gt;(); File taskFile = new File(\"./task.json\"); // 작업을 저장할 파일 정보  @Override public void contextInitialized(Map&lt;String,Object&gt; context) {   // 애플리케이션의 서비스가 시작되면 먼저 파일에서 데이터를 로딩한다.   // 파일에서 데이터 로딩   loadData(boardList, boardFile, Board[].class);   loadData(memberList, memberFile, Member[].class);   loadData(projectList, projectFile, Project[].class);   loadData(taskList, taskFile, Task[].class);    // 옵저버가 파일에서 데이터(게시글,회원,프로젝트,작업)를 읽어   // List 컬렉션에 저장한 다음,   // 발행자(App 객체)가 사용할 수 있도록 맵 객체에 담아서 공유한다.   context.put(\"boardList\", boardList);   context.put(\"memberList\", memberList);   context.put(\"projectList\", projectList);   context.put(\"taskList\", taskList); }  @Override public void contextDestroyed(Map&lt;String,Object&gt; context) {   // 애플리케이션 서비스가 종료되면 컬렉션에 보관된 객체를 파일에 저장한다.   // 데이터를 파일에 저장   saveData(boardList, boardFile);   saveData(memberList, memberFile);   saveData(projectList, projectFile);   saveData(taskList, taskFile); }  private &lt;T&gt; void loadData(     Collection&lt;T&gt; list, // 객체를 담을 컬렉션     File file, // JSON 문자열이 저장된 파일     Class&lt;T[]&gt; clazz // JSON 문자열을 어떤 타입의 배열로 만들 것인지 알려주는 클래스 정보     ) {   BufferedReader in = null;    try {     in = new BufferedReader(new FileReader(file));     list.addAll(Arrays.asList(new Gson().fromJson(in, clazz)));     System.out.printf(\"'%s' 파일에서 총 %d 개의 객체를 로딩했습니다.\\n\",         file.getName(), list.size());    } catch (Exception e) {     System.out.printf(\"'%s' 파일 읽기 중 오류 발생! - %s\\n\",         file.getName(), e.getMessage());    } finally {     try {       in.close();     } catch (Exception e) {     }   } }  private void saveData(Collection&lt;?&gt; list, File file) {   BufferedWriter out = null;    try {     out = new BufferedWriter(new FileWriter(file));      Gson gson = new Gson();     String jsonStr = gson.toJson(list);     out.write(jsonStr);      out.flush();      System.out.printf(\"총 %d 개의 객체를 '%s' 파일에 저장했습니다.\\n\",         list.size(), file.getName());    } catch (IOException e) {     System.out.printf(\"객체를 '%s' 파일에  쓰는 중 오류 발생! - %s\\n\",         file.getName(), e.getMessage());    } finally {     try {       out.close();     } catch (IOException e) {     }   } } }           App에 DataHandlerListener 옵저버를 등록한다.     public class App { . . .   public static void main(String[] args) throws Exception {   App app = new App();    app.addApplicationContextListener(new AppInitListener());   // 옵저버 등록   app.addApplicationContextListener(new DataHandlerListener());    app.service(); } . . . }          ","categories": ["pms"],
        "tags": [],
        "url": "http://localhost:4000/pms/mini-pms-33b/",
        "teaser": null
      },{
        "title": "2020-10-20 TIL",
        "excerpt":"스레드풀 구현     mini-pms 36   스레드풀     스레드를 풀링 기법(pooling)을 이용하여 관리한다.   스레드를 사용한 후에 버리지 않고 재사용하여 가비지 생성을 줄인다.   풀링 기법(pooling)     사용한 객체를 버리지 않고 보관해 두었다가 재사용하는 객체 관리 기법이다.   동일한 객체를 자주 생성하고,   생성한 객체를 쓰고 버리는 상황에서 대량의 가비지가 생성되는 경우에 적합한다.   GoF의 ‘디자인 패턴’에서 Flyweight 패턴의 한 예이다.   01) 스레드풀 정의     notify() 와 wait() 는 싱크로되지 않은 곳(막혀있지 않은 곳)에서 사용하면 에러가 뜬다.   synchronized (대상)   에외처리       @Override     public void run() {       while (true) {          // try-catch를 while 안에 넣으면 task.run()을 수행하다가 예외가 발생했을 경우 처리할 수 없다.         // 스레드는 유효하다.          try {           this.wait();         } catch (Exception e) {           System.out.println(\"스레드 실행 중 오류 발생\");           break;         }          task.run();       }     }      스레드풀 만들기(java.util 따라하기)   public class ThreadPool {    List&lt;Worker&gt; workers = new ArrayList&lt;&gt;();    // 스레드 + 작업을 맡기고 + 깨우는 기능 + 작업 완료 후 잠자는 기능   class Worker extends Thread {     Runnable task;      public void setTask(Runnable task) {       // 스레드가 할 작업을 배정한 후       this.task = task;        synchronized (this) {         // 스레드를 깨운다.         this.notify();       }     }      @Override     public void run() {        synchronized (this) {         while (true) {           try {             System.out.printf(\"[%s] - 스레드 대기 중...\\n\", this.getName());             this.wait();             System.out.printf(\"[%s] - 스레드 작업 시작\\n\", this.getName());             // 이 스레드 객체에 대해 대기 상태로 있다가             // 이 스레드에게 깨어나라는 알림(notify()/notifyAll()이 온다면             // 즉시 runninig 상태로 되돌아간다.           } catch (Exception e) {             System.out.printf(\"[%s] - 스레드 실행 중 오류 발생\\n\", this.getName());             break;             // 기다리다가 인터럽트 예외가 발생하면 스레드를 종료한다.           }           try {             task.run();             System.out.printf(\"[%s] - 스레드 작업 종료\\n\", this.getName());           } catch (Exception e) {             System.out.printf(\"[%s] - %s\\n\", this.getName(), e.getMessage());             // 작업 수행 중 오류가 발생하더라도 스레드는 계속 유효하다.           } finally {             // 정상적인 종료든 작업 수행 중 예외가 발생했든 간에             // 작업을 마친 스레드는 재사용할 수 있도록             // 다시 목록에 보관되어야 한다.             workers.add(this);             System.out.printf(\"[%s] - 스레드풀로 되돌아 감\\n\", this.getName());           }         }       }     }   }    public void execute(Runnable task) {      Worker t;     if (workers.size() == 0) {       // 만약 스레드가 없다면 스레드를 새로 생성한다.       t = new Worker();       System.out.printf(\"[%s] - 스레드 생성\\n\", t.getName());       // 그리고 즉시 실행한다.       // - 실행하더라도 스레드 스스로 대기 상태로 갈 것이다.       t.start();        // 현재 main 스레드를 잠깐 멈추게 하여       // 새로 만든 스레드가 실행할 틈을 주자.       // 그래야만 새로 만든 스레드가 실행하자마자 대기 상태로 간다.       try {         Thread.sleep(20);       } catch (Exception e) {         // sleep() 중 발생한 예외는 무시한다.       }     } else {       // 만약 스레드가 있다면 스레드풀에서 스레드를 한 개 꺼낸다.       // - 스레드풀에서 꺼낸 스레드는 현재 대기 상태이다.       t = workers.remove(0);       System.out.printf(\"[%s] - 스레드 재사용\\n\", t.getName());     }      // 스레드를 깨워서 일을 시킨다.     // - 스레드에게 해야 할 작업을 배정하면 된다.     t.setTask(task);   } }   02) 클라이언트가 접속하면 요청 처리를 ThreadPool에게 맡긴다.     같은 코드인데 정상 실행이 됐다가 안됐다가 하는것은 비동기 때문이다.            비동기에서는 누가 먼저 실행되는지 정확하게 알아야 한다.           소켓은 클라이언트가 연결되었다가 끊어지는 순간에 사라지기 때문에 재사용이 불가능하다.   스레드가 몇개의 작업을 처리할 수 있는지는 컴퓨터의 cpu 성능에 따라 다르다.   스레드를 몇개 생성할 수 있는지는 메모리에 따라 다르다.   메인 스레드가 죽어도 나머지 스레드(스레드풀)가 살아 있으면 종료되지 않는다.   public class ServerApp {    static boolean stop = false;    // 스레드풀 준비   ThreadPool threadPool = new ThreadPool();    static Map&lt;String,Object&gt; context = new Hashtable&lt;&gt;();    List&lt;ApplicationContextListener&gt; listeners = new ArrayList&lt;&gt;();    public void addApplicationContextListener(ApplicationContextListener listener) {     listeners.add(listener);   }    public void removeApplicationContextListener(ApplicationContextListener listener) {     listeners.remove(listener);   }    private void notifyApplicationContextListenerOnServiceStarted() {     for (ApplicationContextListener listener : listeners) {       listener.contextInitialized(context);     }   }    private void notifyApplicationContextListenerOnServiceStopped() {     for (ApplicationContextListener listener : listeners) {       listener.contextDestroyed(context);     }   }    public void service(int port) {      notifyApplicationContextListenerOnServiceStarted();      try (ServerSocket serverSocket = new ServerSocket(port)) {       System.out.println(\"서버 실행 중...\");        while (true) {         Socket clientSocket = serverSocket.accept();          if (stop) {           break;         }         // 스레드풀로 변경         threadPool.execute(() -&gt; handleClient(clientSocket));       }      } catch (Exception e) {       e.printStackTrace();     }      notifyApplicationContextListenerOnServiceStopped();   } . . . }   03) 스레드풀   package com.eomcs.util.concurrent;  import java.util.ArrayList;  public class ThreadPool {    // 스레드풀의 종료 상태   boolean stopping = false;    // 스레드 목록을 담는 리스트   ArrayList&lt;Worker&gt; workers = new ArrayList&lt;&gt;();    // 작업을 수행하는 스레드   private class Worker extends Thread {     Runnable task;      public void setTask(Runnable task) {       this.task = task;       synchronized (this) {         this.notify();       }     }      @Override     public void run() {       synchronized (this) {         try {           while (true) {             this.wait();              // 스레드풀의 상태가 종료하는 상태라면, 스레드 실행을 멈춘다.             if (ThreadPool.this.stopping)               break;              task.run();             workers.add(this);             System.out.println(\"스레드풀로 되돌아 감!\");           }         } catch (Exception e) {           System.out.printf(\"%s 스레드에서 오류 발생! - 스레드풀에서 제거.\\n\", this.getName());           workers.remove(this);         }       }     }   }    public void execute(Runnable task) {     Worker t = null;     if (workers.isEmpty()) {       t = new Worker();       t.start();       System.out.printf(\"새 스레드(%s) 생성 및 실행!\\n\", t.getName());     } else {       t = workers.remove(0);       System.out.printf(\"기존 스레드(%s) 사용!\\n\", t.getName());     }      t.setTask(task);   }    public void shutdown() {     try {       this.stopping = true;        // 일단 현재 목록에 대기하고 있는 스레드를 종료한다.       while (!workers.isEmpty()) {         Worker worker = workers.remove(0);         synchronized (worker) {           worker.notify();         }       }        // 아직 클라이언트의 요청 처리를 완료하지 못한 스레드를 기다린다.       Thread.sleep(2000);        // 다시 현재 목록에 대기하고 있는 스레드를 종료한다.       while (!workers.isEmpty()) {         Worker worker = workers.remove(0);         synchronized (worker) {           worker.notify();         }       }     } catch (Exception e) {       System.out.println(\"스레드풀 종료 중 오류 발생!\");       e.printStackTrace();     }   } }       내가 타이핑한거.   public class ThreadPool {    // 스레드풀의 종료 상태   boolean stopping = false;    List&lt;Worker&gt; workers = new ArrayList&lt;&gt;();    class Worker extends Thread {     Runnable task;      public void setTask(Runnable task) {       this.task = task;        synchronized (this) {         this.notify();       }     }      @Override     public void run() {        synchronized (this) {         while (true) {           try {             System.out.printf(\"[%s] - 스레드 대기 중...\\n\", this.getName());             this.wait();              if (ThreadPool.this.stopping) { // 스레드풀이 종료 상태라면               // 스레드는 깨어나는 즉시 실행을 멈춘다.               break;             }              System.out.printf(\"[%s] - 스레드 작업 시작\\n\", this.getName());           } catch (Exception e) {             System.out.printf(\"[%s] - 스레드 실행 중 오류 발생\\n\", this.getName());             break;           }           try {             task.run();             System.out.printf(\"[%s] - 스레드 작업 종료\\n\", this.getName());           } catch (Exception e) {             System.out.printf(\"[%s] - %s\\n\", this.getName(), e.getMessage());           } finally {             workers.add(this);             System.out.printf(\"[%s] - 스레드풀로 되돌아 감\\n\", this.getName());           }         }       }     }   }    public void execute(Runnable task) {      if (stopping) {       // RuntimeException을 사용하면 public void execute(Runnable task) 에서 예외를 던지지 않아도 된다.       throw new RuntimeException(\"스레드풀이 종료 상태입니다.\");     }      Worker t;     if (workers.size() == 0) {       t = new Worker();       System.out.printf(\"[%s] - 스레드 생성\\n\", t.getName());       t.start();        try {         Thread.sleep(20);       } catch (Exception e) {       }     } else {       t = workers.remove(0);       System.out.printf(\"[%s] - 스레드 재사용\\n\", t.getName());     }      t.setTask(task);   }    public void shutdown() {     try {       this.stopping = true;        while (!workers.isEmpty()) { // 스레드풀에 대기 중인 스레드가 있다면         Worker worker = workers.remove(0); // 맨 앞에 있는 스레드를 꺼내서         synchronized (worker) {           // 스레드를 깨운다.           // 스레드는 깨어나면 stopping 상태에 따라 종료 여부를 결정하도록 프로그래밍 되어있다.           // worker 스레드를 보라.           worker.notify();         }       }        // 아직 스레드풀에서 대기하지 않고 현재 작업을 수행하는 스레드가 있을 수 있다.       // 그 스레드가 작업을 끝낼 때까지 좀 기다리자       Thread.sleep(2000);        // 다시 한 번 대기하고 있는 스레드를 종료해보자.       while (!workers.isEmpty()) { // 스레드풀에 대기 중인 스레드가 있다면         Worker worker = workers.remove(0); // 맨 앞에 있는 스레드를 꺼내서         synchronized (worker) {           // 스레드를 깨운다.           // 스레드는 깨어나면 stopping 상태에 따라 종료 여부를 결정하도록 프로그래밍 되어있다.           // worker 스레드를 보라.           worker.notify();         }       }         // 예외 처리를 한다.     } catch (Exception e) {       System.out.println(\"스레드풀을 종료하는 중에 예외 발생\");       e.printStackTrace();     }    } }   36-b   스레드풀을 자바에서 제공하는 것으로 변경   public class ServerApp {    static boolean stop = false;    // 스레드풀 준비   ExecutorService threadPool = Executors.newCachedThreadPool();    static Map&lt;String,Object&gt; context = new Hashtable&lt;&gt;();    List&lt;ApplicationContextListener&gt; listeners = new ArrayList&lt;&gt;();    public void addApplicationContextListener(ApplicationContextListener listener) {     listeners.add(listener);   }    public void removeApplicationContextListener(ApplicationContextListener listener) {     listeners.remove(listener);   }    private void notifyApplicationContextListenerOnServiceStarted() {     for (ApplicationContextListener listener : listeners) {       listener.contextInitialized(context);     }   }    private void notifyApplicationContextListenerOnServiceStopped() {     for (ApplicationContextListener listener : listeners) {       listener.contextDestroyed(context);     }   }    public void service(int port) {      notifyApplicationContextListenerOnServiceStarted();      try (ServerSocket serverSocket = new ServerSocket(port)) {       System.out.println(\"서버 실행 중...\");        while (true) {         Socket clientSocket = serverSocket.accept();          if (stop) {           break;         }         threadPool.execute(() -&gt; handleClient(clientSocket));       }      } catch (Exception e) {       e.printStackTrace();     }      notifyApplicationContextListenerOnServiceStopped();      // 스레드풀을 종료한다.     threadPool.shutdown();      // 스레드풀을 종료한다.     try {       if (!threadPool.awaitTermination(10, TimeUnit.SECONDS)) {         System.out.println(\"아직 종료 안된 작업이 있다.\");         System.out.println(\"남아 있는 작업의 강제 종료를 시도하겠다.\");         threadPool.shutdownNow();          if (!threadPool.awaitTermination(5, TimeUnit.SECONDS)) {           System.out.println(\"스레드풀의 강제 종료를 완료하지 못했다.\");         } else {           System.out.println(\"모든 작업을 강제 종료했다.\");         }        }        System.out.println(\"main() 종료!\");     } catch (Exception e) {       // 예외는 무시한다.     }   } . . . }   DBMS   개발자가 직접 데이터 관리를 위해 파일을 조작할 때     임의의 위치에 있는 값을 변경?   특정 조건에 해당하는 데이터를 찾기?   특정 조건의 데이터 삭제?   대량의 데이터를 다루기 쉽게 어떤 기법으로 여러 파일로 분산할 것이냐?   데이터와 데이터 간의 관계를 어떻게 관리할 것이냐?   유효하지 않은 데이터 조작            많은 코딩, 중복 개발 =&gt; Data 관리 전문 S/W =&gt; DBMS       상용으로 쓸 수 없다.           DBMS     데이터 관리 전문 소프트웨어   DataBase Management System   예)            (외산) Oracle, My-SQL, MS-SQL, DB2,       (국산) Altibase, Cubrid, Tibero       MariaDB &lt;- My-SQL 창시자           Relational DBMS -&gt; 데이터와 데이터 사이의 관계를 다루기 쉽게            Object-Relational                    O-RDBMS -&gt; PostgreSQL                           NoSQL-DBMS            MongoDB &lt;- BigData : 자잘하게 갯수가 많은 데이터       https://poiemaweb.com/mongdb-basics       서로 연관이 없으면서 데이터 불륨이 큰 빅데이터를 다루기 위해서 사용한다.           Data 저장 / 조회   임의의 위치에 있는 Data 변경 / 삭제 / 검색   Client 인증 / 권한 관리   Data 간의 관계를 제어            -&gt; 결함이 생기지 않게 제어(무결성 Integrity)           DBMS 와 SQL     https://zzsza.github.io/development/2018/03/18/sql-for-everyone/   https://brunch.co.kr/@minu-log/5   DBMS 와 Client 의 통신에서 명령을 작성하는 문법이 SQL 이다.   Structured Query Language   특정 DBMS로부터 독립적으로 사용한다.   Select, From, Where, Group by, Having, Limit   표준 SQL + α     버젼별 표준 문법이 있다.   DBMS 마다 지원하는 버젼에 차이가 있다.            모든 DBMS 가 SQL 표준을 완벽하게 지원하지 못한다.       또는 DBMS 마다 지원하는 SQL 버젼도 다르다       같은 DBMS라도 버젼마다 지원하는 SQL 버젼이 다르다.                    -&gt; 개발자는 사용할 DBMS에 맞춰 SQL을 작성해야 한다.                           SQL 과 개발 현실     SQL 문 = 표준 SQL + DBMS 전용 문법            -&gt; 1) 같은 Vendor의 DBMS(같은 제품)라 하더라도 버젼마다 사용할 수 있는 문법이 차이가 난다.       -&gt; 2) DBMS가 다른 Vendor의 제품이라면 전용 문법이 다르기 때문에 동작이 안될 수 있다.           -&gt; 그렇다면 표준 SQL을 사용?            DBMS 마다 사용 가능한 문법이 다를 수 있다.       DBMS 전용 문법은 DBMS 성능을 극한으로 이용                    -&gt; 표준 SQL만 사용하면 이런 이점을 누릴 수 없다.                           개발자는 DBMS 상황에 맞춰 SQL을 변경해줘야한다.   DBMS 설치 (eomcs-docs-dbms)     MariaDB &lt;-&gt; (접속하는 프로그램) MySql   MariaDB 설치   [windows OS] scoop 패키지 관리자를 이용하여 mariadb 설치 &gt; scoop install mariadb  서비스에 등록      mysqld --install \"서비스명\" &gt; mysqld --install \"mariadb\"  서비스 시작      net start 서비스명 &gt; net start mariadb    (windows)  서비스 종료     net stop 서비스명 &gt; net stop mariadb  [mac] mariadb 설치 &gt; brew install mariadb  mariadb 실행 &gt; brew services start mariadb &gt; brew services stop mariadb 또는 &gt; mysql.server start &gt; mysql.server stop  [linux] mariadb 설치 &gt; sudo apt update &gt; sudo apt install mariadb-server &gt; sudo systemctl status mariadb &gt; mysql -V  mariadb 설치 후 root 암호 변경 &gt; sudo mysql_secure_installation  mariadb 실행 &gt; service mariadb start &gt; service mariadb stop &gt; service mariadb status     mysql 서버에 접속하기 로컬 MySQL 서버에 접속            mysql -u root -p Enter password: 암호입력            원격 MySQL 서버에 접속     mysql -h 서버주소 -u root -p Enter password: 암호입력       mysql root 암호 변경            alter user ‘root’@’localhost’ identified by ‘1111’;            MySQL 사용자 추가            CREATE USER ‘사용자아이디’@’서버주소’ IDENTIFIED BY ‘암호’;            로컬에서만 접속할 수 있는 사용자를 만들기:     CREATE USER ‘study’@’localhost’ IDENTIFIED BY ‘1111’;   =&gt; 이 경우 stidu 사용자는 오직 로컬(서버를 실행하는 컴퓨터)에서만 접속 가능한다.   =&gt; 다른 컴퓨터에서 실행하는 MySQL 서버에 접속할 수 없다는 것을 의미한다.    원격에서만 접속할 수 있는 사용자를 만들기:     CREATE USER ‘study’@’%’ IDENTIFIED BY ‘1111’;   =&gt; 이 경우 study 사용자는 원력에서만 접속 가능하다.       MySQL 사용자 목록 조회            select user, host from 데이터베이스명.테이블명; select user, host from mysql.user;            MySQL 데이터베이스 생성 mariadb에서는 default 키워드를 사용하지 않는다.            CREATE DATABASE 데이터베이스명 CHARACTER SET utf8 COLLATE utf8_general_ci;               CREATE DATABASE studydb   CHARACTER SET utf8   COLLATE utf8_general_ci;       MySQL 사용자에게 데이터베이스 사용 권한 부여            GRANT ALL ON 데이터베이스명.* TO ‘사용자아이디’@’서버주소’; GRANT ALL ON studydb.* TO ‘study’@’localhost’;            데이터베이스 목록 조회            show databases;            사용자 교체            quit or exit  (프로그램 종료 후) mysql -u study -p   (다시 실행)            기본으로 사용할 데이터베이스 지정하기            use 데이터베이스명 use studydb;            데이터베이스의 전체 테이블 목록 조회            show tables;            연습 ``` 사용자 생성 : user1 user1이 사용할 데이터베이스 생성: user1db   사용자 생성 : user2 user1이 사용할 데이터베이스 생성: user2db   사용자 생성 : user3 user1이 사용할 데이터베이스 생성: user3db   사용자 생성 : user4 user1이 사용할 데이터베이스 생성: user4db   사용자 생성 : user5 user1이 사용할 데이터베이스 생성: user5db  - mariadb 인스톨과 설정  ✘ rsh@rsh  ~  brew service stop mariadb Error: Unknown command: service  ✘ rsh@rsh  ~  brew services stop mariadb Stopping mariadb… (might take a while) ==&gt; Successfully stopped mariadb (label: homebrew.mxcl.mariadb)  rsh@rsh  ~  brew services start mariadb ==&gt; Successfully started mariadb (label: homebrew.mxcl.mariadb)  rsh@rsh  ~  mysql -u root -p Enter password:  ERROR 1698 (28000): Access denied for user ‘root’@’localhost’  ✘ rsh@rsh  ~  sudo mysql_secure_installation Password: Sorry, try again. Password:   NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB       SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!   In order to log into MariaDB to secure it, we’ll need the current password for the root user. If you’ve just installed MariaDB, and haven’t set the root password yet, you should just press enter here.   Enter current password for root (enter for none):  OK, successfully used password, moving on…   Setting the root password or using the unix_socket ensures that nobody can log into the MariaDB root user without the proper authorisation.   You already have your root account protected, so you can safely answer ‘n’.   Switch to unix_socket authentication [Y/n] n  … skipping.   You already have your root account protected, so you can safely answer ‘n’.   Change the root password? [Y/n] y New password:  Re-enter new password:  Password updated successfully! Reloading privilege tables..  … Success!   By default, a MariaDB installation has an anonymous user, allowing anyone to log into MariaDB without having to have a user account created for them.  This is intended only for testing, and to make the installation go a bit smoother.  You should remove them before moving into a production environment.   Remove anonymous users? [Y/n] y  … Success!   Normally, root should only be allowed to connect from ‘localhost’.  This ensures that someone cannot guess at the root password from the network.   Disallow root login remotely? [Y/n] y  … Success!   By default, MariaDB comes with a database named ‘test’ that anyone can access.  This is also intended only for testing, and should be removed before moving into a production environment.   Remove test database and access to it? [Y/n] y     Dropping test database…  … Success!   Removing privileges on test database…  … Success!   Reloading the privilege tables will ensure that all changes made so far will take effect immediately.   Reload privilege tables now? [Y/n] y  … Success!   Cleaning up…   All done!  If you’ve completed all of the above steps, your MariaDB installation should now be secure.   Thanks for using MariaDB!  rsh@rsh  ~  brew services stop mariadb Stopping mariadb… (might take a while) ==&gt; Successfully stopped mariadb (label: homebrew.mxcl.mariadb)  rsh@rsh  ~  mysql -u root -p Enter password:  ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ (2)  ✘ rsh@rsh  ~  brew services start mariadb   ==&gt; Successfully started mariadb (label: homebrew.mxcl.mariadb)  rsh@rsh  ~  mysql -u root -p           Enter password:  Welcome to the MariaDB monitor.  Commands end with ; or \\g. Your MariaDB connection id is 3 Server version: 10.5.6-MariaDB Homebrew   Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.   Type ‘help;’ or ‘\\h’ for help. Type ‘\\c’ to clear the current input statement.   MariaDB [(none)]&gt; ```  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL201020/",
        "teaser": null
      },{
        "title": "mini-pms 36 a",
        "excerpt":"Server   36-a. 스레드풀을 이용하여 스레드를 재사용하기 : 스레드풀 구현하기   01) 스레드풀을 정의한다.     com.eomcs.util.concurrent.ThreadPool 추가   public class ThreadPool {    // 생성한 스레드를 보관할 컬렉션 준비   List&lt;Worker&gt; workers = new ArrayList&lt;&gt;();    // 스레드 + 작업을 맡기고 + 깨우는 기능 + 작업 완료 후 잠자는 기능   class Worker extends Thread {      Runnable task;      public void setTask(Runnable task) {       // 스레드가 할 작업을 배정한 후       this.task = task;        synchronized (this) {         // 스레드를 깨운다.         this.notify();       }     }      // 스레드를 확장했기 때문에 오버라이드를 통해 알맞게 바꾼다.     @Override     public void run() {        synchronized (this) {         while (true) {           try {             System.out.printf(\"[%s] - 스레드 대기 중...\\n\", this.getName());              this.wait();              System.out.printf(\"[%s] - 스레드 작업 시작!\\n\", this.getName());             // 이 스레드 객체에 대해 대기 상태로 있다가             // 이 스레드에게 깨어나라는 알림(notify()/nofifyAll())이 온다면             // 즉시 running 상태로 되돌아 간다.           } catch (Exception e) {             System.out.printf(\"[%s] - 스레드 실행 중 오류 발생!\\n\", this.getName());             break;             // 기다리다가 인터럽트 예외가 발생하면             // 스레드를 종료한다.           }           try {             task.run();             System.out.printf(\"[%s] - 스레드 작업 종료!\\n\", this.getName());           } catch (Exception e) {             System.out.printf(\"[%s] - %s\\n\",                 this.getName(), e.getMessage());             // 작업 수행 중 오류가 발생하더라도 스레드는 계속 유효하다.           } finally {             // 정상적인 종료든 작업 수행 중 예외가 발생했든 간에             // 작업을 마친 스레드는 재사용할 수 있도록             // 다시 목록에 보관되어야 한다.             workers.add(this);             System.out.printf(\"[%s] - 스레드풀로 되돌아 감!\\n\", this.getName());           }         }       }     }   }    public void execute(Runnable task) {     Worker t;     if (workers.size() == 0) {       // 스레드가 없다면 새로 생성한다.       t = new Worker();       System.out.printf(\"[%s] - 스레드 생성!\\n\", t.getName());        // 그리고 즉시 실행한다.       // - 실행하더라도 스레드는 처음에 스스로 대기 상태로 갈 것인다.       t.start();        // 현재 main 스레드를 잠깐 멈추게 하여 새로 만든 스레드가 실행할 틈을 주자       // 그래야만 새로 만든 스레드가 실행하자마자 대기 상태로 간다.        try {         Thread.sleep(20);       } catch (Exception e) {         // sleep() 중에 발생한 예외는 무시한다.       }     } else {       // 스레드가 있다면, 스레드풀에서 한 개 꺼낸다.       // - 스레드풀에서 꺼낸 스레드는 현재 대기 상태이다.       t = workers.remove(0);       System.out.printf(\"[%s] - 스레드 꺼내서 재사용!\\n\", t.getName());     }      // 스레드를 깨워서 일을 시킨다.     // - 스레드에게 해야 할 작업을 배정하면 된다.     t.setTask(task);   } }   02) 클라이언트가 접속하면 요청 처리를 ThreadPool에게 맡긴다.     com.eomcs.pms.ServerApp 변경   stop 명령을 수행했을 때 서버가 완전히 종료하지 못한다.            왜냐하면 스레드풀에 실행 중인 스레드가 있기 때문이다.             static boolean stop = false;    // 스레드폴 준비   ThreadPool threadPool = new ThreadPool();    static Map&lt;String,Object&gt; context = new Hashtable&lt;&gt;();    List&lt;ApplicationContextListener&gt; listeners = new ArrayList&lt;&gt;();    public void addApplicationContextListener(ApplicationContextListener listener) {     listeners.add(listener);   }    public void removeApplicationContextListener(ApplicationContextListener listener) {     listeners.remove(listener);   }    private void notifyApplicationContextListenerOnServiceStarted() {     for (ApplicationContextListener listener : listeners) {       listener.contextInitialized(context);     }   }    private void notifyApplicationContextListenerOnServiceStopped() {     for (ApplicationContextListener listener : listeners) {       listener.contextDestroyed(context);     }   }    public void service(int port) {      notifyApplicationContextListenerOnServiceStarted();      try (ServerSocket serverSocket = new ServerSocket(port)) {       System.out.println(\"서버 실행 중...\");        while (true) {         Socket clientSocket = serverSocket.accept();          if (stop) {           break;         }          // 직접 스레드를 생성하는 것이 아니라 스레드풀에 작업을 맡긴다.         threadPool.execute(() -&gt; handleClient(clientSocket));       }      } catch (Exception e) {       e.printStackTrace();     }      notifyApplicationContextListenerOnServiceStopped();   }    public static void main(String[] args) {     ServerApp server = new ServerApp();      server.addApplicationContextListener(new AppInitListener());     server.addApplicationContextListener(new DataHandlerListener());     server.addApplicationContextListener(new RequestMappingListener());      server.service(8888);   } . . . }   03) 스레드풀 종료 기능을 추가     스레드풀이 관리하는 스레드들을 종료하는 shutdown() 메서드를 추가한다.   stop 명령이 들어오면 ThreadPool.shutdown() 을 통해 스레드를 종료시킨다.   public class ThreadPool {    // 스레드풀의 종료 상태   boolean stopping = false;    List&lt;Worker&gt; workers = new ArrayList&lt;&gt;();    class Worker extends Thread {      Runnable task;      public void setTask(Runnable task) {       this.task = task;        synchronized (this) {         this.notify();       }     }      @Override     public void run() {        synchronized (this) {         while (true) {           try {             System.out.printf(\"[%s] - 스레드 대기 중...\\n\", this.getName());             this.wait();              if (ThreadPool.this.stopping) { // 스레드풀이 종료 상태라면               // 스레드는 깨어나는 즉시 실행을 멈춘다.               break;             }              System.out.printf(\"[%s] - 스레드 작업 시작!\\n\", this.getName());           } catch (Exception e) {             System.out.printf(\"[%s] - 스레드 실행 중 오류 발생!\\n\", this.getName());             break;           }           try {             task.run();             System.out.printf(\"[%s] - 스레드 작업 종료!\\n\", this.getName());           } catch (Exception e) {             System.out.printf(\"[%s] - %s\\n\",                 this.getName(), e.getMessage());           } finally {             workers.add(this);             System.out.printf(\"[%s] - 스레드풀로 되돌아 감!\\n\", this.getName());           }         }       }     }   }    public void execute(Runnable task) {      // RuntimeException을 사용하면 public void execute(Runnable task) 에서     // 예외를 던지지 않아도 된다.     if (stopping) {       throw new RuntimeException(\"스레드풀이 종료 상태입니다.\");     }     Worker t;     if (workers.size() == 0) {       t = new Worker();       System.out.printf(\"[%s] - 스레드 생성!\\n\", t.getName());       t.start();       try {         Thread.sleep(20);       } catch (Exception e) {}     } else {       t = workers.remove(0);       System.out.printf(\"[%s] - 스레드 꺼내서 재사용!\\n\", t.getName());     }      t.setTask(task);   }    public void shutdown() {     try {       this.stopping = true;        while (!workers.isEmpty()) { // 스레드풀에 대기중인 스레드가 있다면         Worker worker = workers.remove(0); // 맨 앞의 스레드를 꺼내서         synchronized (worker) {           worker.notify(); // 스레드를 깨운다.           // 스레드는 깨어나면 stopping 상태에 따라 종료 여부를 결정하도록 되어있다.           // =&gt; worker 스레드 코드를 보라.         }       }        // 스레드풀에서 대기하지 않고 현재 작업을 수행하는 스레드가 있을 수 있다.       // 그 스레드가 작업을 끝낼 때까지 좀 기다리자.       Thread.sleep(2000);        // 다시 한 번 대기하고 있는 스레드를 종료해 보자.       while (!workers.isEmpty()) { // 스레드풀에 대기중인 스레드가 있다면         Worker worker = workers.remove(0); // 맨 앞 스레드를 꺼내서         synchronized (worker) {           worker.notify(); // 스레드를 깨운다.           // 스레드는 깨어나면 stopping 상태에 따라 종료 여부를 결정하도록 되어있다.           // =&gt; worker 스레드 코드를 보라.         }       }     } catch (Exception e) {       System.out.println(\"스레드풀을 종료하는 중에 예외 발생!\");       e.printStackTrace();     }   } }   public class ServerApp { . . .   public void service(int port) {      notifyApplicationContextListenerOnServiceStarted();      try (ServerSocket serverSocket = new ServerSocket(port)) {       System.out.println(\"서버 실행 중...\");        while (true) {         Socket clientSocket = serverSocket.accept();          if (stop) {           break;         }          threadPool.execute(() -&gt; handleClient(clientSocket));       }      } catch (Exception e) {       e.printStackTrace();     }      notifyApplicationContextListenerOnServiceStopped();      // 스레드풀을 종료한다.     threadPool.shutdown();   } . . . }   ","categories": ["pms"],
        "tags": [],
        "url": "http://localhost:4000/pms/mini-pms-36a/",
        "teaser": null
      },{
        "title": "mini-pms 36 b",
        "excerpt":"Server   36-b. 스레드풀을 이용하여 스레드를 재사용하기 : 자바에서 제공하는 스레드풀 사용하기   01) 기존의 ThreadPool 대신에 ExecutorService 를 사용한다.     util 패키지는 지운다.   public class ServerApp {   static boolean stop = false;    // 기존의 ThreadPool 대신 ExecutorService를 사용한다.   ExecutorService threadPool = Executors.newCachedThreadPool();    static Map&lt;String,Object&gt; context = new Hashtable&lt;&gt;();    List&lt;ApplicationContextListener&gt; listeners = new ArrayList&lt;&gt;();    public void addApplicationContextListener(ApplicationContextListener listener) {     listeners.add(listener);   }    public void removeApplicationContextListener(ApplicationContextListener listener) {     listeners.remove(listener);   }    private void notifyApplicationContextListenerOnServiceStarted() {     for (ApplicationContextListener listener : listeners) {       listener.contextInitialized(context);     }   }    private void notifyApplicationContextListenerOnServiceStopped() {     for (ApplicationContextListener listener : listeners) {       listener.contextDestroyed(context);     }   }    public void service(int port) {      notifyApplicationContextListenerOnServiceStarted();      try (ServerSocket serverSocket = new ServerSocket(port)) {       System.out.println(\"서버 실행 중...\");        while (true) {         Socket clientSocket = serverSocket.accept();          if (stop) {           break;         }          threadPool.execute(() -&gt; handleClient(clientSocket));       }      } catch (Exception e) {       e.printStackTrace();     }      notifyApplicationContextListenerOnServiceStopped();      threadPool.shutdown();      // 스레드를 종료시킨다.     try {       // 스레드풀의 모든 스레드가 종료될 때까지 기다린다.       if (!threadPool.awaitTermination(10, TimeUnit.SECONDS)) {         System.out.println(\"아직 종료 안된 작업이 있다.\");         System.out.println(\"남아 있는 작업의 강제 종료를 시도하겠다.\");         // =&gt; 만약 10초가 경과될 때까지 종료되지 않으면,         //    수행 중인 작업을 강제 종료하라고 지시하고,         //    대기 중인 작업은 취소한다.         threadPool.shutdownNow();          // 그리고 다시 작업이 종료될 때까지 기다린다.         if (!threadPool.awaitTermination(5, TimeUnit.SECONDS)) {           System.out.println(\"스레드풀의 강제 종료를 완료하지 못했다.\");         } else {           System.out.println(\"모든 작업을 강제 종료했다.\");         }       }     } catch (Exception e) {       System.out.println(\"스레드풀 종료 중 오류 발생!\");     }     System.out.println(\"서버 종료!\");   } . . . }  ","categories": ["pms"],
        "tags": [],
        "url": "http://localhost:4000/pms/mini-pms-36b/",
        "teaser": null
      },{
        "title": "2020-10-21 TIL",
        "excerpt":"MariaDB, MySQL   DBMS 접속 방식     원격(인터넷)을 이용해서 데이터 서버에 루트로 직접 접속하는 것은 불가능하다.   루트 암호를 알면 데이터 서버에 접속이 가능해서 데이터가 노출될 수 있다.   이런 것을 막기 위해서 vpn(가상 프로토콜)을 연결한다.            접속 가능한 아이피 어드레스를 지정한다.                    특정 사람만 데이터 서버에 접속하도록 한다.                            루트 암호는 차단시킨다.                                                   이론적으로 원격 루트 접속이 가능하게 하려면 등록을 해놔야 한다.   하지만 실무에서는 이것조차 허락하지 않는다.            데이터 서버에 어플리케이션 서버(서버 앱)을 설치하고 local PC에서 어플리케이션 서버로 접속 요청을 한다.                    그러면 어플리케이션 서버가 데이터 베이스에 접속을 해서 요청을 실행하고 결과를 리턴한다.                           운영체제     유닉스        https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Unix_history-simple.svg/1920px-Unix_history-simple.svg.png       service &lt;- windowsOS   Daemon &lt;- Unix / Linux            -&gt; Back-end 프로그램                    실행 상태를 .log 파일                           MySQL     클라이언트 프로그램   MySQL 설치 후 설정   mysql 서버에 접속하기  로컬 MySQL 서버에 접속     mysql -u root -p Enter password: 암호입력    원격 MySQL 서버에 접속     mysql -h 서버주소 -u root -p Enter password: 암호입력    mysql root 암호 변경     alter user ‘root’@’localhost’ identified by ‘1111’;    MySQL 사용자 추가     CREATE USER ‘사용자아이디’@’서버주소’ IDENTIFIED BY ‘암호’;    로컬에서만 접속할 수 있는 사용자를 만들기:     CREATE USER ‘study’@’localhost’ IDENTIFIED BY ‘1111’;   =&gt; 이 경우 stidu 사용자는 오직 로컬(서버를 실행하는 컴퓨터)에서만 접속 가능한다.   =&gt; 다른 컴퓨터에서 실행하는 MySQL 서버에 접속할 수 없다는 것을 의미한다.    원격에서만 접속할 수 있는 사용자를 만들기:     CREATE USER ‘study’@’%’ IDENTIFIED BY ‘1111’;   =&gt; 이 경우 study 사용자는 원력에서만 접속 가능하다.    MySQL 사용자 목록 조회     select user from 데이터베이스명.테이블명; select user from mysql.user;    MySQL 데이터베이스 생성     CREATE DATABASE 데이터베이스명   DEFAULT CHARACTER SET utf8   DEFAULT COLLATE utf8_general_ci;       CREATE DATABASE studydb   DEFAULT CHARACTER SET utf8   DEFAULT COLLATE utf8_general_ci;    MySQL 사용자에게 데이터베이스 사용 권한 부여     GRANT ALL ON 데이터베이스명.* TO ‘사용자아이디’@’서버주소’; GRANT ALL ON studydb.* TO ‘study’@’localhost’;    데이터베이스 목록 조회     show databases;    사용자 교체     quit    (프로그램 종료 후) mysql -u study -p   (다시 실행)    기본으로 사용할 데이터베이스 지정하기     use 데이터베이스명 use studydb;    데이터베이스의 전체 테이블 목록 조회     show tables;    MariaDB [(none)]&gt; select Host, User from mysql.user;  +———–+————-+ | Host      | User        | +———–+————-+ | %         | study       |  &lt;- 원격 스터디 사용자 | localhost | mariadb.sys | | localhost | root        | | localhost | rsh         | | localhost | study       |  &lt;- 로컬 스터디 사용자 +———–+————-+ 5 rows in set (0.007 sec)      mysql 파일에서 user라는 테이블의 Host, User 라는 항목을 보여달라.   설정이 완료되면 루트 사용자는 종료하고 스터디 사용자를 사용한다.     MariaDB [(none)]&gt; show databases; +——————–+ | Database           | +——————–+ | information_schema | | studydb            | +——————–+ 2 rows in set (0.001 sec)   SQL     dbms에 보내는 명령   DDL : Data Definition Language            데이터를 저장할 구조(테이블)를 준비                    table, view, function, trigger, procedure, index (DBMS 객체) 관리하는 명령                           DML : Data Manipulation Language            Data insert, update, delete 명령           DQL : Data Query Language            select 명령 (데이터 조회 명령)           https://mariadb.com/kb/en/documentation/   DDL     데이터베이스(database) = 스키마(schema)   테이블(table)   뷰(view)   트리거(trigger)            특정 조건에서 자동으로 호출되는 함수       특정 조건? SQL 실행 전/후 등       OOP 디자인 패턴에서 옵저버에 해당한다.           함수(function)   프로시저(procedure)        인덱스(index)            MariaDB [(none)]&gt; create table test01 (   -&gt;     name varchar(50) not null,   -&gt;     kor int not null,   -&gt;     eng int not null,   -&gt;     math int not null,   -&gt;     sum int not null,   -&gt;     aver float not null   -&gt;   ); ERROR 1046 (3D000): No database selected            MariaDB [(none)]&gt; show databases; +——————–+ | Database           | +——————–+ | information_schema | | mysql              | | performance_schema | | studydb            | +——————–+ 4 rows in set (0.002 sec)            MariaDB [(none)]&gt; create table studydb.test01 (   -&gt;     name varchar(50) not null,   -&gt;     kor int not null,   -&gt;     eng int not null,   -&gt;     math int not null,   -&gt;     sum int not null,   -&gt;     aver float not null   -&gt;   ); Query OK, 0 rows affected (0.031 sec)            MariaDB [(none)]&gt; drop table studydb.test01; &lt;- 삭제 Query OK, 0 rows affected (0.008 sec)       MariaDB [(none)]&gt; use studydb; &lt;- 어떤 db를 사용할 지 설정 Database changed   테이블 생성     MariaDB [studydb]&gt; create table test01 ( &lt;- 테이블을 만듬   -&gt;     name varchar(50) not null,   -&gt;     kor int not null,   -&gt;     eng int not null,   -&gt;     math int not null,   -&gt;     sum int not null,   -&gt;     aver float not null   -&gt;   ); Query OK, 0 rows affected (0.018 sec)   테이블 확인     MariaDB [studydb]&gt; show tables; +——————-+ | Tables_in_studydb | +——————-+ | test01            | +——————-+ 1 row in set (0.000 sec)   테이블 정보 보기          MariaDB [studydb]&gt; describe test01; +——-+————-+——+—–+———+——-+ | Field | Type        | Null | Key | Default | Extra | +——-+————-+——+—–+———+——-+ | name  | varchar(50) | NO   |     | NULL    |       | | kor   | int(11)     | NO   |     | NULL    |       | | eng   | int(11)     | NO   |     | NULL    |       | | math  | int(11)     | NO   |     | NULL    |       | | sum   | int(11)     | NO   |     | NULL    |       | | aver  | float       | NO   |     | NULL    |       | +——-+————-+——+—–+———+——-+ 6 rows in set (0.003 sec)            MariaDB [studydb]&gt; desc test01; &lt;- 줄임말 +——-+————-+——+—–+———+——-+ | Field | Type        | Null | Key | Default | Extra | +——-+————-+——+—–+———+——-+ | name  | varchar(50) | NO   |     | NULL    |       | | kor   | int(11)     | NO   |     | NULL    |       | | eng   | int(11)     | NO   |     | NULL    |       | | math  | int(11)     | NO   |     | NULL    |       | | sum   | int(11)     | NO   |     | NULL    |       | | aver  | float       | NO   |     | NULL    |       | +——-+————-+——+—–+———+——-+ 6 rows in set (0.003 sec)       테이블 삭제          MariaDB [studydb]&gt; drop table test01; Query OK, 0 rows affected (0.003 sec)            MariaDB [studydb]&gt; show tables; &lt;- 테이블을 보면 없다고 나온다. Empty set (0.000 sec)       null 허용과 not null (무결성 제약 조건)          MariaDB [studydb]&gt; create table test1(   -&gt;     no int not null,    -&gt;     name varchar(20)   -&gt;   ); Query OK, 0 rows affected (0.021 sec)            MariaDB [studydb]&gt; desc test1; +——-+————-+——+—–+———+——-+ | Field | Type        | Null | Key | Default | Extra | +——-+————-+——+—–+———+——-+ | no    | int(11)     | NO   |     | NULL    |       | | name  | varchar(20) | YES  |     | NULL    |       | +——-+————-+——+—–+———+——-+ 2 rows in set (0.003 sec)            MariaDB [studydb]&gt; insert into test1(no, name) values(1, ‘aaa’); Query OK, 1 row affected (0.001 sec)            MariaDB [studydb]&gt; insert into test1(no, name) values(null, ‘bbb’); ERROR 1048 (23000): Column ‘no’ cannot be null            MariaDB [studydb]&gt; insert into test1(no, name) values(3, null); Query OK, 1 row affected (0.001 sec)            MariaDB [studydb]&gt; select * from test1; +—-+——+ | no | name | +—-+——+ |  1 | aaa  | |  3 | NULL | +—-+——+ 2 rows in set (0.000 sec)       기본값 지정          MariaDB [studydb]&gt; create table test1(   -&gt;     no int not null,   -&gt;     name varchar(20) default ‘noname’,   -&gt;     age int default 20   -&gt;   ); Query OK, 0 rows affected (0.018 sec)            MariaDB [studydb]&gt; insert into test1(no, name, age) values(1, ‘aaa’, 30); Query OK, 1 row affected (0.002 sec)            MariaDB [studydb]&gt; select * from test1; +—-+——+——+ | no | name | age  | +—-+——+——+ |  1 | aaa  |   30 | +—-+——+——+ 1 row in set (0.000 sec)            MariaDB [studydb]&gt; insert into test1(name, age) values(‘aaa’, 30); ERROR 1364 (HY000): Field ‘no’ doesn’t have a default value            MariaDB [studydb]&gt; insert into test1(no, age) values(3, 30); Query OK, 1 row affected (0.002 sec)            MariaDB [studydb]&gt; insert into test1(no, name) values(4, ‘ddd’); Query OK, 1 row affected (0.002 sec)            MariaDB [studydb]&gt; insert into test1(no) values(5); Query OK, 1 row affected (0.001 sec)            MariaDB [studydb]&gt; select * from test1; +—-+——–+——+ | no | name   | age  | +—-+——–+——+ |  1 | aaa    |   30 | |  3 | noname |   30 | |  4 | ddd    |   20 | |  5 | noname |   20 | +—-+——–+——+ 4 rows in set (0.000 sec)       컬럼에 디폴트 옵션이 있는 경우,     컬럼 값을 생략하면 디폴트 옵션으로 지정한 값이 사용된다.        컬럼 값을 null로 지정하면 기본 값이 사용되지 않는다.            MariaDB [studydb]&gt; insert into test1(no, age, name) values(6, null, null); Query OK, 1 row affected (0.002 sec)       MariaDB [studydb]&gt; select * from test1; +—-+——–+——+ | no | name   | age  | +—-+——–+——+ |  1 | aaa    |   30 | |  3 | noname |   30 | |  4 | ddd    |   20 | |  5 | noname |   20 | |  6 | NULL   | NULL | +—-+——–+——+ 5 rows in set (0.000 sec)   컬럼 타입     https://mariadb.com/kb/en/data-types/   int            4바이트 크기의 정수 값 저장       기타 tinyint(1), smallint(2), mediumint(3), bigint(8)           float            부동소수점 저장           numeric = decimal            전체 자릿수와 소수점 이하의 자릿수를 정밀하게 지정할 수 있다.       numeric(n,e) : 전체 n 자릿수 중에서 소수점은 e 자릿수다.                numeric : numeric(10, 0) 과 같다.                   TINYINT(M) [ 옵션 UNSIGNED , ZEROFILL ] ★★       정수형으로 총 1Byte 저장공간을 차지하는 데이터 타입으로 -128에서 127 사이의 숫자를 저장하기 위한 데이터 타입이다. UNSIGNED 옵션을 적용하면 0에서 255까지의 숫자를 저장한다.                       SMALLINT(M) [ 옵션 UNSIGNED , ZEROFILL ]       정수형으로 총 2Byte 저장공간을 차지하는 데이터 타입으로 -32768에서 32767 사이의 숫자를 저장하기 위한 데이터 타입이다. UNSIGNED 옵션을 적용하면 0에서 65535까지의 숫자를 저장한다.                       MEDIUMINT(M) [ 옵션 UNSIGNED , ZEROFILL ]       정수형으로 총 3Byte 저장공간을 차지하는 데이터 타입으로 -8388608에서 8388607사이의 숫자를 저장하기 위한 데이터 타입이다. UNSIGNED 옵션을 적용하면 0에서 16777215까지의 숫자를 저장한다.                       INT(M) [ 옵션 UNSIGNED , ZEROFILL ] ★★★       정수형으로 총 4Byte 저장공간을 차지하는 데이터 타입으로 INTEGER 라고도 사용한다. -2147483648에서 2147483647 사이의 숫자를 저장하기 위한 데이터 타입으로 UNSIGNED 옵션을 적용하면 0에서 4294967295까지의 숫자를 저장한다.           char(n)            최대 n개의 문자를 저장.       0 &lt;= n &lt;= 255       고정 크기를 갖는다.       한 문자를 저장하더라도 n자를 저장할 크기를 사용한다.       메모리 크기가 고정되어서 검색할 때 빠르다.           varchar(n)            최대 n개의 문자를 저장.       0 ~ 65535 바이트 크기를 갖는다.       n 값은 문자집합에 따라 최대 값이 다르다.       한 문자에 1 바이트를 사용하는 ISO-8859-n 문자집합인 경우, 최대 65535 이다.       만약 UTF-8로 지정된 경우 n은 최대 21844까지 지정할 수 있다. (문자 크기인지 바이트 크기인지 확인)       UTF-8로 저장해야 한글을 사용할 수 있다. (국제표준 사용)       가변 크기를 갖는다.       한 문자를 저장하면 한 문자 만큼 크기의 메모리를 차지한다.       메모리 크기가 가변적이라서 데이터 위치를 찾을 때 시간이 오래 걸린다. 그래서 검색할 때 위치를 계산해야 하기 때문에 검색 시 느리다.       빈 문자열도 값이다. null이 아니다.       char 는 값을 저장하나 안하나 5칸 차지 = 크기가 균등 = 찾는 속도가 빠름                    우편번호나 ISBN처럼 크기가 정해진 데이터를 저장할 때 쓰기도 한다                       varchar 는 값에 따라 크기가 다르다 = 쓰지 않으면 메모리를 적게 차지 = 찾는 속도가 느림           select * from test1 where c1=’abc’;            DBMS 중에는 고정 크기인 컬럼의 값을 비교할 때 빈자리까지 검사하는 경우도 있다. (ex : 오라클)       즉 c1=’abc’에서는 데이터를 찾지 못하고, c1=’abc  ‘여야만 데이터를 찾는 경우가 있다.       그러나 mysql은 고정크기 컬럼이더라도 빈자리를 무시하고 데이터를 찾는다. (ex : mariaDB)           text(65535), mediumtext(약 1.6MB), longtext(약 2GB)            긴 텍스트를 저장할 때 사용하는 컬럼 타입이다.       오라클의 경우 long 타입과 CLOB(character large object) 타입이 있다.           date            날짜 정보를 저장할 때 사용한다.       년,월,일 정보를 저장한다.       오라클의 경우 날짜 뿐만 아니라 시간 정보도 저장한다.       mariadb는 날짜만 저장한다.           time            시간 정보를 저장할 때 사용한다.       시, 분, 초 정보를 저장한다.           datetime            날짜와 시간 정보를 함께 저장할 때 사용한다.           불린 타입            보통 true, false를 의미하는 값을 저장할 때는 정수 1 또는 0으로 표현한다.       또는 문자로 Y 또는 N으로 표현하기도 한다.       회원 탈퇴를 하면 게시글이 다 지워지지 않도록 컬럼에 불린 타입을 사용하여 회원이 가입 상태인지 탈퇴 상태인지 표시한다.       ㄱ 회원이 게시글을 올리고 ㄴ, ㄷ, ㄹ 회원이 댓글을 달았을 때 ㄱ 회원이 탈퇴하면 게시글이 사라진다. 하지만 ㄴ, ㄷ, ㄹ 회원이 달아놓은 댓글은 그대로 남아있다.       불린 타입에는 true, false, 문자 ‘1’, ‘0’, 숫자 1, 0을 집어넣을 수 있다.       불린 타입으로 지정하면 내부적으로는 컬럼을 생성할 때 tinyint(1)로 설정한다.                    숫자 컬럼인 경우 값을 설정할 때 문자로 표현할 수 있다.           즉, 문자열을 숫자로 바꿀 수 있으면 된다.                           키 컬럼 지정     테이블:            no, name, email, id, pwd, jumin, tel, postno, basic_addr, gender, fax           key vs candidate key            key                    데이터를 구분할 대 사용하는 컬럼들의 집합           예)                            {email}, {jumin}, {id}, {name, tel}, {tel, basic_addr, gender, name}, {name, jumin}, {email, id} {id, name, email} …                                               candidate key (후보키 = 최소키)                    key 들 중에서 최소 항목으로 줄인 키           예)                            {jumin}, {email}, {id}, {name, tel}                                                   alternate key vs primary key            primary key (주 키)                    candidate key 중에서 DBMS 관리자가 사용하기로 결정한 키           예) DBMS 관리자가 id 컬럼의 값을 데이터를 구분하는 키로 사용하기로 결정했다면           주 키는 {id} 가 된다.                            테이블의 데이터를 구분할 때 사용하는 컬럼들이다.               줄여서 PK라고 표시한다.               PK 컬럼을 지정하지 않으면 데이터가 중복될 수 있다.                                   주 키로 선택되지 않은 모든 candidate key는 alternate key 가 된다.           pk는 not null 이다.           pk를 여러개 지정했을 때 pk 들이 다 똑같지 않으면 저장 가능하다. 하나라도 값이 다르면 오류가 생기지 않는다.                            두 개 이상의 컬럼을 묶어서 PK로 선언하고 싶다면 각 컬럼에 대해서 개별적으로 PK를 지정해서는 안된다.               여러 개의 컬럼을 묶어서 PK로 지정하려면 별도의 문법을 사용해야 한다.                                    constraint 제약조건이름_pk primary key(컬럼명, 컬럼명, …)                                                                   여러 개의 컬럼을 묶어서 PK로 사용하면 데이터를 다루기가 불편하다. 즉 데이터를 찾을 때 마다 name과 age 값을 지정해야 한다.           그래서 실무에서는 이런 경우 ‘학번’처럼 임의의 값을 저장하는 컬럼을 만들어 PK로 사용한다.           학번이 중복되지 않는다면 동일 데이터를 저장할 수 있게 되는 경우 사용하는 문법이 uniuqe이다.                            K는 아니지만 PK처럼 중복을 허락하지 않는 컬럼을 지정할 때 사용한다.               그래서 PK를 대신해서 사용할 수 있는 key라고 해서 “대안키(alternate key)”라고 부른다.               unique = alternate key(대안키)                                    no int primary key, constraint test1_uk unique (name, age)                   constraint test1_pk primary key(no), constraint test1_uk unique (name, age)                                                                               alternate key (대안키)                    candidate key 중에서 primary key로 선택된 키를 제외한 나머지 키           비록 primary key는 아니지만 primary key 처럼 데이터를 구분하는 용도로 대신 사용할 수 있다고 해서 대안 키(alternate key)라 부른다.                           artificial key (인공키)            primary key로 사용하기에 적절한 컬럼을 찾을 수 없다면       예) 게시글 : 제목, 내용, 작성자, 등록일, 조회수                    이런 경우에 key로 사용할 컬럼을 추가한다.           보통 일련번호를 저장할 정수 타입의 컬럼을 추가한다.                            예) 게시글 : 게시글 번호                                   대부분의 SNS 서비스들은 일련의 번호를 primary key로 사용한다.           왜?                            회원 탈퇴의 경우                                    아이디도 제거한다.                   아이디를 지우면 그 아이디와 연결된 게시글을 지워야 한다.                   그런데 회원 아이디 대신 일련 번호를 사용하면                   그 회원이 쓴 게시글은 일련 번호와 묶인다.                   따라서 아이디가 삭제되더라도 해당 글은 계속 유효하게 처리할 수 있다.                                               이메일 변경,                                    primary key 값은 다른 데이터에서 사용하기 때문에,                                            예) 게시글을 젖아할 때 회원 이메일을 저장한다고 가정하자.                                                           pk 값을 변경하면 그 값을 사용한 모든 데이터에 영향을 끼친다.                   그래서 pk 값을 다른 데이터에서 사용한 경우, DBMS는 pk 값을 변경하지 못하도록 통제한다.                   이렇게 값이 변경될 수 있는 경우에는 pk로 사용하지 말라                   대신 회원 번호와 같은 임의의 키(인공 키)를 만들어 사용하는 것이 좋다.                                                                               실제적으로는 인공키를 주로 사용한다.           ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL201021/",
        "teaser": null
      },{
        "title": "2020-10-22 TIL",
        "excerpt":"챗봇 기반 방탈출 게임 만들기      if 문 중첩이 최선인가.   리팩토링은 아직.   while 문을 사용해서 반복을 시키는 것을 조금 더 깔끔하게 할 수 없나.  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL201022/",
        "teaser": null
      },{
        "title": "2020-10-23 TIL",
        "excerpt":"커밋 메시지 스타일 가이드           https://udacity.github.io/git-styleguide/            type: subject       body       footer            The Type The type is contained within the title and can be one of these types:       feat: a new feature fix: a bug fix docs: changes to documentation style: formatting, missing semi colons, etc; no code change refactor: refactoring production code test: adding tests, refactoring test; no production code change chore: updating build tasks, package manager configs, etc; no production code change   그레이들 빌드     해당 프로젝트 폴더에 가서 gradle build 아니면 gradle run  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL201023/",
        "teaser": null
      },{
        "title": "2020-10-26 TIL",
        "excerpt":"stateful, stateless   Stateless 의 문제점     한 번 연결하고 응답하고 나면 연결이 끊기는데 어떻게 클라이언트를 특정할 수 있는지?   DataInput/OutputStram     데이터를 타입 별로 받아들이기 좋다.   ex04 stateful     메인 스레드가 모든 일을 다 하기 때문에 하나의 클라이언트와 연결되면 다른 클라이언트는 accept() 에서 기다리고 있어야 한다.   처음 연결된 클라이언트가 종료되고 나면 두번째로 연결된 클라이언트에 응답을 흔다.   ex04 stateful 2     계산 결과를 서버에 저장해둔다.   메인 스레드가 혼자 일을 한다.   ex04 stateful 3     스레드를 사용해서 동시에 여러 클라이언트의 요청에 응답할 수 있다.   소켓을 통해서 다이렉트로 어드레스를 받아오는 것보다 주소를 다루는 별도의 클래스를 분리시킨 것이 InetSocketAddress 이다.            InetSocketAddress 객체를 통해 주소화 포트번호가 담긴 객체를 얻은 다음에 거기서 뽑아서 쓰는 것이 확장성이 더 좋다.           메인 스레드는 클라이언트 요청이 들어오면 accept 를 통해 socket 객체를 만들어서 새로운 스레드에게 일을 시킨다.   run() 메소드를 실행하고 processRequest를 호출해서 클라이언트의 요청을 해결하는 동안 만들어지는 모든 로컬 변수는 각 스레드에서 생성되는 stack 메모리에 저장된다.   ex04 stateless     서버와의 연결을 최소한으로 하기 위해서 클라이언트에 값을 다 입력하고 나서 연산을 처리할 때만(엔터를 칠 때) 연결한다.   버퍼 스트림을 쓸 때는 out.flush()를 꼭 사용해야 한다.   스테이트리스는 둘 사이의 요청 응답이 끝나면 연결을 끊는다.   ex04 stateless 2     stateless 에서 클라이언트를 구분하고 작업 결과를 유지하는 방법   ID 를 Map 에 등록하고 클라이언트가 서버에서 반환된 ID 를 저장해둔다.        ID와 함께 저장된 result 값을 다음 연산에 사용한다.       쿠키 : 웹 서버가 웹 브라우저에게 보내는 정보(객체), 인증 정보를 웹 브라우저에 저장하고 사용자가 요청을 할 때 그 정보를 함께 보내서 사용자를 식별할 수 있도록 도와준다.   세션 : 로그인, 사용자 닉네임, 접속 시간 등 서버가 알아야 할 정보를 저장해 놓는다. 만료가 되었다는 것은 세션에 지정된 시간이 종료되었다는 것을 뜻하는 듯하다.   sql (eomcs-docs-sql)   DDL(Data Definition Language)  DB 객체(테이블, 뷰, 함수, 트리거 등)를 생성, 변경, 삭제하는 SQL 명령이다.   sql     색인표에 특정 컬럼의 값을 정렬시키는 문법이 인덱스이다.   색인표에 자료를 정렬해두고 찾으면            장점 : 훨씬 빠른 속도로 찾을 수 있게 된다.       단점 : 파일의 크기가 커진다. (하드디스크 메모리를 사용한다.)           기준 항목에 대해 정렬하는 것이 색인표이다.   새 데이터를 추가하거나 데이터를 변경하면 색인표도 갱신해야 한다.            추가, 변경, 삭제 시 실행 속도가 느리다.       대신 검색 속도가 빠르다.           컬럼 값 자동 증가 (auto-increment)     숫자 타입의 PK 컬럼인 경우 값을 1씩 자동 증가시킬 수 있다.   즉, 데이터를 입력할 때 해당 컬럼의 값을 넣지 않아도 자동으로 증가된다.   단, 삭제를 해서 중간에 비어있는 번호는 다시 채우지 않는다. 증가된 번호는 계속 앞으로 증가할 뿐이다.   프라이머리에 낫널 컬럼이라도 오토-인크리먼트라면 입력이 가능하다.   마리아db는 인서트를 하다가 실패하면 번호가 올라가지 않지만, 다른 db는 인서트를 하다가 실패하면 번호가 자동으로 증가될 때가 있다.   뷰 (view)     프로젝션 : 어떤 컬럼 값을 꺼낼 지 선택하는 것.   셀렉션 : 데이터(row) 를 선택하는 것.   웨어 : 레코드를 선택하는 것.   뷰로 만들어진 테이블은 가상 테이블이다.   Last login: Mon Oct 26 14:02:02 on ttys000  rsh@rsh  ~  mysql -u study -p Enter password:  Welcome to the MariaDB monitor.  Commands end with ; or \\g. Your MariaDB connection id is 3 Server version: 10.5.6-MariaDB Homebrew  Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.  Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.  MariaDB [(none)]&gt; show databases; +--------------------+ | Database           | +--------------------+ | information_schema | | studydb            | +--------------------+ 2 rows in set (0.005 sec)  MariaDB [(none)]&gt; use studydb Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A  Database changed MariaDB [studydb]&gt; show tables; +-------------------+ | Tables_in_studydb | +-------------------+ | test1             | +-------------------+ 1 row in set (0.000 sec)  MariaDB [studydb]&gt; drop table test1; Query OK, 0 rows affected (0.009 sec)  MariaDB [studydb]&gt; show tables; Empty set (0.000 sec)  MariaDB [studydb]&gt; create table test1(     -&gt;   no int primary key,     -&gt;   name varchar(20),     -&gt;   age int,     -&gt;   kor int,     -&gt;   eng int,     -&gt;   math int,     -&gt;   constraint test1_uk unique (name, age),     -&gt;   fulltext index test1_name_idx (name)     -&gt; ); Query OK, 0 rows affected (0.033 sec)  MariaDB [studydb]&gt; insert into test1(no,name,age,kor,eng,math) values(1,'aaa',20,80,80,80); Query OK, 1 row affected (0.004 sec)  MariaDB [studydb]&gt; insert into test1(no,name,age,kor,eng,math) values(2,'bbb',21,90,80,80); Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; insert into test1(no,name,age,kor,eng,math) values(3,'ccc',20,80,80,80); Query OK, 1 row affected (0.000 sec)  MariaDB [studydb]&gt; insert into test1(no,name,age,kor,eng,math) values(4,'ddd',22,90,80,80); Query OK, 1 row affected (0.000 sec)  MariaDB [studydb]&gt; insert into test1(no,name,age,kor,eng,math) values(5,'eee',20,80,80,80);  Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; select * from test1; +----+------+------+------+------+------+ | no | name | age  | kor  | eng  | math | +----+------+------+------+------+------+ |  1 | aaa  |   20 |   80 |   80 |   80 | |  2 | bbb  |   21 |   90 |   80 |   80 | |  3 | ccc  |   20 |   80 |   80 |   80 | |  4 | ddd  |   22 |   90 |   80 |   80 | |  5 | eee  |   20 |   80 |   80 |   80 | +----+------+------+------+------+------+ 5 rows in set (0.002 sec)  MariaDB [studydb]&gt; select * from test1 where name = 'ccc'; +----+------+------+------+------+------+ | no | name | age  | kor  | eng  | math | +----+------+------+------+------+------+ |  3 | ccc  |   20 |   80 |   80 |   80 | +----+------+------+------+------+------+ 1 row in set (0.006 sec)  MariaDB [studydb]&gt; drop table test1; Query OK, 0 rows affected (0.016 sec)  MariaDB [studydb]&gt; create table test1 (     -&gt;   name varchar(3),     -&gt;   kor int,     -&gt;   eng int,     -&gt;   math int,     -&gt;   sum int,     -&gt;   aver int     -&gt; ); Query OK, 0 rows affected (0.012 sec)  MariaDB [studydb]&gt; desc test1; +-------+------------+------+-----+---------+-------+ | Field | Type       | Null | Key | Default | Extra | +-------+------------+------+-----+---------+-------+ | name  | varchar(3) | YES  |     | NULL    |       | | kor   | int(11)    | YES  |     | NULL    |       | | eng   | int(11)    | YES  |     | NULL    |       | | math  | int(11)    | YES  |     | NULL    |       | | sum   | int(11)    | YES  |     | NULL    |       | | aver  | int(11)    | YES  |     | NULL    |       | +-------+------------+------+-----+---------+-------+ 6 rows in set (0.006 sec)  MariaDB [studydb]&gt; alter table test1     -&gt;   add column no int; Query OK, 0 rows affected (0.021 sec) Records: 0  Duplicates: 0  Warnings: 0  MariaDB [studydb]&gt; desc test1; +-------+------------+------+-----+---------+-------+ | Field | Type       | Null | Key | Default | Extra | +-------+------------+------+-----+---------+-------+ | name  | varchar(3) | YES  |     | NULL    |       | | kor   | int(11)    | YES  |     | NULL    |       | | eng   | int(11)    | YES  |     | NULL    |       | | math  | int(11)    | YES  |     | NULL    |       | | sum   | int(11)    | YES  |     | NULL    |       | | aver  | int(11)    | YES  |     | NULL    |       | | no    | int(11)    | YES  |     | NULL    |       | +-------+------------+------+-----+---------+-------+ 7 rows in set (0.003 sec)  MariaDB [studydb]&gt; alter table test1     -&gt;   add column age int;  Query OK, 0 rows affected (0.020 sec) Records: 0  Duplicates: 0  Warnings: 0  MariaDB [studydb]&gt; desc test1; +-------+------------+------+-----+---------+-------+ | Field | Type       | Null | Key | Default | Extra | +-------+------------+------+-----+---------+-------+ | name  | varchar(3) | YES  |     | NULL    |       | | kor   | int(11)    | YES  |     | NULL    |       | | eng   | int(11)    | YES  |     | NULL    |       | | math  | int(11)    | YES  |     | NULL    |       | | sum   | int(11)    | YES  |     | NULL    |       | | aver  | int(11)    | YES  |     | NULL    |       | | no    | int(11)    | YES  |     | NULL    |       | | age   | int(11)    | YES  |     | NULL    |       | +-------+------------+------+-----+---------+-------+ 8 rows in set (0.004 sec)  MariaDB [studydb]&gt; alter table test1     -&gt;   add column no2 int,     -&gt;   add column age2 int;   Query OK, 0 rows affected (0.014 sec) Records: 0  Duplicates: 0  Warnings: 0  MariaDB [studydb]&gt; desc test1; +-------+------------+------+-----+---------+-------+ | Field | Type       | Null | Key | Default | Extra | +-------+------------+------+-----+---------+-------+ | name  | varchar(3) | YES  |     | NULL    |       | | kor   | int(11)    | YES  |     | NULL    |       | | eng   | int(11)    | YES  |     | NULL    |       | | math  | int(11)    | YES  |     | NULL    |       | | sum   | int(11)    | YES  |     | NULL    |       | | aver  | int(11)    | YES  |     | NULL    |       | | no    | int(11)    | YES  |     | NULL    |       | | age   | int(11)    | YES  |     | NULL    |       | | no2   | int(11)    | YES  |     | NULL    |       | | age2  | int(11)    | YES  |     | NULL    |       | +-------+------------+------+-----+---------+-------+ 10 rows in set (0.003 sec)  MariaDB [studydb]&gt; alter table test1     -&gt;   add constraint test1_pk primary key (no),     -&gt;   add constraint test1_uk unique (name, age),     -&gt;   add fulltext index test1_name_idx (name); Query OK, 0 rows affected, 1 warning (0.041 sec) Records: 0  Duplicates: 0  Warnings: 1  MariaDB [studydb]&gt; desc test1; +-------+------------+------+-----+---------+-------+ | Field | Type       | Null | Key | Default | Extra | +-------+------------+------+-----+---------+-------+ | name  | varchar(3) | YES  | MUL | NULL    |       | | kor   | int(11)    | YES  |     | NULL    |       | | eng   | int(11)    | YES  |     | NULL    |       | | math  | int(11)    | YES  |     | NULL    |       | | sum   | int(11)    | YES  |     | NULL    |       | | aver  | int(11)    | YES  |     | NULL    |       | | no    | int(11)    | NO   | PRI | NULL    |       | | age   | int(11)    | YES  |     | NULL    |       | | no2   | int(11)    | YES  |     | NULL    |       | | age2  | int(11)    | YES  |     | NULL    |       | +-------+------------+------+-----+---------+-------+ 10 rows in set (0.004 sec)  MariaDB [studydb]&gt; alter table test1     -&gt;   modify column name varchar(20) not null,     -&gt;   modify column age int not null,     -&gt;   modify column kor int not null,     -&gt;   modify column eng int not null,     -&gt;   modify column math int not null,     -&gt;   modify column sum int not null,     -&gt;   modify column aver float not null; Query OK, 0 rows affected (0.051 sec)               Records: 0  Duplicates: 0  Warnings: 0  MariaDB [studydb]&gt; desc test1; +-------+-------------+------+-----+---------+-------+ | Field | Type        | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | name  | varchar(20) | NO   | MUL | NULL    |       | | kor   | int(11)     | NO   |     | NULL    |       | | eng   | int(11)     | NO   |     | NULL    |       | | math  | int(11)     | NO   |     | NULL    |       | | sum   | int(11)     | NO   |     | NULL    |       | | aver  | float       | NO   |     | NULL    |       | | no    | int(11)     | NO   | PRI | NULL    |       | | age   | int(11)     | NO   |     | NULL    |       | | no2   | int(11)     | YES  |     | NULL    |       | | age2  | int(11)     | YES  |     | NULL    |       | +-------+-------------+------+-----+---------+-------+ 10 rows in set (0.003 sec)  MariaDB [studydb]&gt; insert into test1(no,name,age,kor,eng,math,sum,aver)     -&gt;   values(1,'aaa',20,100,100,100,300,100); Query OK, 1 row affected (0.002 sec)  MariaDB [studydb]&gt; insert into test1(no,name,age,kor,eng,math,sum,aver)     -&gt;   values(2,'bbb',21,100,100,100,300,100); Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; desc test1; +-------+-------------+------+-----+---------+-------+ | Field | Type        | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | name  | varchar(20) | NO   | MUL | NULL    |       | | kor   | int(11)     | NO   |     | NULL    |       | | eng   | int(11)     | NO   |     | NULL    |       | | math  | int(11)     | NO   |     | NULL    |       | | sum   | int(11)     | NO   |     | NULL    |       | | aver  | float       | NO   |     | NULL    |       | | no    | int(11)     | NO   | PRI | NULL    |       | | age   | int(11)     | NO   |     | NULL    |       | | no2   | int(11)     | YES  |     | NULL    |       | | age2  | int(11)     | YES  |     | NULL    |       | +-------+-------------+------+-----+---------+-------+ 10 rows in set (0.003 sec)  MariaDB [studydb]&gt; select * from test1; +------+-----+-----+------+-----+------+----+-----+------+------+ | name | kor | eng | math | sum | aver | no | age | no2  | age2 | +------+-----+-----+------+-----+------+----+-----+------+------+ | aaa  | 100 | 100 |  100 | 300 |  100 |  1 |  20 | NULL | NULL | | bbb  | 100 | 100 |  100 | 300 |  100 |  2 |  21 | NULL | NULL | +------+-----+-----+------+-----+------+----+-----+------+------+ 2 rows in set (0.001 sec)  MariaDB [studydb]&gt; insert into test1(no,name,age,kor,eng,math,sum,aver)     -&gt;   values(3,'bbb',21,100,100,100,300,100);  ERROR 1062 (23000): Duplicate entry 'bbb-21' for key 'test1_uk' MariaDB [studydb]&gt; drop table test1; Query OK, 0 rows affected (0.010 sec)  MariaDB [studydb]&gt; create table test1(     -&gt;   no int not null,     -&gt;   name varchar(20) not null     -&gt; ); Query OK, 0 rows affected (0.016 sec)  MariaDB [studydb]&gt; alter table test1     -&gt;   modify column no int not null auto_increment; ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key MariaDB [studydb]&gt; alter table test1     -&gt;   add constraint primary key (no); /* 일단 no를 pk로 지정한다.*/ Query OK, 0 rows affected (0.016 sec) Records: 0  Duplicates: 0  Warnings: 0  MariaDB [studydb]&gt; alter table test1     -&gt;      -&gt; ; Query OK, 0 rows affected (0.001 sec) Records: 0  Duplicates: 0  Warnings: 0  MariaDB [studydb]&gt; alter table test1     -&gt;   modify column no int not null auto_increment; Query OK, 0 rows affected (0.034 sec)               Records: 0  Duplicates: 0  Warnings: 0  MariaDB [studydb]&gt; desc test1; +-------+-------------+------+-----+---------+----------------+ | Field | Type        | Null | Key | Default | Extra          | +-------+-------------+------+-----+---------+----------------+ | no    | int(11)     | NO   | PRI | NULL    | auto_increment | | name  | varchar(20) | NO   |     | NULL    |                | +-------+-------------+------+-----+---------+----------------+ 2 rows in set (0.005 sec)  MariaDB [studydb]&gt; insert into test1(no, name) values(1, 'xxx'); Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; select * from test1; +----+------+ | no | name | +----+------+ |  1 | xxx  | +----+------+ 1 row in set (0.000 sec)  MariaDB [studydb]&gt; insert into test1(name) values('aaa'); Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; select * from test1; +----+------+ | no | name | +----+------+ |  1 | xxx  | |  2 | aaa  | +----+------+ 2 rows in set (0.000 sec)  MariaDB [studydb]&gt; insert into test1(no, name) values(100, 'yyy'); Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; select * from test1; +-----+------+ | no  | name | +-----+------+ |   1 | xxx  | |   2 | aaa  | | 100 | yyy  | +-----+------+ 3 rows in set (0.000 sec)  MariaDB [studydb]&gt; insert into test1(name) values('bbb'); Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; select * from test1; +-----+------+ | no  | name | +-----+------+ |   1 | xxx  | |   2 | aaa  | | 100 | yyy  | | 101 | bbb  | +-----+------+ 4 rows in set (0.000 sec)  MariaDB [studydb]&gt; insert into test1(name) values('ccc'); Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; insert into test1(name) values('ddd'); Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; select * from test1; +-----+------+ | no  | name | +-----+------+ |   1 | xxx  | |   2 | aaa  | | 100 | yyy  | | 101 | bbb  | | 102 | ccc  | | 103 | ddd  | +-----+------+ 6 rows in set (0.000 sec)  MariaDB [studydb]&gt; delete from test1 where no=103; Query OK, 1 row affected (0.003 sec)  MariaDB [studydb]&gt; insert into test1(name) values('eee'); Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; select * from test1; +-----+------+ | no  | name | +-----+------+ |   1 | xxx  | |   2 | aaa  | | 100 | yyy  | | 101 | bbb  | | 102 | ccc  | | 104 | eee  | +-----+------+ 6 rows in set (0.000 sec)  MariaDB [studydb]&gt; insert into test1(name) values('fff'); Query OK, 1 row affected (0.002 sec)  MariaDB [studydb]&gt; select * from test1; +-----+------+ | no  | name | +-----+------+ |   1 | xxx  | |   2 | aaa  | | 100 | yyy  | | 101 | bbb  | | 102 | ccc  | | 104 | eee  | | 105 | fff  | +-----+------+ 7 rows in set (0.000 sec)  MariaDB [studydb]&gt;  MariaDB [studydb]&gt; insert into test1(name) values('123456789012345678901234'); ERROR 1406 (22001): Data too long for column 'name' at row 1 MariaDB [studydb]&gt; insert into test1(name) values('ggg'); Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; select * from test1; +-----+------+ | no  | name | +-----+------+ |   1 | xxx  | |   2 | aaa  | | 100 | yyy  | | 101 | bbb  | | 102 | ccc  | | 104 | eee  | | 105 | fff  | | 106 | ggg  | +-----+------+ 8 rows in set (0.000 sec)  MariaDB [studydb]&gt; drop table test1; Query OK, 0 rows affected (0.004 sec)  MariaDB [studydb]&gt; create table test1 (     -&gt;   no int primary key auto_increment,     -&gt;   name varchar(20) not null,     -&gt;   class varchar(10) not null,     -&gt;   working char(1) not null,     -&gt;   tel varchar(20)     -&gt; ); Query OK, 0 rows affected (0.017 sec)  MariaDB [studydb]&gt; insert into test1(name,class,working) values('aaa','java100','Y'); Query OK, 1 row affected (0.002 sec)  MariaDB [studydb]&gt; insert into test1(name,class,working) values('bbb','java100','N'); Query OK, 1 row affected (0.000 sec)  MariaDB [studydb]&gt; insert into test1(name,class,working) values('ccc','java100','Y'); Query OK, 1 row affected (0.000 sec)  MariaDB [studydb]&gt; insert into test1(name,class,working) values('ddd','java100','N'); Query OK, 1 row affected (0.000 sec)  MariaDB [studydb]&gt; insert into test1(name,class,working) values('eee','java100','Y'); Query OK, 1 row affected (0.000 sec)  MariaDB [studydb]&gt; insert into test1(name,class,working) values('kkk','java101','N'); Query OK, 1 row affected (0.000 sec)  MariaDB [studydb]&gt; insert into test1(name,class,working) values('lll','java101','Y'); Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; insert into test1(name,class,working) values('mmm','java101','N'); Query OK, 1 row affected (0.002 sec)  MariaDB [studydb]&gt; insert into test1(name,class,working) values('nnn','java101','Y'); Query OK, 1 row affected (0.000 sec)  MariaDB [studydb]&gt; insert into test1(name,class,working) values('ooo','java101','N');  Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; select * from test1; +----+------+---------+---------+------+ | no | name | class   | working | tel  | +----+------+---------+---------+------+ |  1 | aaa  | java100 | Y       | NULL | |  2 | bbb  | java100 | N       | NULL | |  3 | ccc  | java100 | Y       | NULL | |  4 | ddd  | java100 | N       | NULL | |  5 | eee  | java100 | Y       | NULL | |  6 | kkk  | java101 | N       | NULL | |  7 | lll  | java101 | Y       | NULL | |  8 | mmm  | java101 | N       | NULL | |  9 | nnn  | java101 | Y       | NULL | | 10 | ooo  | java101 | N       | NULL | +----+------+---------+---------+------+ 10 rows in set (0.000 sec)  MariaDB [studydb]&gt; select no, name, class from test1 where working = 'Y'; +----+------+---------+ | no | name | class   | +----+------+---------+ |  1 | aaa  | java100 | |  3 | ccc  | java100 | |  5 | eee  | java100 | |  7 | lll  | java101 | |  9 | nnn  | java101 | +----+------+---------+ 5 rows in set (0.000 sec)  MariaDB [studydb]&gt; select no, name, class from test1 where working = 'N'; +----+------+---------+ | no | name | class   | +----+------+---------+ |  2 | bbb  | java100 | |  4 | ddd  | java100 | |  6 | kkk  | java101 | |  8 | mmm  | java101 | | 10 | ooo  | java101 | +----+------+---------+ 5 rows in set (0.000 sec)  MariaDB [studydb]&gt; create view worker     -&gt;   as select no, name, class from test1 where working = 'Y'; Query OK, 0 rows affected (0.015 sec)  MariaDB [studydb]&gt; show tables; +-------------------+ | Tables_in_studydb | +-------------------+ | test1             | | worker            | +-------------------+ 2 rows in set (0.000 sec)  MariaDB [studydb]&gt; select * from worker; +----+------+---------+ | no | name | class   | +----+------+---------+ |  1 | aaa  | java100 | |  3 | ccc  | java100 | |  5 | eee  | java100 | |  7 | lll  | java101 | |  9 | nnn  | java101 | +----+------+---------+ 5 rows in set (0.003 sec)  MariaDB [studydb]&gt; insert into test1(name,class,working) values('ppp','java101','Y'); Query OK, 1 row affected (0.002 sec)  MariaDB [studydb]&gt; select * from worker; +----+------+---------+ | no | name | class   | +----+------+---------+ |  1 | aaa  | java100 | |  3 | ccc  | java100 | |  5 | eee  | java100 | |  7 | lll  | java101 | |  9 | nnn  | java101 | | 11 | ppp  | java101 | +----+------+---------+ 6 rows in set (0.000 sec)  MariaDB [studydb]&gt; drop view worker; Query OK, 0 rows affected (0.002 sec)  MariaDB [studydb]&gt; show tables; +-------------------+ | Tables_in_studydb | +-------------------+ | test1             | +-------------------+ 1 row in set (0.000 sec)  MariaDB [studydb]&gt; drop table test1; Query OK, 0 rows affected (0.003 sec)  MariaDB [studydb]&gt; show tables; Empty set (0.000 sec)  MariaDB [studydb]&gt;     DML(Data Manipulation Language)  데이터 등록, 변경, 삭제를 다루는 SQL 문법   insert     데이터를 입력할 때 사용하는 문법이다.   select 결과를 테이블이 insert 할 때            where 을 먼저 실행한 뒤 그 결과에서 필요한 값을 뽑아낸다.           select 결과를 테이블에 바롱 립력하기            셀렉트 결과의 컬럼명과 인서트 테이블의 컬럼명이 같을 필요는 없다.       그러나 결과의 컬럼 개수와 인서트 하려는 컬럼 개수가 같아야 한다.       결과의 컬럼 타입과 인서트 하려는 컬럼의 타입이 같거나 입력할 수 있는 타입이어야 한다.           MariaDB [studydb]&gt; create table test1 (     -&gt;   no int not null,     -&gt;   name varchar(20) not null,     -&gt;   tel varchar(20) not null,     -&gt;   fax varchar(20),     -&gt;   pstno varchar(5),     -&gt;   addr varchar(200)     -&gt; ); Query OK, 0 rows affected (0.016 sec)  MariaDB [studydb]&gt; alter table test1     -&gt;   add constraint test1_pk primary key (no); Query OK, 0 rows affected, 1 warning (0.019 sec) Records: 0  Duplicates: 0  Warnings: 1  MariaDB [studydb]&gt; alter table test1     -&gt;   modify column no int not null auto_increment; Query OK, 0 rows affected (0.031 sec)               Records: 0  Duplicates: 0  Warnings: 0  MariaDB [studydb]&gt; desc test1; +-------+--------------+------+-----+---------+----------------+ | Field | Type         | Null | Key | Default | Extra          | +-------+--------------+------+-----+---------+----------------+ | no    | int(11)      | NO   | PRI | NULL    | auto_increment | | name  | varchar(20)  | NO   |     | NULL    |                | | tel   | varchar(20)  | NO   |     | NULL    |                | | fax   | varchar(20)  | YES  |     | NULL    |                | | pstno | varchar(5)   | YES  |     | NULL    |                | | addr  | varchar(200) | YES  |     | NULL    |                | +-------+--------------+------+-----+---------+----------------+ 6 rows in set (0.005 sec)  MariaDB [studydb]&gt; insert into test1 values(null,'aaa','111','222','10101','seoul'); Query OK, 1 row affected (0.002 sec)  MariaDB [studydb]&gt; insert into test1(name,fax,tel,no,pstno,addr)      -&gt;     values('bbb','222','111',null,'10101','seoul'); Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; select * from test1; +----+------+-----+------+-------+-------+ | no | name | tel | fax  | pstno | addr  | +----+------+-----+------+-------+-------+ |  1 | aaa  | 111 | 222  | 10101 | seoul | |  2 | bbb  | 111 | 222  | 10101 | seoul | +----+------+-----+------+-------+-------+ 2 rows in set (0.000 sec)  MariaDB [studydb]&gt; insert into test1(name,tel) values('ccc','333'); Query OK, 1 row affected (0.001 sec)  MariaDB [studydb]&gt; select * from test1; +----+------+-----+------+-------+-------+ | no | name | tel | fax  | pstno | addr  | +----+------+-----+------+-------+-------+ |  1 | aaa  | 111 | 222  | 10101 | seoul | |  2 | bbb  | 111 | 222  | 10101 | seoul | |  3 | ccc  | 333 | NULL | NULL  | NULL  | +----+------+-----+------+-------+-------+ 3 rows in set (0.000 sec)  MariaDB [studydb]&gt; insert into test1(name,tel) values     -&gt; ('aaa', '1111'),     -&gt; ('bbb', '2222'),     -&gt; ('ccc', '3333'); Query OK, 3 rows affected (0.001 sec) Records: 3  Duplicates: 0  Warnings: 0  MariaDB [studydb]&gt; select * from test1; +----+------+------+------+-------+-------+ | no | name | tel  | fax  | pstno | addr  | +----+------+------+------+-------+-------+ |  1 | aaa  | 111  | 222  | 10101 | seoul | |  2 | bbb  | 111  | 222  | 10101 | seoul | |  3 | ccc  | 333  | NULL | NULL  | NULL  | |  4 | aaa  | 1111 | NULL | NULL  | NULL  | |  5 | bbb  | 2222 | NULL | NULL  | NULL  | |  6 | ccc  | 3333 | NULL | NULL  | NULL  | +----+------+------+------+-------+-------+ 6 rows in set (0.000 sec)  MariaDB [studydb]&gt; create table test2 (     -&gt;   no int not null primary key auto_increment,     -&gt;   name varchar(20) not null,     -&gt;   tel varchar(20) not null,     -&gt;   kor int,     -&gt;   eng int,     -&gt;   math int     -&gt; ); Query OK, 0 rows affected (0.016 sec)  MariaDB [studydb]&gt; show tables; +-------------------+ | Tables_in_studydb | +-------------------+ | test1             | | test2             | +-------------------+ 2 rows in set (0.000 sec)  MariaDB [studydb]&gt;   select name, tel from test1 where addr='seoul';  +------+-----+ | name | tel | +------+-----+ | aaa  | 111 | | bbb  | 111 | +------+-----+ 2 rows in set (0.000 sec)  MariaDB [studydb]&gt;   select name, tel from test1; +------+------+ | name | tel  | +------+------+ | aaa  | 111  | | bbb  | 111  | | ccc  | 333  | | aaa  | 1111 | | bbb  | 2222 | | ccc  | 3333 | +------+------+ 6 rows in set (0.000 sec)  MariaDB [studydb]&gt; select * from test1; +----+------+------+------+-------+-------+ | no | name | tel  | fax  | pstno | addr  | +----+------+------+------+-------+-------+ |  1 | aaa  | 111  | 222  | 10101 | seoul | |  2 | bbb  | 111  | 222  | 10101 | seoul | |  3 | ccc  | 333  | NULL | NULL  | NULL  | |  4 | aaa  | 1111 | NULL | NULL  | NULL  | |  5 | bbb  | 2222 | NULL | NULL  | NULL  | |  6 | ccc  | 3333 | NULL | NULL  | NULL  | +----+------+------+------+-------+-------+ 6 rows in set (0.000 sec)  MariaDB [studydb]&gt;   select name, tel from test1 where addr='seoul';  +------+-----+ | name | tel | +------+-----+ | aaa  | 111 | | bbb  | 111 | +------+-----+ 2 rows in set (0.000 sec)  MariaDB [studydb]&gt; desc test2; +-------+-------------+------+-----+---------+----------------+ | Field | Type        | Null | Key | Default | Extra          | +-------+-------------+------+-----+---------+----------------+ | no    | int(11)     | NO   | PRI | NULL    | auto_increment | | name  | varchar(20) | NO   |     | NULL    |                | | tel   | varchar(20) | NO   |     | NULL    |                | | kor   | int(11)     | YES  |     | NULL    |                | | eng   | int(11)     | YES  |     | NULL    |                | | math  | int(11)     | YES  |     | NULL    |                | +-------+-------------+------+-----+---------+----------------+ 6 rows in set (0.003 sec)  MariaDB [studydb]&gt; drop table test2; Query OK, 0 rows affected (0.003 sec)  MariaDB [studydb]&gt; create table test2 (     -&gt;   no int not null primary key auto_increment,     -&gt;   fullname varchar(20) not null,     -&gt;   phone varchar(20) not null,     -&gt;   kor int,     -&gt;   eng int,     -&gt;   math int     -&gt; ); Query OK, 0 rows affected (0.021 sec)  MariaDB [studydb]&gt; insert into test2(fullname,phone)     -&gt;   select name, tel from test1 where addr='seoul';  Query OK, 2 rows affected (0.002 sec) Records: 2  Duplicates: 0  Warnings: 0  MariaDB [studydb]&gt; select * from test2; +----+----------+-------+------+------+------+ | no | fullname | phone | kor  | eng  | math | +----+----------+-------+------+------+------+ |  1 | aaa      | 111   | NULL | NULL | NULL | |  2 | bbb      | 111   | NULL | NULL | NULL | +----+----------+-------+------+------+------+ 2 rows in set (0.000 sec)  MariaDB [studydb]&gt; insert into test2(name,tel)     -&gt;   select name, tel, fax from test1 where addr='seoul';  ERROR 1136 (21S01): Column count doesn't match value count at row 1 MariaDB [studydb]&gt; insert into test2(name,kor)     -&gt;   select name, tel from test1 where addr='seoul';  ERROR 1054 (42S22): Unknown column 'name' in 'field list' MariaDB [studydb]&gt;    update     등록된 데이터를 변경할 때 사용하는 명령이다.   qutocommit            명령창에서 실행하면 바로 실제 테이블에 적용된다.       set autocommit=false; 로 하면 오토 커밋이 되지 않는다.           commit; 을 하면 입력한 명령어들이 전부 테이블에 반영되어 고정된다.   commit; 이전에 작업한 것들은 rollback 되지 않는다.   기존 명령창에서 데이터 변경 후 commit; 을 하고 다른 명령창에서 새로 접속해서 살펴보면 최신 데이터를 보여주게 된다.            mysql은 다른 명령창에서 auto-commit 을 true; 로 설정해놔야 기존 명령창에서 커밋한 것들이 자동으로 업데이트 되어 보여진다.       flase 인 경우 다른 명령창에서 commit; 명령어를 먼저 입력해야 한다.       오라클인 경우는 다른 명령창의 커밋 설정이 오토 커밋을 기본값으로 가지기 때문에 오토 커밋을 트루로 할 필요가 없다.           MariaDB [studydb]&gt; select * from test1; +----+------+------+------+-------+-------+ | no | name | tel  | fax  | pstno | addr  | +----+------+------+------+-------+-------+ |  1 | aaa  | 111  | 222  | 10101 | seoul | |  2 | bbb  | 111  | 222  | 10101 | seoul | |  3 | ccc  | 333  | NULL | NULL  | NULL  | |  4 | aaa  | 1111 | NULL | NULL  | NULL  | |  5 | bbb  | 2222 | NULL | NULL  | NULL  | |  6 | ccc  | 3333 | NULL | NULL  | NULL  | +----+------+------+------+-------+-------+ 6 rows in set (0.000 sec)  MariaDB [studydb]&gt; update test1 set pstno='11111', fax='222' where no=3; Query OK, 1 row affected (0.002 sec) Rows matched: 1  Changed: 1  Warnings: 0  MariaDB [studydb]&gt; select * from test1; +----+------+------+------+-------+-------+ | no | name | tel  | fax  | pstno | addr  | +----+------+------+------+-------+-------+ |  1 | aaa  | 111  | 222  | 10101 | seoul | |  2 | bbb  | 111  | 222  | 10101 | seoul | |  3 | ccc  | 333  | 222  | 11111 | NULL  | |  4 | aaa  | 1111 | NULL | NULL  | NULL  | |  5 | bbb  | 2222 | NULL | NULL  | NULL  | |  6 | ccc  | 3333 | NULL | NULL  | NULL  | +----+------+------+------+-------+-------+ 6 rows in set (0.000 sec)  MariaDB [studydb]&gt; update test1 set tel='3030', fax='1212' where no=2; Query OK, 1 row affected (0.001 sec) Rows matched: 1  Changed: 1  Warnings: 0  MariaDB [studydb]&gt; select * from test1; +----+------+------+------+-------+-------+ | no | name | tel  | fax  | pstno | addr  | +----+------+------+------+-------+-------+ |  1 | aaa  | 111  | 222  | 10101 | seoul | |  2 | bbb  | 3030 | 1212 | 10101 | seoul | |  3 | ccc  | 333  | 222  | 11111 | NULL  | |  4 | aaa  | 1111 | NULL | NULL  | NULL  | |  5 | bbb  | 2222 | NULL | NULL  | NULL  | |  6 | ccc  | 3333 | NULL | NULL  | NULL  | +----+------+------+------+-------+-------+ 6 rows in set (0.000 sec)  MariaDB [studydb]&gt; rollback; Query OK, 0 rows affected (0.000 sec)  MariaDB [studydb]&gt; select * from test1; +----+------+------+------+-------+-------+ | no | name | tel  | fax  | pstno | addr  | +----+------+------+------+-------+-------+ |  1 | aaa  | 111  | 222  | 10101 | seoul | |  2 | bbb  | 3030 | 1212 | 10101 | seoul | |  3 | ccc  | 333  | 222  | 11111 | NULL  | |  4 | aaa  | 1111 | NULL | NULL  | NULL  | |  5 | bbb  | 2222 | NULL | NULL  | NULL  | |  6 | ccc  | 3333 | NULL | NULL  | NULL  | +----+------+------+------+-------+-------+ 6 rows in set (0.000 sec)  MariaDB [studydb]&gt; set autocommit=false; Query OK, 0 rows affected (0.003 sec)  MariaDB [studydb]&gt; delete from test1 where no = 4; Query OK, 1 row affected (0.000 sec)  MariaDB [studydb]&gt; select * from test1; +----+------+------+------+-------+-------+ | no | name | tel  | fax  | pstno | addr  | +----+------+------+------+-------+-------+ |  1 | aaa  | 111  | 222  | 10101 | seoul | |  2 | bbb  | 3030 | 1212 | 10101 | seoul | |  3 | ccc  | 333  | 222  | 11111 | NULL  | |  5 | bbb  | 2222 | NULL | NULL  | NULL  | |  6 | ccc  | 3333 | NULL | NULL  | NULL  | +----+------+------+------+-------+-------+ 5 rows in set (0.000 sec)  MariaDB [studydb]&gt; update test1 set tel = '777'; Query OK, 5 rows affected (0.000 sec) Rows matched: 5  Changed: 5  Warnings: 0  MariaDB [studydb]&gt; insert into test1(name, tel) valued('hong', '1212'); ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near 'valued('hong', '1212')' at line 1 MariaDB [studydb]&gt; insert into test1(name, tel) values('hong', '1212);     '&gt; ;     '&gt; );     '&gt; quit     '&gt; '); Query OK, 1 row affected (0.000 sec)  MariaDB [studydb]&gt; select * from test1; +----+------+-------------------+------+-------+-------+ | no | name | tel               | fax  | pstno | addr  | +----+------+-------------------+------+-------+-------+ |  1 | aaa  | 777               | 222  | 10101 | seoul | |  2 | bbb  | 777               | 1212 | 10101 | seoul | |  3 | ccc  | 777               | 222  | 11111 | NULL  | |  5 | bbb  | 777               | NULL | NULL  | NULL  | |  6 | ccc  | 777               | NULL | NULL  | NULL  | |  7 | hong | 1212); ; ); quit  | NULL | NULL  | NULL  | +----+------+-------------------+------+-------+-------+ 6 rows in set (0.000 sec)  MariaDB [studydb]&gt; rollback; Query OK, 0 rows affected (0.002 sec)  MariaDB [studydb]&gt; select * from test1; +----+------+------+------+-------+-------+ | no | name | tel  | fax  | pstno | addr  | +----+------+------+------+-------+-------+ |  1 | aaa  | 111  | 222  | 10101 | seoul | |  2 | bbb  | 3030 | 1212 | 10101 | seoul | |  3 | ccc  | 333  | 222  | 11111 | NULL  | |  4 | aaa  | 1111 | NULL | NULL  | NULL  | |  5 | bbb  | 2222 | NULL | NULL  | NULL  | |  6 | ccc  | 3333 | NULL | NULL  | NULL  | +----+------+------+------+-------+-------+ 6 rows in set (0.000 sec)  MariaDB [studydb]&gt; delete from test1 where no = 4; Query OK, 1 row affected (0.000 sec)  MariaDB [studydb]&gt; update test1 set tel = '777'; Query OK, 5 rows affected (0.000 sec) Rows matched: 5  Changed: 5  Warnings: 0  MariaDB [studydb]&gt; commit; Query OK, 0 rows affected (0.001 sec)  MariaDB [studydb]&gt; insert into test1(name, tel) values('hong', '1212'); Query OK, 1 row affected (0.000 sec)  MariaDB [studydb]&gt; select * from test1; +----+------+------+------+-------+-------+ | no | name | tel  | fax  | pstno | addr  | +----+------+------+------+-------+-------+ |  1 | aaa  | 777  | 222  | 10101 | seoul | |  2 | bbb  | 777  | 1212 | 10101 | seoul | |  3 | ccc  | 777  | 222  | 11111 | NULL  | |  5 | bbb  | 777  | NULL | NULL  | NULL  | |  6 | ccc  | 777  | NULL | NULL  | NULL  | |  8 | hong | 1212 | NULL | NULL  | NULL  | +----+------+------+------+-------+-------+ 6 rows in set (0.000 sec)  MariaDB [studydb]&gt; rollback; Query OK, 0 rows affected (0.001 sec)  MariaDB [studydb]&gt; select * from test1; +----+------+-----+------+-------+-------+ | no | name | tel | fax  | pstno | addr  | +----+------+-----+------+-------+-------+ |  1 | aaa  | 777 | 222  | 10101 | seoul | |  2 | bbb  | 777 | 1212 | 10101 | seoul | |  3 | ccc  | 777 | 222  | 11111 | NULL  | |  5 | bbb  | 777 | NULL | NULL  | NULL  | |  6 | ccc  | 777 | NULL | NULL  | NULL  | +----+------+-----+------+-------+-------+ 5 rows in set (0.000 sec)   마이그레이션     기존 버젼의 테이블 구조에서 신규 구조의 테이블에 맞춰서 데이터를 옮기는 것.  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "http://localhost:4000/til/TIL201026/",
        "teaser": null
      }]
