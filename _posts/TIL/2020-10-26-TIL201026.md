---
layout: post
title:  2020-10-26 TIL
categories: TIL
layout : single
---

# stateful, stateless

## Stateless 의 문제점
- 한 번 연결하고 응답하고 나면 연결이 끊기는데 어떻게 클라이언트를 특정할 수 있는지?

## DataInput/OutputStram
- 데이터를 타입 별로 받아들이기 좋다.

## ex04 stateful
- 메인 스레드가 모든 일을 다 하기 때문에 하나의 클라이언트와 연결되면 다른 클라이언트는 accept() 에서 기다리고 있어야 한다.
- 처음 연결된 클라이언트가 종료되고 나면 두번째로 연결된 클라이언트에 응답을 흔다.

## ex04 stateful 2
- 계산 결과를 서버에 저장해둔다.
- 메인 스레드가 혼자 일을 한다.

## ex04 stateful 3
- 스레드를 사용해서 동시에 여러 클라이언트의 요청에 응답할 수 있다.
 - 소켓을 통해서 다이렉트로 어드레스를 받아오는 것보다 주소를 다루는 별도의 클래스를 분리시킨 것이 InetSocketAddress 이다.
    - InetSocketAddress 객체를 통해 주소화 포트번호가 담긴 객체를 얻은 다음에 거기서 뽑아서 쓰는 것이 확장성이 더 좋다.
- 메인 스레드는 클라이언트 요청이 들어오면 accept 를 통해 socket 객체를 만들어서 새로운 스레드에게 일을 시킨다.
- run() 메소드를 실행하고 processRequest를 호출해서 클라이언트의 요청을 해결하는 동안 만들어지는 모든 로컬 변수는 각 스레드에서 생성되는 stack 메모리에 저장된다.

## ex04 stateless
- 서버와의 연결을 최소한으로 하기 위해서 클라이언트에 값을 다 입력하고 나서 연산을 처리할 때만(엔터를 칠 때) 연결한다.
- 버퍼 스트림을 쓸 때는 out.flush()를 꼭 사용해야 한다.
- 스테이트리스는 둘 사이의 요청 응답이 끝나면 연결을 끊는다.

## ex04 stateless 2
- stateless 에서 클라이언트를 구분하고 작업 결과를 유지하는 방법
- ID 를 Map 에 등록하고 클라이언트가 서버에서 반환된 ID 를 저장해둔다.
- ID와 함께 저장된 result 값을 다음 연산에 사용한다. 

- 쿠키 : 웹 서버가 웹 브라우저에게 보내는 정보(객체), 인증 정보를 웹 브라우저에 저장하고 사용자가 요청을 할 때 그 정보를 함께 보내서 사용자를 식별할 수 있도록 도와준다.
- 세션 : 로그인, 사용자 닉네임, 접속 시간 등 서버가 알아야 할 정보를 저장해 놓는다. 만료가 되었다는 것은 세션에 지정된 시간이 종료되었다는 것을 뜻하는 듯하다.

# sql (eomcs-docs-sql)

## sql
- 색인표에 특정 컬럼의 값을 정렬시키는 문법이 인덱스이다.
- 색인표에 자료를 정렬해두고 찾으면 
    - 장점 : 훨씬 빠른 속도로 찾을 수 있게 된다.
    - 단점 : 파일의 크기가 커진다. (하드디스크 메모리를 사용한다.)
- 기준 항목에 대해 정렬하는 것이 색인표이다.
- 새 데이터를 추가하거나 데이터를 변경하면 색인표도 갱신해야 한다.
    - 추가, 변경, 삭제 시 실행 속도가 느리다.
    - 대신 검색 속도가 빠르다.
