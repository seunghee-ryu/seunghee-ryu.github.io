---
layout : post
title :  2020-11-24 TIL
categories : TIL
layout : single
toc : true 
toc_sticky : true
---

# WAS

![image-20201124095314363](/Users/rsh/Library/Application Support/typora-user-images/image-20201124095314363.png)



### 서블릿의 배포

![image-20201124115444883](/Users/rsh/Library/Application Support/typora-user-images/image-20201124115444883.png)

- <<interface>>서블릿 <--- <<concrete>>마이서블릿 @WebServlet(경로) 애노테이션으로 배포 정보 설정
- Web.xml <- DDfile 에 배치 정보를 설정해서 배포



### 서블릿의 메서드 호출

- 서블릿을 실행하고 종료할 때 호출되는 메서드

```java
Servlet01()

Servlet01.init(ServletConfig)

Servlet01.service(ServletRequest,ServletResponse)

Servlet01.service(ServletRequest,ServletResponse)

Servlet01.service(ServletRequest,ServletResponse)

Servlet01.service(ServletRequest,ServletResponse)

Servlet01.service(ServletRequest,ServletResponse)

Servlet01.destroy()
```



#### 서블릿 이름

- 서블릿 이름은 별명
- 실무에서는 클래스 이름과 동일하게 한다.



### 서블릿 만들기

```xml
  <!-- 서블릿 등록 / 서블릿 이름은 별명 -->
  <servlet>
    <servlet-name>s01</servlet-name>
    <servlet-class>com.eomcs.web.ex01.Servlet01</servlet-class>
  </servlet>
  
    <!-- 서블릿을 실행할 때 사용할 url path를 설정 -->
   <servlet-mapping>
    <servlet-name>s01</servlet-name>
    <url-pattern>/ohora/haha</url-pattern>
  </servlet-mapping>
```

- 주소가 다음과 같이 바뀐다
  - http://localhost:8080/bitcamp-web-project/ohora/haha



### 서블릿 인터페이스 구현

![image-20201124115505647](/Users/rsh/Library/Application Support/typora-user-images/image-20201124115505647.png)

- 서블릿 인터페이스를 상속받아서 직접 구현하면 init(), service(), destroy(), getServletInfo(), getServletConfig() 메서드를 전부 다 구현해야 한다.
- 이것을 보완하기 위해 미리 service를 빼고 나머지를 다 구현한 추상 메서드 GenericServlet이 서블릿 인터페이스를 상속받아서 만들어졌다.
  - service() 는 추상 메서드로 남아있다.
- GenericServlet에 HTTP 프로토콜 처리 기능을 추가해서 만들어진 것이 HttpServlet이다
  - 이 추상 클래스는 service()를 구현하고 추가로 service()를 오버로딩, doGet(), doPost() 등의 메서드를 가진다.
  - 이 추상 클래스를 상속받아 MyServlet()를 만든다.
    - 오버라이딩을 해서 doGet(), doPost(), doHead() 등의 메서드를 만든다.
- HttpServlet에서 호출되는 것은 service() 이다.
  - 이 service()가 그 아래의 service(), doGet(), doPost() 등을 호출한다.



### GenericServlet 추상 클래스 상송

```java
// GenericServlet 추상 클래스
// => javax.servlet.Servlet 인터페이스를 구현하였다.
// => service() 메서드만 남겨두고 나머지 메서드들은 모두 구현하였다.
// => 따라서 이 클래스를 상속 받는 서브 클래스는 service() 만 구현하면 된다.
//
public class Servlet02 extends GenericServlet {

  // GenericServlet 추상 클래스는 java.io.Serialize 인터페이스를 구현하였다.
  // => serialVersionUID 변수 값을 설정해야 한다.
  private static final long serialVersionUID = 1L;

  public Servlet02() {
    System.out.println("Servlet02()");
  }

  @Override
  public void service(ServletRequest req, ServletResponse res)
      throws ServletException, IOException {
    System.out.println("Servlet02.service(ServletRequest,ServletResponse)");
  }
}
```



#### Servlet과 java.io.Serializable

![image-20201124115525338](/Users/rsh/Library/Application Support/typora-user-images/image-20201124115525338.png)

- Load Balancer 가 여러 Servlet Container에 객체를 분배한다.

  - 실행 중에 다른 서블릿에 객체를 이관해야 하는 상황이 온다면 객체를 복제해서 보낼 때 시리얼 넘버를 부여해서 복제한 다음에 보낸다.
    - 그렇기 때문에 서블릿은 시리얼라이즈 인터페이스를 구현한다.

- 또는 Active한 서블릿 컨테이너(예 : 사용중인 타이어)와 InActive한 서블릿 컨테이너(예 : 스페어 타이어)가 있을 때 (시스템 2중화)

  - Active한 서블릿 컨테이너에 문제가 생겼을 경우 Active한 서블릿 컨테이너에서 실행하고 있던 객체를 InActive한 서블릿 컨테이너로 옮겨야 한다.

  - 실행 중인 값을 그대로 복제해야 하기 때문에 시리얼라이즈 해야한다.

- 서블릿은 Serial 버전관리를 해야한다.

  - 그래서 각 서블릿은 serialVersionUID 스태틱 변수의 값을 설정해야 한다.

### HttpServlet 추상 클래스 상속

- 요청 -> 서블릿 컨테이너 -service()->MyServlet 클래스에는 service가 없기 때문에 그 수퍼 클래스에서 service()를 호출

```java
// HttpServlet 추상 클래스
// => javax.servlet.GenericServlet 추상 클래스를 상속 받았다.
// => service() 메서드도 구현했다.
// => service() 메서드는 웹브라우저가 요청한 명령에 따라 
//    doGet(), doPost(), doHead(), doPut() 등을 호출하게 프로그램 되어 있다.
// => HTTP 프로토콜을 다루려면 GenericServlet을 상속 받지 말고 
//    HttpServlet을 상속 받아 서블릿 클래스를 만들라!
// 
public class Servlet03 extends HttpServlet {
  
  // GenericServlet 추상 클래스가 java.io.Serialize 인터페이스를 구현하였고,
  // HttpServlet 클래스가 GenericServlet 추상 클래스를 상속 받았으니
  // HttpServlet 클래스를 상속 받는 이 클래스도 마찬가지로
  // serialVersionUID 변수 값을 설정해야 한다.
  private static final long serialVersionUID = 1L;

  // service()를 오버라이딩 하는 대신에
  // doGet(), doPost(), doHead() 등을 오버라이딩 하라.
  // 호출과정:
  // => 웹브라우저
  //   => 톰캣 서버
  //     => Servlet03.service(ServletRequest, ServletResponse) 
  //       => Serlvet03.service(HttpServletRequest, HttpServletResponse)
  //         => Servlet03.doGet(HttpServletRequest, HttpServletResponse)
  @Override
  public void doGet(HttpServletRequest req, HttpServletResponse res)
      throws ServletException, IOException {
    System.out.println("Servlet03.doGet(HttpServletRequest,HttpServletResponse)");
  }
}
```

- 수퍼 클래스인 HttpServlet에서 service가 호출된다. 

```java
public abstract class HttpServlet extends GenericServlet
.
.
.
	@Override
    public void service(ServletRequest req, ServletResponse res)
        throws ServletException, IOException
    {
        HttpServletRequest  request;
        HttpServletResponse response;
        
        if (!(req instanceof HttpServletRequest &&
                res instanceof HttpServletResponse)) {
            throw new ServletException("non-HTTP request or response");
        }

        request = (HttpServletRequest) req;
        response = (HttpServletResponse) res;

        service(request, response);
    }
}
```

- HttpServlet에서 service(ServletRequest, ServletResponse) 를 오버로딩 해서 내부적으로 service(HttpServletRequest, HttpServletResponse)를 호출한다.

```java
 protected void service(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException
    {
        String method = req.getMethod();

        if (method.equals(METHOD_GET)) {
            long lastModified = getLastModified(req);
            if (lastModified == -1) {
                // servlet doesn't support if-modified-since, no reason
                // to go through further expensive logic
                doGet(req, resp);
            } else {
                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
                if (ifModifiedSince < lastModified) {
                    // If the servlet mod time is later, call doGet()
                    // Round down to the nearest second for a proper compare
                    // A ifModifiedSince of -1 will always be less
                    maybeSetLastModified(resp, lastModified);
                    doGet(req, resp);
                } else {
                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                }
            }

        } else if (method.equals(METHOD_HEAD)) {
            long lastModified = getLastModified(req);
            maybeSetLastModified(resp, lastModified);
            doHead(req, resp);

        } else if (method.equals(METHOD_POST)) {
            doPost(req, resp);
            
        } else if (method.equals(METHOD_PUT)) {
            doPut(req, resp);
            
        } else if (method.equals(METHOD_DELETE)) {
            doDelete(req, resp);
            
        } else if (method.equals(METHOD_OPTIONS)) {
            doOptions(req,resp);
            
        } else if (method.equals(METHOD_TRACE)) {
            doTrace(req,resp);
            
        } else {
            //
            // Note that this means NO servlet supports whatever
            // method was requested, anywhere on this server.
            //

            String errMsg = lStrings.getString("http.method_not_implemented");
            Object[] errArgs = new Object[1];
            errArgs[0] = method;
            errMsg = MessageFormat.format(errMsg, errArgs);
            
            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);
        }
    }
```

- get을 요청받았다면 service(HttpServletRequest, HttpServletResponse)에서 자식 클래스의 doGet()을 호출한다.
  - post를 요청받으면 doPost(), head를 요청받으면 doHead()를 호출한다.

![image-20201124121400068](/Users/rsh/Library/Application Support/typora-user-images/image-20201124121400068.png)



### 