---
layout: post
title:  2020-10-20 TIL
categories: TIL
layout : single
---

# 스레드풀 구현
- mini-pms 36

## 스레드풀
- 스레드를 풀링 기법(pooling)을 이용하여 관리한다.
- 스레드를 사용한 후에 버리지 않고 재사용하여 가비지 생성을 줄인다.

## 풀링 기법(pooling)
- 사용한 객체를 버리지 않고 보관해 두었다가 재사용하는 객체 관리 기법이다.
- 동일한 객체를 자주 생성하고,
- 생성한 객체를 쓰고 버리는 상황에서 대량의 가비지가 생성되는 경우에 적합한다.
- GoF의 '디자인 패턴'에서 Flyweight 패턴의 한 예이다.

## 01) 스레드풀 정의
- notify() 와 wait() 는 싱크로되지 않은 곳(막혀있지 않은 곳)에서 사용하면 에러가 뜬다.
- synchronized (대상)
- 에외처리

```java
    @Override
    public void run() {
      while (true) {

        // try-catch를 while 안에 넣으면 task.run()을 수행하다가 예외가 발생했을 경우 처리할 수 없다.
        // 스레드는 유효하다.

        try {
          this.wait();
        } catch (Exception e) {
          System.out.println("스레드 실행 중 오류 발생");
          break;
        }

        task.run();
      }
    }
```

- 스레드풀 만들기(java.util 따라하기)

```java
public class ThreadPool {

  List<Worker> workers = new ArrayList<>();

  // 스레드 + 작업을 맡기고 + 깨우는 기능 + 작업 완료 후 잠자는 기능
  class Worker extends Thread {
    Runnable task;

    public void setTask(Runnable task) {
      // 스레드가 할 작업을 배정한 후
      this.task = task;

      synchronized (this) {
        // 스레드를 깨운다.
        this.notify();
      }
    }

    @Override
    public void run() {

      synchronized (this) {
        while (true) {
          try {
            System.out.printf("[%s] - 스레드 대기 중...\n", this.getName());
            this.wait();
            System.out.printf("[%s] - 스레드 작업 시작\n", this.getName());
            // 이 스레드 객체에 대해 대기 상태로 있다가
            // 이 스레드에게 깨어나라는 알림(notify()/notifyAll()이 온다면
            // 즉시 runninig 상태로 되돌아간다.
          } catch (Exception e) {
            System.out.printf("[%s] - 스레드 실행 중 오류 발생\n", this.getName());
            break;
            // 기다리다가 인터럽트 예외가 발생하면 스레드를 종료한다.
          }
          try {
            task.run();
            System.out.printf("[%s] - 스레드 작업 종료\n", this.getName());
          } catch (Exception e) {
            System.out.printf("[%s] - %s\n", this.getName(), e.getMessage());
            // 작업 수행 중 오류가 발생하더라도 스레드는 계속 유효하다.
          } finally {
            // 정상적인 종료든 작업 수행 중 예외가 발생했든 간에
            // 작업을 마친 스레드는 재사용할 수 있도록
            // 다시 목록에 보관되어야 한다.
            workers.add(this);
            System.out.printf("[%s] - 스레드풀로 되돌아 감\n", this.getName());
          }
        }
      }
    }
  }

  public void execute(Runnable task) {

    Worker t;
    if (workers.size() == 0) {
      // 만약 스레드가 없다면 스레드를 새로 생성한다.
      t = new Worker();
      System.out.printf("[%s] - 스레드 생성\n", t.getName());
      // 그리고 즉시 실행한다.
      // - 실행하더라도 스레드 스스로 대기 상태로 갈 것이다.
      t.start();

      // 현재 main 스레드를 잠깐 멈추게 하여
      // 새로 만든 스레드가 실행할 틈을 주자.
      // 그래야만 새로 만든 스레드가 실행하자마자 대기 상태로 간다.
      try {
        Thread.sleep(20);
      } catch (Exception e) {
        // sleep() 중 발생한 예외는 무시한다.
      }
    } else {
      // 만약 스레드가 있다면 스레드풀에서 스레드를 한 개 꺼낸다.
      // - 스레드풀에서 꺼낸 스레드는 현재 대기 상태이다.
      t = workers.remove(0);
      System.out.printf("[%s] - 스레드 재사용\n", t.getName());
    }

    // 스레드를 깨워서 일을 시킨다.
    // - 스레드에게 해야 할 작업을 배정하면 된다.
    t.setTask(task);
  }
}
```

## 02) 클라이언트가 접속하면 요청 처리를 ThreadPool에게 맡긴다.
- 같은 코드인데 정상 실행이 됐다가 안됐다가 하는것은 비동기 때문이다.
    - 비동기에서는 누가 먼저 실행되는지 정확하게 알아야 한다.
- 소켓은 클라이언트가 연결되었다가 끊어지는 순간에 사라지기 때문에 재사용이 불가능하다.
- 스레드가 몇개의 작업을 처리할 수 있는지는 컴퓨터의 cpu 성능에 따라 다르다.
- 스레드를 몇개 생성할 수 있는지는 메모리에 따라 다르다.
- 메인 스레드가 죽어도 나머지 스레드(스레드풀)가 살아 있으면 종료되지 않는다.


```java
public class ServerApp {

  static boolean stop = false;

  // 스레드풀 준비
  ThreadPool threadPool = new ThreadPool();

  static Map<String,Object> context = new Hashtable<>();

  List<ApplicationContextListener> listeners = new ArrayList<>();

  public void addApplicationContextListener(ApplicationContextListener listener) {
    listeners.add(listener);
  }

  public void removeApplicationContextListener(ApplicationContextListener listener) {
    listeners.remove(listener);
  }

  private void notifyApplicationContextListenerOnServiceStarted() {
    for (ApplicationContextListener listener : listeners) {
      listener.contextInitialized(context);
    }
  }

  private void notifyApplicationContextListenerOnServiceStopped() {
    for (ApplicationContextListener listener : listeners) {
      listener.contextDestroyed(context);
    }
  }

  public void service(int port) {

    notifyApplicationContextListenerOnServiceStarted();

    try (ServerSocket serverSocket = new ServerSocket(port)) {
      System.out.println("서버 실행 중...");

      while (true) {
        Socket clientSocket = serverSocket.accept();

        if (stop) {
          break;
        }
        // 스레드풀로 변경
        threadPool.execute(() -> handleClient(clientSocket));
      }

    } catch (Exception e) {
      e.printStackTrace();
    }

    notifyApplicationContextListenerOnServiceStopped();
  }
.
.
.
}
```

## 03) 스레드풀

```java
package com.eomcs.util.concurrent;

import java.util.ArrayList;

public class ThreadPool {

  // 스레드풀의 종료 상태
  boolean stopping = false;

  // 스레드 목록을 담는 리스트
  ArrayList<Worker> workers = new ArrayList<>();

  // 작업을 수행하는 스레드
  private class Worker extends Thread {
    Runnable task;

    public void setTask(Runnable task) {
      this.task = task;
      synchronized (this) {
        this.notify();
      }
    }

    @Override
    public void run() {
      synchronized (this) {
        try {
          while (true) {
            this.wait();

            // 스레드풀의 상태가 종료하는 상태라면, 스레드 실행을 멈춘다.
            if (ThreadPool.this.stopping)
              break;

            task.run();
            workers.add(this);
            System.out.println("스레드풀로 되돌아 감!");
          }
        } catch (Exception e) {
          System.out.printf("%s 스레드에서 오류 발생! - 스레드풀에서 제거.\n", this.getName());
          workers.remove(this);
        }
      }
    }
  }

  public void execute(Runnable task) {
    Worker t = null;
    if (workers.isEmpty()) {
      t = new Worker();
      t.start();
      System.out.printf("새 스레드(%s) 생성 및 실행!\n", t.getName());
    } else {
      t = workers.remove(0);
      System.out.printf("기존 스레드(%s) 사용!\n", t.getName());
    }

    t.setTask(task);
  }

  public void shutdown() {
    try {
      this.stopping = true;

      // 일단 현재 목록에 대기하고 있는 스레드를 종료한다.
      while (!workers.isEmpty()) {
        Worker worker = workers.remove(0);
        synchronized (worker) {
          worker.notify();
        }
      }

      // 아직 클라이언트의 요청 처리를 완료하지 못한 스레드를 기다린다.
      Thread.sleep(2000);

      // 다시 현재 목록에 대기하고 있는 스레드를 종료한다.
      while (!workers.isEmpty()) {
        Worker worker = workers.remove(0);
        synchronized (worker) {
          worker.notify();
        }
      }
    } catch (Exception e) {
      System.out.println("스레드풀 종료 중 오류 발생!");
      e.printStackTrace();
    }
  }
}

```

- 내가 타이핑한거.

```java
public class ThreadPool {

  // 스레드풀의 종료 상태
  boolean stopping = false;

  List<Worker> workers = new ArrayList<>();

  class Worker extends Thread {
    Runnable task;

    public void setTask(Runnable task) {
      this.task = task;

      synchronized (this) {
        this.notify();
      }
    }

    @Override
    public void run() {

      synchronized (this) {
        while (true) {
          try {
            System.out.printf("[%s] - 스레드 대기 중...\n", this.getName());
            this.wait();

            if (ThreadPool.this.stopping) { // 스레드풀이 종료 상태라면
              // 스레드는 깨어나는 즉시 실행을 멈춘다.
              break;
            }

            System.out.printf("[%s] - 스레드 작업 시작\n", this.getName());
          } catch (Exception e) {
            System.out.printf("[%s] - 스레드 실행 중 오류 발생\n", this.getName());
            break;
          }
          try {
            task.run();
            System.out.printf("[%s] - 스레드 작업 종료\n", this.getName());
          } catch (Exception e) {
            System.out.printf("[%s] - %s\n", this.getName(), e.getMessage());
          } finally {
            workers.add(this);
            System.out.printf("[%s] - 스레드풀로 되돌아 감\n", this.getName());
          }
        }
      }
    }
  }

  public void execute(Runnable task) {

    if (stopping) {
      // RuntimeException을 사용하면 public void execute(Runnable task) 에서 예외를 던지지 않아도 된다.
      throw new RuntimeException("스레드풀이 종료 상태입니다.");
    }

    Worker t;
    if (workers.size() == 0) {
      t = new Worker();
      System.out.printf("[%s] - 스레드 생성\n", t.getName());
      t.start();

      try {
        Thread.sleep(20);
      } catch (Exception e) {
      }
    } else {
      t = workers.remove(0);
      System.out.printf("[%s] - 스레드 재사용\n", t.getName());
    }

    t.setTask(task);
  }

  public void shutdown() {
    try {
      this.stopping = true;

      while (!workers.isEmpty()) { // 스레드풀에 대기 중인 스레드가 있다면
        Worker worker = workers.remove(0); // 맨 앞에 있는 스레드를 꺼내서
        synchronized (worker) {
          // 스레드를 깨운다.
          // 스레드는 깨어나면 stopping 상태에 따라 종료 여부를 결정하도록 프로그래밍 되어있다.
          // worker 스레드를 보라.
          worker.notify();
        }
      }

      // 아직 스레드풀에서 대기하지 않고 현재 작업을 수행하는 스레드가 있을 수 있다.
      // 그 스레드가 작업을 끝낼 때까지 좀 기다리자
      Thread.sleep(2000);

      // 다시 한 번 대기하고 있는 스레드를 종료해보자.
      while (!workers.isEmpty()) { // 스레드풀에 대기 중인 스레드가 있다면
        Worker worker = workers.remove(0); // 맨 앞에 있는 스레드를 꺼내서
        synchronized (worker) {
          // 스레드를 깨운다.
          // 스레드는 깨어나면 stopping 상태에 따라 종료 여부를 결정하도록 프로그래밍 되어있다.
          // worker 스레드를 보라.
          worker.notify();
        }
      }


      // 예외 처리를 한다.
    } catch (Exception e) {
      System.out.println("스레드풀을 종료하는 중에 예외 발생");
      e.printStackTrace();
    }

  }
}
```

# 36-b 

## 스레드풀을 자바에서 제공하는 것으로 변경

```java
public class ServerApp {

  static boolean stop = false;

  // 스레드풀 준비
  ExecutorService threadPool = Executors.newCachedThreadPool();

  static Map<String,Object> context = new Hashtable<>();

  List<ApplicationContextListener> listeners = new ArrayList<>();

  public void addApplicationContextListener(ApplicationContextListener listener) {
    listeners.add(listener);
  }

  public void removeApplicationContextListener(ApplicationContextListener listener) {
    listeners.remove(listener);
  }

  private void notifyApplicationContextListenerOnServiceStarted() {
    for (ApplicationContextListener listener : listeners) {
      listener.contextInitialized(context);
    }
  }

  private void notifyApplicationContextListenerOnServiceStopped() {
    for (ApplicationContextListener listener : listeners) {
      listener.contextDestroyed(context);
    }
  }

  public void service(int port) {

    notifyApplicationContextListenerOnServiceStarted();

    try (ServerSocket serverSocket = new ServerSocket(port)) {
      System.out.println("서버 실행 중...");

      while (true) {
        Socket clientSocket = serverSocket.accept();

        if (stop) {
          break;
        }
        threadPool.execute(() -> handleClient(clientSocket));
      }

    } catch (Exception e) {
      e.printStackTrace();
    }

    notifyApplicationContextListenerOnServiceStopped();

    // 스레드풀을 종료한다.
    threadPool.shutdown();

    // 스레드풀을 종료한다.
    try {
      if (!threadPool.awaitTermination(10, TimeUnit.SECONDS)) {
        System.out.println("아직 종료 안된 작업이 있다.");
        System.out.println("남아 있는 작업의 강제 종료를 시도하겠다.");
        threadPool.shutdownNow();

        if (!threadPool.awaitTermination(5, TimeUnit.SECONDS)) {
          System.out.println("스레드풀의 강제 종료를 완료하지 못했다.");
        } else {
          System.out.println("모든 작업을 강제 종료했다.");
        }

      }

      System.out.println("main() 종료!");
    } catch (Exception e) {
      // 예외는 무시한다.
    }
  }
.
.
.
}
```

# DBMS

## 개발자가 직접 데이터 관리를 위해 파일을 조작할 때
- 임의의 위치에 있는 값을 변경?
- 특정 조건에 해당하는 데이터를 찾기?
- 특정 조건의 데이터 삭제?
- 대량의 데이터를 다루기 쉽게 어떤 기법으로 여러 파일로 분산할 것이냐?
- 데이터와 데이터 간의 관계를 어떻게 관리할 것이냐?
- 유효하지 않은 데이터 조작
    - 많은 코딩, 중복 개발 => Data 관리 전문 S/W => DBMS
    - 상용으로 쓸 수 없다.

## DBMS
- 데이터 관리 전문 소프트웨어
- DataBase Management System
- 예) 
    - (외산) Oracle, My-SQL, MS-SQL, DB2, 
    - (국산) Altibase, Cubrid, Tibero

