---
layout: post
title:  "PMS TLI"
categories: PMS
layout : single
toc : true 
toc_sticky : true
---

# pms project study

## pms 03

### Scanner 사용
- 클래스 밖에 import java.util.Scanner; 로 임포트를 해두면 사용하기 편하다.
- 사용법
    - Scanner sc = new Scanner(System.in);
- 사용이 끝나면 닫아줘야 한다.
    - sc.close();

### int를 스캐너로 받을 때
- int no = sc.nextInt();
- 숫자를 입력하고 엔터를 쳤을 때 nextInt()는 숫자만 읽어가고 엔터가 남는다.
- 이후 sc.nextLine();을 하면 남아있던 엔터가 읽혀서 원하는 문자열을 입력하지 못하게 된다.
- 이 문제를 해결하기 위해 nextInt(); 아래에 nextLine();을 미리 삽입해서 엔터를 읽고 끝내도록 한다.

### 시작일과 종료일을 입력받을 때
- java.sql.Date 를 임포트한다.
- Date startDate = Date.valueOf(sc.nextLine()); 으로 받는다.

### 상태를 입력받을 때
- int status = Integer.valueOf(sc.nextLine()); 으로 입력받는다.
- 출력 시에 조건문을 사용한다.
- switch 문을 사용해서 조건문을 출력한다.

## pms 04

### 배열을 사용해서 변수 배열을 새로 만든다.
- String[] 변수이름 = new String[갯수];
- 위에서 배열로 정의한 변수는 아래 조건문에서 앞에 String을 붙이지 않아도 된다.

### 반복문을 돌릴 때 횟수가 늘어날 때 아래쪽에 size를 붙인다.

### 배열의 길이를 변수로 따로 지정해서 관리한다.
- final을 붙여서 상수로 관리하면 아래쪽에서 변경되지 않는다.

### switch 문을 써서 진행중, 완료, 신규를 나눠서 표시할 수 있다.
- 배열로 바꿨을 때 상태표시를 나타낼 스트링 변수를 하나 준비한다.
- 그 변수에 진행중, 완료, 신규를 넣는 스위치 문을 만들어서 출력 부분에서 변수를 출력한다.

## pms 05

### 명령어를 반복해서 받을 때는 while 문을 사용한다.
- while 문이 언제나 참이면 무한 루프가 되기 때문에 loop를 사용해서 원하는 구간을 반복시키고 빠져나갈 수 있도록 한다.

### 명령어 입력을 받아 명령을 구별할 때는 switch 문을 사용한다.
- 케이스에 따라 명령 구분이 가능한 스위치 문을 사용한다.


## pms 06

### 변수들은 다른 메서드에서도 사용할 수 있도록 스태틱을 붙인다.

### 메인 메서드에는 메서드 호출만 하도록 만든다.

### 호출당하는 메서드들은 스태틱을 붙인다.

### 명령 입력문을 프롬프트 메서드로 만든다.
- 프롬프트 메서드의 파라미터를 스트링으로 받는다.
- 입력받는 기능에 프롬프트 제목을 바꿀 수 있게 만든다.
- 리턴하는 값에 맞춰 리턴 타입을 정한다.
- 메소드명은 아규먼트 타입에 맞춰서 알아보기 쉽게 적는다.
- 리턴할 때 파라미터가 스트링이기 때문에 스트링을 인트와 데이트 타입으로 바꿔서 리턴해야 한다.

## pms 07

### (add) static 변수를 클래스로 묶었을 때
- class 로 인스턴스 메모리를 만들 때 타입과 이름만 지정한다.
- 배열로 되어있을 필요가 없다.

### (add) 클래스로 인스턴트를 만들 때
- 멤버 인스턴스를 담을 레퍼런스 배열을 만들어야 한다.
- 길이와 사이즈는 클래스에 포함하지 않는다.

### (add) 회원 정보를 담을 메모리 생성

### (add) 인스턴스 주소를 레퍼런스 배열에 저장

### (list) 레퍼런스 배열에서 인스턴스 주소를 꺼내서 레퍼런스 변수에 저장.

### add 의 반복문은 지워줘야 add 메서드를 한번 완료하고 빠져나온다.

## pms 08

### 프롬프트, 멤버 핸들러, 프로젝트 핸들러, 태스크 핸들러로 분리시킬 때 앞에 클래스 주소를 붙여준다.

## pms 09

### util 패키지를 새로 만들어서 프롬프트를 옮긴다.
- 이때 public 으로 공개를 한다.

## pms 10

### findByName 클래스를 만들 때
- 회원 정보를 담을 인스턴스가 필요하다.

### 이름을 공란으로 처리하는 명령을 만들때는 문자열 길이를 비교하는 것이 좋다.

## pms 11

### 보드 핸들러를 만들 때 퍼블릭 클래스 이름과 스태틱 클래스 이름을 헷갈리지 않도록 주의한다.

## pms 12

## pms 15
- 프라이빗으로 숨기고
- 게터, 세터 사용

## pms 16
- 리스트를 각각 나눠서 사용하니 번잡하기 때문에
- 어레이리스트 하나를 만들고 배열 타입을 오브젝트로
- 오브젝트로 하니까 아무 주소나 다 담을 수 있어서 제네릭을 사용해서 무엇을 담을지 미리 지정

## 17

### 18. CRUD

### 19. 배열 대신 연결 리스트 자료구조 사용하기

### 20. 스택 자료구조 구현과 활용

### 21. 큐 자료구조 구현과 활용

### 22. 상속 : 일반화(generalization)를 이용한 공통점 분리

### 23. 추상 클래스와 추상 메서드

### 24. 인터페이스를 활용한 객체 사용 규칙 정의

### 25. `Iterator` 디자인 패턴

### 26-a. 중첩 클래스 : 스태틱 중첩 클래스(static nested class)
### 26-b. 중첩 클래스 : 논스태틱 중첩 클래스(inner class)
### 26-c. 중첩 클래스 : 로컬 클래스(local class)
### 26-d. 중첩 클래스 : 익명 클래스(anonymous class)

### 27. 자바 컬렉션 API 사용하기

### 28-a. 'Command' 디자인 패턴을 적용하기 : 메서드를 객체로 분리하기
### 28-b. 'Command' 디자인 패턴을 적용하기 : Map 을 이용한 커맨드 객체 관리

### 29. 예외가 발생했을 때 시스템을 멈추지 않게 하는 방법

### 30-a. 파일 입출력 API : 바이너리 형식으로 데이터를 읽고 쓰기(FileInputStream/FileOutputStream)
### 30-b. 파일 입출력 API : 데코레이터 객체 활용하기(DataInputStream/DataOutputStream)
### 30-c. 파일 입출력 API : 버퍼 사용하기(BufferedInputStream/BufferedOutputStream)
### 30-d. 파일 입출력 API : 객체 읽고 쓰기(ObjectInputStream/ObjectOutputStream)
### 30-e. 파일 입출력 API : 리팩터링 I

### 31-a. 파일 입출력 API : 텍스트 형식(CSV 파일 포맷)으로 데이터를 읽고 쓰기(FileReader/FileWriter)
### 31-b. 파일 입출력 API : 버퍼 사용하기(BufferedReader/BufferedWriter)
### 31-c. 파일 입출력 API : 리팩터링 I
### 31-d. 파일 입출력 API : 리팩터링 II

### 32. JSON 형식으로 객체를 읽고 쓰기 : Gson 라이브러리 활용

### 33-a. `Observer` 디자인 패턴 : 프로젝트에 적용하기
### 33-b. `Observer` 디자인 패턴 : `Observer` 객체를 통해 파일 다루기

### 34-a. 네트워크 API를 활용한 C/S 아키텍처 : 클라이언트/서버 프로젝트 준비
### 34-b. 네트워크 API를 활용한 C/S 아키텍처 : 간단한 메시지 송수신
### 34-c. 네트워크 API를 활용한 C/S 아키텍처 : 사용자가 입력한 명령처리
### 34-d. 네트워크 API를 활용한 C/S 아키텍처 : 응답 프로토콜 변경
### 34-e. 네트워크 API를 활용한 C/S 아키텍처 : 다중 클라이언트의 요청 처리
### 34-f. 네트워크 API를 활용한 C/S 아키텍처 : 다중 클라이언트의 동시 접속 처리
### 34-g. 네트워크 API를 활용한 C/S 아키텍처 : PMS 코드를 C/S로 분리

### 35. 동일한 자원으로 더 많은 클라이언트 요청을 처리하는 방법 : Stateful을 Stateless로 전환하기

### 36-a. 스레드풀을 이용하여 스레드를 재사용하기 : 스레드풀 구현하기
### 36-b. 스레드풀을 이용하여 스레드를 재사용하기 : 자바에서 제공하는 스레드풀 사용하기

### 37-a. 데이터 관리를 DBMS에게 맡기기 : JDBC API 사용하기
### 37-b. 데이터 관리를 DBMS에게 맡기기 : SQL 삽입 공격과 자바 시큐어 코딩
### 37-c. 데이터 관리를 DBMS에게 맡기기 : 무결성 제약 조건 다루기
### 37-d. 데이터 관리를 DBMS에게 맡기기 : 무결성 제약 조건 다루기 II

### 38-a. 데이터 처리 코드를 별도의 클래스로 분리하기 : DAO 클래스 도입
### 38-b. 데이터 처리 코드를 별도의 클래스로 분리하기 : DAO 인터페이스 도입
### 38-c. 데이터 처리 코드를 별도의 클래스로 분리하기 : 의존 객체 주입과 DB 커넥션 객체 공유하기
### 38-d. 데이터 처리 코드를 별도의 클래스로 분리하기 : 트랜잭션이 필용한 이유

### 39. 로그인/로그아웃 구현하기 : 사용자 인증(authentication)하기

### 40-a. 커맨드 실행 전/후에 기능 추가하기: 디자인 패턴 적용 전
### 40-b. 커맨드 실행 전/후에 기능 추가하기: Chain of Responsibility 패턴 적용
### 40-c. 커맨드 실행 전/후에 기능 추가하기: init() 와 destroy()의 필요성

### 41-a. DB 프로그래밍 더 쉽고 간단히 하는 방법 : Mybatis 퍼시스턴스 프레임워크 도입
### 41-b. DB 프로그래밍 더 쉽고 간단히 하는 방법 : Mybatis 기타 기능 활용하기


### 42. MyBatis의 다양한 기능 활용법

### 43. DAO 구현체를 자동으로 만들기


### 37 - 애플리케이션 서버가 등장한 이유!

### 38 - 트랜잭션이 필요한 이유!

### 39 - 여러 스레드가 동시에 같은 커넥션을 사용했을 때 발생되는 문제와 해결책

### 40 - 스레드 로컬 변수를 활용하여 작업 간에 DB 커넥션 공유하기

### 41 - 커넥션 재사용을 위해 커넥션풀 적용하기




### 46 - 객체 생성을 자동화하는 IoC 컨테이너 만들기

### 47 - IoC 컨테이너 개선 : 애노테이션을 이용한 객체 관리

### 48 - 인터페이스 대신 애노테이션으로 메서드 구분하기

### 49 - CRUD 메서드를 묶어 한 클래스로 분류하기

### 50 - Spring IoC 컨테이너 도입하기

### 51 - Spring IoC 컨테이너와 MyBatis 연동하기

### 52 - 애노테이션을 이용하여 트랜잭션 제어하기

### 53 - Log4j를 사용하여 애플리케이션 로그 처리하기

### 54 - Web 기술 도입하기





