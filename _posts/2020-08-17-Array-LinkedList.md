---
layout: post
title:  "ArrayList, LinkedList"
categories: TLI
layout : single
---

# 2020-08-17 TLI

## ArrayList
- 배열을 이용하여 컬렉션 클래스 만들기 : ArrayList
    - 배열의 크기가 고정되기 때문에 배열을 초과하여 값을 넣으려면 더 큰 새 배열을 만들고 기존 값을 복사해야 한다.
    - 배열의 크기가 늘어날 때마다 가비지가 새기는 문제가 있다.
    - 기본 배열의 값을 복사하기 때문에 속도가 느리다.

- contains() 와 equals() 의 관계
    - contains()는 해당 인스턴스와 같은 객체가 있는지 알아낸다.
    - contains()가 값을 비교할때는 인스턴스 주소가 아니라 equals()의 결과값이 true 인지 비교한다.
        - String 클래스의 경우 equals()를 오버라이딩 했기 때문에 서로 다른 인스턴스라도 값이 같으면 같은 객체로 간주한다.
        - equals()를 오버라이딩 하지 않으면 같은 값을 같더라도 인스턴스가 다르기 때문에 equals()의 결과가 false로 나온다.
    - contains()를 호출할 때는  equals()가 오버라이딩 되어 있는지 확인해야 한다.

- indexOf()
    - 특정한 값의 객체의 위치를 찾는 메서드.
    - indexOf()는 equals()를 사용하여 객체가 같은지 비교하여 값이 true일 때 indexOf()로 객체를 찾을 수 있다.
        - 오버라이딩이 되어있지 않다면 오버라이딩을 해야한다.

## LinkedList

### ArrayList vs LinkedList
- 1) 메모리
    - ArrayList
    - => 고정 크기를 갖는다.
    - => 크기를 초과하면 새로 배열을 만들어야 하기 때문에 메모리 낭비가 심하다.
    - => 기존 배열은 가비지가 되기 때문에 가비지가 과다 생산된다.
- LinkedList
    - => 값을 넣을 때마다 새 메모리가 추가되는 가변 크기를 가진다.
    - => ArrayList 보다 메모리 낭비가 적고 가비지를 덜 생산한다.
- 2) 속도
    - ArrayList
        - => 배열의 특징 상 인덱스를 이용하여 특정 항목을 찾을 때 속도 빠르다.
        - => 삭제할 때 이전 항목을 당겨와야 하기 때문에 속도가 느리다.
        - => 삽입할 때 현재 항목을 다음 항목으로 이동해야 하기 때문에 속도가 느리다.
- LinkedList
    - => 인덱스를 이용항 특정 항목을 찾을 때 리스트의 처음부터 찾아야 하기 때문에 속도가 느리다.
    - => 삭제할 때 이전 항목과 다음 항목을 바로 연결하면 되기 때문에 속도가 빠르다.
    - => 입력할 때 현재항목과 다음 항목을 새 항목과 연결하면 되기 때문에 속도가 빠르다.

### LinkedList 구조
- Node 는 value 와 next 로 구성되어 있다.
